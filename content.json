{"meta":{"title":"你是我心中不灭的光","subtitle":"","description":"猫耳堀川雷鼓的杂物间，好像什么东西都会放的样子（￣▽￣）","author":"猫耳堀川雷鼓 / neko-horikawaraiko","url":"https://neko-horikawaraiko.github.io","root":"/"},"pages":[{"title":"","date":"2023-05-07T16:39:01.866Z","updated":"2023-05-07T16:39:01.866Z","comments":true,"path":"/404.html","permalink":"https://neko-horikawaraiko.github.io/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"我的朋友们","date":"2023-05-07T16:01:49.116Z","updated":"2023-05-07T16:01:49.116Z","comments":true,"path":"friends/index.html","permalink":"https://neko-horikawaraiko.github.io/friends/index.html","excerpt":"","text":""},{"title":"","date":"2024-03-10T09:15:19.071Z","updated":"2024-03-10T09:15:19.071Z","comments":true,"path":"about/index.html","permalink":"https://neko-horikawaraiko.github.io/about/index.html","excerpt":"","text":"pid=73896157 现东游鉴成员，东方二次同人游戏收集者 自学日语、绘画（绘画鸽好久了，AI都出来了）中 大概和本体一样，半抖S半抖M的感觉 挖过打車万全作的坑，但实际实际已经坑了 作品名 Easy Normal Hard Lunatic Extra 东方灵异传 东方封魔录 √ √ √ √ √ 东方梦时空 √ √ 东方幻想乡 √ √ √ √ √ 东方怪绮谈 √ √ √ √ √ 东方红魔乡 √ √ √ √ √ 东方妖妖梦 √ √ √ √ Extra、Phantasm 东方萃梦想 √ √ 东方永夜抄 √ √ √ √ √ 东方花映塚 √ √ √ 东方文花帖 Level 7 完成 东方风神录 √ √ √ √ √ 东方绯想天 √ √ √ √ √ 东方地灵殿 √ √ √ √ √ 东方星莲船 √ √ √ √ √ 东方非想天则 √ 东方文花帖DS Level 6 完成 妖精大战争 √ √ √ √ √ 东方神灵庙 √ √ √ √ √ 东方心绮楼 √ √ 东方辉针城 √ √ √ √ √ 弹幕天邪鬼 √（ni进度 56 / 75 ） 东方深秘录 √ √ √ 东方绀珠传 √ √ √ √ √ 东方凭依华 √ √ √ √ Overdrive 东方天空璋 √ √ √ √ √ 秘封噩梦日记 √ 东方鬼形兽 √ √ √ √ √ 东方刚欲异闻 - √ - 东方虹龙洞 √ √ √ √ √ 弹幕狂们的黑集市 √ 东方兽王园"},{"title":"","date":"2024-11-03T09:36:26.256Z","updated":"2024-11-03T09:36:26.256Z","comments":true,"path":"gameList.html","permalink":"https://neko-horikawaraiko.github.io/gameList.html","excerpt":"","text":"表格点击表头可排序，如果点两下表头没反应就F5刷新就好了 总序号 游戏名 类型 作者 简介 1 東方靈異伝 ～ Highly Responsive to Prayers. 动作 ZUNSOFT 东方第一作，打砖块 2 東方封魔録 ～ the Story of Eastern Wonderland. 飞行射击 ZUNSOFT 东方第二作，没有低速和判定点的stg 3 東方夢時空 ～ Phantasmagoria of Dim.Dream. 飞行射击 ZUNSOFT 东方第三作，没有低速和判定点的对战stg 4 東方幻想郷 ～ Lotus Land Story. 飞行射击 ZUNSOFT 东方第四作，加入了低速和擦弹的stg 5 東方怪綺談 ～ Mystic Square. 飞行射击 ZUNSOFT 东方第五作，比较像现代东方stg结构的stg 6 東方紅魔郷 ～ the Embodiment of Scarlet Devil. 飞行射击 上海アリス幻樂団 东方第六作，现代东方stg第一作，有了满P后收点线 7 東方妖々夢 ～ Perfect Cherry Blossom. 飞行射击 上海アリス幻樂団 东方第七作，开始有了低速判定点显示 8 東方萃夢想 ～ Immaterial and Missing Power. 格斗 上海アリス幻樂団、黄昏フロンティア 东方第7.5作，第一次合作格斗 9 東方永夜抄 ～ Imperishable Night. 飞行射击 上海アリス幻樂団 东方第八作，可以不满P上线手动全收点，集大成之作 10 東方花映塚 ～ Phantasmagoria of Flower View. 飞行射击 上海アリス幻樂団 东方第九作，相当成熟的对战stg 11 東方文花帖 ～ Shoot the Bullet. 飞行射击 上海アリス幻樂団 东方第9.5作，弹幕摄影第一作 12 東方風神録 ～ Mountain of Faith. 飞行射击 上海アリス幻樂団 东方第十作，没有擦弹系统但还有擦弹特效的东方stg，上线可直接收点 13 東方緋想天 ～ Scarlet Weather Rhapsody. 格斗 上海アリス幻樂団、黄昏フロンティア 东方第10.5作，加了天气系统的格斗 14 東方地霊殿 ～ Subterranean Animism. 飞行射击 上海アリス幻樂団 东方第11作，信号系统 15 東方星蓮船 ～ Undefined Fantastic Object. 飞行射击 上海アリス幻樂団 东方第12作，UFO系统，东方stg难度之巅 16 東方非想天則 ～ 超弩級ギニョルの謎を追え 格斗 上海アリス幻樂団、黄昏フロンティア 东方第12.3作，东方地面格斗游戏之巅，可与绯想天合体 17 ダブルスポイラー ～ 東方文花帖 飞行射击 上海アリス幻樂団 东方第12.5作，弹幕摄影，加了新角色姬海棠果 18 妖精大戦争 ～ 東方三月精 飞行射击 上海アリス幻樂団 东方第12.8作，冰冻系统小品stg 19 東方神霊廟 ～ Ten Desires. 飞行射击 上海アリス幻樂団 东方第13作，神灵系统 20 東方心綺楼 ～ Hopeless Masquerade. 飞行射击 上海アリス幻樂団、黄昏フロンティア 东方第13.5作，空中格斗第一作 21 東方輝針城 ～ Double Dealing Character. 飞行射击 上海アリス幻樂団 东方第14作，主系统无特殊，按照一次收点多少奖资源的特殊收点系统 22 弾幕アマノジャク ～ Impossible Spell Card. 飞行射击 上海アリス幻樂団 东方第14.3作，道具辅助型小品射击游戏，出现奖杯/称号系统 23 東方深秘録 ～ Urban Legend in Limbo. 格斗 上海アリス幻樂団、黄昏フロンティア 东方第14.5作，空中格斗，引入神秘珠的神秘系统 24 東方紺珠伝 ～ Legacy of Lunatic Kingdom. 飞行射击 上海アリス幻樂団 东方第15作，完美无缺模式与章节模式 25 東方憑依華 ～ Antinomy of Common Flowers. 格斗 上海アリス幻樂団、黄昏フロンティア 东方第15.5作，双角色切换与合作的凭依系统 26 東方天空璋 ～ Hidden Star in Four Seasons. 飞行射击 上海アリス幻樂団 东方第16作，季节解放系统 27 弾幕アマノジャク ゴールドラッシュ デジゲー博スコアアタック専用ゲーム 飞行射击 上海アリス幻樂団 日本数码游戏博览会上zun展出的限时得分小游戏 28 黄昏酒場～Uwabami Breakers～ 飞行射击 呑んべぇ会 zun为首的酒鬼们组成的社团发布的小品级stg 29 闇のルーミア 动作 川獺アルカディア 仿星之卡比的动作游戏，流程不短有隐藏，但是手感不行 30 Sky Star Spark 动作 @N-Factory 是魔理沙就下30层 31 Necoro'n Dash 解谜 Bleck Rock ONE 猫车抬尸体，有点挖地小子感觉 32 MegaAri 动作 蓬屋ふらん 类似洛克人那个快速人关卡 33 東方大乱闘 动作 UTG Software 四人大乱斗游戏 34 Sora Suwa -そらすわ- 策略 壁際ヒッキー 双人连线成区域圈怪消除的游戏 35 チルノの願い叶エール♪ 动作 Waiei 找平衡类游戏 36 こんぱくの剣 解谜 松の木 单版面平台跳跃解谜游戏 37 飛べ!マリサ 动作 のんびり工房Nyamt 单关平台跳跃，有点在迷宫找出口的感觉 38 西方的正月 文字冒险 PTm（島國Perfect教團） 复古控制台型文字冒险游戏 39 Winter vs Spring 策略 BNelsey 抢占地盘那种抢占棋盘格的游戏 40 マリランカー 动作 PictureCode fc地底探险东方版 41 東方書斎宮 解谜 ごらんのすぽんさー 骰子贴着正方形格子翻面，相同点数凑一块消除 42 がんばれ幽々子さま 动作 トンカイモ 类似fc大金刚1 43 椛と不思議の洞窟 角色扮演 BACK SPACE 不思议迷宫式随机地牢探索游戏 44 ☆くまのねーさんのホームランダービー 模拟 無変換 打棒球的游戏 45 Alice in Spaceland 飞行射击 KoG flash做的stg，巨大判定+随机版面 46 Eat the Bullet 飞行射击 BNelsey 幽幽子吃小碎骨弹幕的耐久型stg 47 Frozen Magic 飞行射击 - ⑨和爱丽丝的弹幕对战游戏 48 Reisen Rush / Remi Rush 飞行射击 BNelsey 也有点弹幕对战的感觉，周围一圈出一群打你一个，不好玩 49 YuukaShot 飞行射击 BNelsey NO.48那个游戏类型的一个手机游戏版本 50 イオシスのアレ 飞行射击 sin 那个特抽象永琳画像为背景的耐久stg 51 東方三角比 飞行射击 K.K. 小分辨率的一个单关stg 52 夜雀憐 文字冒险 Mosburger（モス） 夜雀主角黑白风文字冒险游戏 53 Mystia Dash 动作 BNelsey 平台跑酷游戏 54 Rumia Hunt 射击 BNelsey 有点像pvz的三叉豌豆的射击游戏 55 あいちる 模拟 BLUFF 摇老虎机的游戏 56 秘封ナイトメアダイアリー ～ Violet Detector. 飞行射击 上海アリス幻樂団 东方第16.5作，堇子主角拍照作 57 東方鬼形獣 ～ Wily Beast and Weakest Creature. 飞行射击 上海アリス幻樂団 东方第17作，动物灵系统 58 東方剛欲異聞 ～ 水没した沈愁地獄 动作 上海アリス幻樂団、黄昏フロンティア 东方第17.5作，官作第一个动作游戏，但是结构与官方格斗相似 59 東方虹龍洞 ～ Unconnected Marketeers. 飞行射击 上海アリス幻樂団 东方第18作，卡牌系统 60 バレットフィリア達の闇市場 ～ 100th Black Market. 飞行射击 上海アリス幻樂団 东方第18.5作，卡牌系统，出怪以一波一波出现进行，没有replay功能 61 Cont Last 动作 Rack Pinion 使用黑白翻转能力的平台跳跃游戏，只有躲机关没有攻击手段 62 東方虹華薬 TheGame 动作 こなぐすり、PEPOSOFT 仿洛克人游戏，但是没有相克链，画风精细难度高 63 Mystical Chain 动作 LION HEART 经典三魔女游戏，双人连携技系统 64 幻想紀行 动作，角色扮演 CUBETYPE、偽英国紳士団 地图有MMORPG那种风格，画面比较高端，但是单机，但是鸽了 65 宵闇伝説 动作 川獺アルカディア 塞尔达织梦岛东方版 66 東方獣王園 ～ Unfinished Dream of All Living Ghost. 飞行射击 上海アリス幻樂団 东方第19作，对战stg，保留了卡牌系统，剧情爆炸，没有replay功能 67 東方爆裂遊戯 动作 コスプレ喫茶娘々 炸弹人东方版，红魔乡主题 68 東方爆裂遊戯2nd 动作 コスプレ喫茶娘々 炸弹人东方版，序号68游戏续作，妖妖梦主题 69 Takkoman -Kouzatsu World- 动作 illuCalab -いるからぼ- 洛克人X式动作游戏，以精神污染怪物出名 70 バカルテットX 动作 ぺんぺん虫の紅茶 仿洛克人游戏，像素画很精细，难度高 71 Touhou Wandering Souls 动作 Estheone 经典横版平台跳跃清关动作游戏，难度不高且量大，就是一路上打起来没啥变化容易审美疲劳 72 がんばりみのりこ 动作 土佐研究所 秋姐妹主角横版平台跳跃清关动作游戏，手感比较舒服 73 ハクレイフリーマーケット 动作 BirdStrike 聚会游戏种类，两队分别往自己家搬东西比较总价格 74 めいどめいどめいず 动作 トッパツプラン 蕾咪主角横版平台跳跃清关动作游戏，打起来比较舒服，有点难度 75 非想天姬傳 动作 節操君 天子主角3D清关游戏，观感一般偏上，但是鸽了 76 美鈴とチルノの妖怪の山大冒険～大妖精を救え～ 动作 悠遊亭 悠遊亭早期动作游戏，不算太简陋但也手感不佳 77 仏とりっく響子ちゃん！ 动作 GATLING CAT 响子主角传统横版清关动作游戏，仅有远程攻击，死亡惩罚略高 78 東方SASA 动作 はちみつくまさん、神奈川電子技術研究所 利用射击反推力跑关的游戏，系统新颖 79 Yuuma Game 动作、解谜、射击 WOAH_MAAAN 尤魔吃弹幕，然后消消乐方式打怪的动作射击游戏 80 The Hunger of Yuyuko: Youmu’s Awakening 动作、射击 Syoudre 弹幕风ph3sx制作的动作游戏，仿塞尔达GB风格 81 妖々剣戟夢想 动作 あんかけスパ 妖梦主角3D动作游戏 82 東方紅輝心 动作 あんかけスパ 咲夜、蕾米双角色3D动作游戏，东方3D动作同人巅峰作 83 東方シンセカイ 动作 あんかけスパ 灵梦、魔理沙双角色3D动作游戏，画质提升但是机制变讨厌了 84 ヨイヤミダンサーズ 动作、音乐 tripper_room、以絵会友 根据音乐节奏来移动和攻击的动作游戏，玩起来又难又爽 85 びしばし東方 动作 アカ 格斗，小巧但能用多个人物，不过手感一般 ex-1 こいしの算数教室 教育 北極天盤 简单的算数flash游戏 ex-2 魔理沙的魔炮阵 动作 迷走ポタージュ 画个圈圈发魔炮 ex-3 FlappyRumia 动作 song_5007等人 东方版Flappy Bird ex-4 Nitori Dungeon 解谜 よもぎ 荷取找黄瓜的解谜动作游戏 ex-5 東方守銭道 飞行射击 はにぐら 微体量像素stg，但是只能从地上射击 ex-6 Lost children at the bamboo forest 角色扮演、射击 White Pikmin 微妙以撒感觉的小游戏 ex-7 MARISA MATRIX 飞行射击 Y-NRG SYSTEM 很爽的类街机风stg ex-8 東方養蜂場 飞行射击 魯鈍ジョン 单boss战的类东方stg，但是有点复刻怒首领蜂的味道 ex-9 キャプテン・ムラサのケツアンカーオンザゲーム 动作 IOSYS、しまねこ工房 不明所以的村纱甩锚打怪游戏 ex-10 東方コンプガチャシュミレータ 模拟 北極天盤 抽卡模拟器 ex-11 しょぼんのアクション 动作 ちく 东方版猫里奥 ex-12 ずっとあたいのターン！ 教育 よもぎ 给日本人的学英语游戏 ex-13 東方一騎當千 射击 東方Flash小店 有点动作要素的擦弹射击 ex-14 快傑スワット 动作 Golden Pe Done、GATLING CAT、the Psalm of Dreamers 青蛙子横版过关 ex-15 東方人生終 － The end of the life 飞行射击 マオ 精神污染系stg ex-16 （红美铃同人横版弹幕） 飞行射击 - 只有一关的横版风神录，但是主角是红美铃 ex-17 東方奇怪録 动作 鬼姫 奇怪的横版清关，主角赤蛮奇 ex-18 Tencoinbox hero 动作 - 虐M子 ex-19 東方風々偽 飞行射击 紫茶店 手感比较差的一个stg ex-20 Touhou Contra 动作 galateasrbb 东方版魂斗罗，但不是fc上那个最经典的魂斗罗 ex-21 伊吹萃香の百万鬼鉄拳 动作 迷走ポタージュ 星之卡比附带的那种打拳小游戏 ex-22 Flandre's Quest 视觉小说 Rednal 芙兰主角的视觉小说 ex-23 touhou fabulous languaje party 飞行射击 chainedTan 像素横版简易stg ex-24 新春！夜雀羽根突きエクストリーム！２０１６ 动作 nagasapa 考验反应速度的夜雀击球游戏 ex-25 Ruby Mobius 飞行射击 水鳥（極彩レヴェリ） 难度较高的一个横版stg ex-26 アマノジャク Reverse 飞行射击 Raichu 影狼主角的弹幕天邪鬼 ex-27 藍さまが よくわからないけど ひたすら走るゲーム ＹＡＫＵＭＯ ＲＵＮ！ 动作 カレーライスゲノム 八云蓝横版跑酷 ex-28 Rumia Roller 动作 Gman8r ⑩主角的动作过关，有点解谜要素 ex-29 东方梦魂链 动作、角色扮演 ッ不动のKING 咲夜的横版清关游戏 ex-30 ルナチャイルドの最終防衛ライン2 动作 えなめる 露娜四面射敌 ex-31 ぞろぞろウォーズ 动作 オートリ電子/特殊装甲隊 猫车收幽灵群殴打怪的清关游戏 ex-32 あたいのにちじょう～いなくなった大ちゃん～ 飞行射击 Rightnya（ライト） 简单的⑨主角stg ex-33 東方店舗録～Combinations With You 飞行射击 魯鈍ジョン 单boss战的类东方stg ex-34 にとりタイプ 教育 SCN - Saikoro Club Network 金山打字东方版日语版 ex-35 Rush the 雛 动作 すい～と らぴーぬ 转转主角横版跳跃游戏 ex-36 東方仮名抄 ～ Sanae x Mystic Circle. 飞行射击 幽々燦々（ゆゆさんさん） ex-360度射击的横纵版stg ex-37 みんな大好き魂魄 动作 GATLING CAT 妖梦横版平台跳跃游戏，但是惯性巨大 ex-38 東方地平線 ～FlightSwitchOn！ 策略、角色扮演 オートリ電子/特殊装甲隊 战棋，难度挺高 ex-39 东方暴打油库里 动作 MyACG Studio 打地鼠 ex-40 东方仙华赋 飞行射击 - 东方x仙剑的stg ex-41 東方降魔伝プラス 动作 ニッキー 像素横版过关游戏，略难 ex-42 To Hole of Hell 动作 蒼月堂骨董店 是灵梦就下100层 ex-43 メイド イン ヘル！ 动作 ex-404 咲夜主角横版过关游戏 ex-44 東方迷路 解谜 松の木 走迷宫 ex-45 SUPER AKI SIMAI（スーパー秋姉妹） 动作 KORINDO 某个小游戏引擎做的平台跳跃动作游戏之一，超级秋静叶 ex-46 妖魔夜行 动作 牛乳屋 有点像fc马戏团的跳猴子 ex-47 ウンザンマニア 模拟 ひむかし 云山电子宠物机 ex-48 東方冷凍湖 飞行射击 CSG 两个笨蛋的stg，手感不好 ex-49 かっぱと神様 解谜 松の木 单版面解谜 ex-50 橙の冒険 解谜 松の木 横版卷轴解谜 ex-51 Touhou Puzzle League 解谜 いぬ研究所 对战型类三消游戏 ex-52 こんぱくの剣神霊廟編 解谜 松の木 单版面解谜 ex-53 伝説の胡瓜を求めて 动作 点睛集積 某个小游戏引擎做的平台跳跃动作游戏之一，但是难 ex-54 TypeNine 角色扮演 ちびっこ娘々 随机地牢，但是简易版 ex-55 とーとと:Re（仮） 策略 GridNote 画风相当精致（PatchyCon风）的像素回合制策略战棋 ex-56 平安のえいりあん 动作 すい～と らぴーぬ 挖坑埋毛玉的小游戏 ex-57 幻想もののけ絵巻 动作 何処かの点 像素风横版卷轴平台跳跃游戏，画面挺精致但是坑了 ex-58 ようようちれいでん 飞行射击 松の木 血槽制stg，但是游戏性不够 ex-59 ブンブンロジック 解谜 松の木 东方版数织 ex-60 レイセン ブロック崩し 动作 猫谷美甘（tailtame） 经典能打掉衣服的打砖块 ex-61 PAC･GYOKU･ROU 动作 East Spring 接近吃豆人的游戏 ex-62 Shiki Sama's Judgement 动作 Firecat1311 横版平台跳跃动作，itch上Touhou fan game jam 3的第一名 ex-63 東方桃月抄 ～ Pitch Peach Paradise 飞行射击 disfact 人气投票时候丰姬的应援小游戏，不射击的飞行射击 ex-64 東方☆らんだむだんじょん 冒险 IdxLab 有点像fc地底探险，但是要华丽点 ex-65 妖精大変装 飞行射击 ぱんついーと 带点养成要素的stg ex-66 橙地霊村 动作 atelierdorineko 东方版fc魔界村，但是要简单些 ex-67 うつほの地底脱出大作戦 飞行射击 耳小屋 感觉是某个常用来做rpg/act的引擎做的stg，与原作相差不小，略简单 ex-68 Sweet Delusions 解谜 Chirei 有点一笔画感觉的单屏平面找路型策略游戏 ex-69 秋屋とカボチャ 解谜 TeamInazuma 速记游戏 ex-70 魔理沙とアリスと不思議の森 解谜 春夏冬中 单屏平台跳跃型前往终点的策略解谜 ex-71 ようむゲー 动作 アカ 根据指令按键考反应力的游戏 ex-72 ちるばいと！ 动作 惑星まりも ⑨冻住人偶然后推走得分的小游戏，游戏性很高 ex-73 刹那の妖夢 动作 ZNP 听发令一击决斗那种考验反应力的小游戏 ex-74 Touhou fantastical pursuit 动作 White Pikmin、J’ Camilo、chainedTan 跑酷小游戏 ex-75 懐式倣緋萃 ～ NEARLY EASTERN STORY 格斗 時遊戯画 fc风格斗游戏 ex-76 符遊置楽宴 策略 Silly Rice、とし（無限旋律） 单一数字比较的卡牌游戏 ex-77 Youmu is a Zombie! 解谜 CookieGames 平面机关解谜那种策略游戏 ex-78 かえるなんてこおらせてやるわ！！ 动作 α-storage ⑨冻青蛙小游戏 ex-79 Recollection! Fantasy 动作 シグナスA-1 小⑤模仿星之卡比的游戏，手感僵硬 ex-80 なずゲーム、なずルーイン 解谜 牛乳屋 棋盘格上挖金子的策略游戏 ex-81 東方降神曲 格斗 ChaoticDawn fc游戏“热血进行曲”那种大乱斗格斗 ex-82 だてんこ 动作 α-storage 根据屏幕上运动着的不同角色驱逐或者收集的小游戏 ex-83 東方紅翔我 动作 ModForGame 红魔馆内打怪的3D平台跳跃过关游戏 ex-84 りりーのぶろっくくずし！ 动作 ほわいとふれあ（46flare） 莉莉白打砖块 ex-85 幽玄の幻夢零 动作 Keio Digital Vertex 仿洛克人系妖梦主角动作游戏，但是不下地 ex-86 Youkai Strike!! 策略 GhostlyFeline 台球感觉的撞球游戏 ex-87 HAKUREI JUMP 动作 同人サークルＧＥＮ 有点涂鸦跳跃感觉的跳跃游戏 ex-88 〇〇〇ノゲエム 动作 ねこもなか iwanna感觉的动作游戏 ex-89 おんりょうをもてあます 动作 α-storage 接球游戏，但是接的不是球 ex-90 紅魔郷4面魔道書地帯を作ろう 飞行射击 pls 红魔乡魔法书阵练习器 ex-91 The Shrine Maiden’s Subterrestrial Excursion 动作 White Pikmin 动作类，偏射击的随机地牢 ex-92 東方不要戦 ～ Fortuitous Strife in Arcane Land 飞行射击 Kousaku-P (NovaWare) 各方面仿旧作的stg ex-93 ようせいのおもちやばこ 解谜 ほわいとふれあ（46flare） 拼图、打砖块 ex-94 うなきゃっちゃー 动作 JavelinStudio 类似于接水果那种游戏 ex-95 This Is The Only Stage 动作 skipp This Is The Only Level翻版 ex-96 上海爆撃団～ 東方巡回帰番外編 飞行射击 T-noin 只有特殊攻击的stg ex-97 COOYAN(くーやん) 射击 智遊堂（ちゆうどう） fc猪小弟翻版 ex-98 ミョンムソー 动作 ZWEi 妖梦砍怪的横版动作小爽游 ex-99 Bun N' Gun 射击 Gman8r、Pigu-A、Vivid Turtle fc西部枪手的感觉的游戏 ex-100 サクヤノゲエム 动作 ねこもなか 类iwanna，与ex-88一样 ex-101 チルノのパーフェ外さんすう教 解谜 月のあくび 考瞬时记忆力小游戏 ex-102 妖精とこころの迷宮 角色扮演 ほわいとふれあ（46flare） 莉莉白和秦心主角的不思议迷宫 ex-103 Citadel of Celestial Cascades 动作 nadomodan 横版平台跳跃类动作游戏，妖梦像素风，好玩难度略高 ex-104 東方異迷宮 不思議な程度のダンジョン 角色扮演 agrippa 策略型随机地牢 ex-105 さとり様は大変な弾幕を想起させていきました 飞行射击 ごもく 文化帖Lv9的fc复刻 ex-106 Garden of Doll 解谜 Asterids 平面解谜过关游戏 ex-107 東方ロマンシングトレード 策略 ZNP 浪漫沙加3里面的trade小游戏复刻 ex-108 夜雀チャーム弾 飞行射击 耳小屋 魅惑菇式stg ex-109 B.Q.WARSバカルテットウォーズ 动作 迷走ポタージュ qq堂那种推箱子砸人 ex-110 東方短編集 视觉小说 蒼木 红魔馆相关的一个视觉小说，多人视角 ex-111 東方白色伝 视觉小说 蒼木 现界幻想入的人的视角的视觉小说 ex-112 たとえどんな切ない恋をしたって 视觉小说 うなだれ 跟幽香的恋爱小说 ex-113 mawaru marisa 动作 Cachi Córdova 大概也算是一种撞球游戏 ex-114 東方蛇封陣 动作 RECOIL 类似Qix的游戏 ex-115 レイセンの悪夢 动作 カナ江 平台跳跃动作游戏，不错的像素风但是难度很高 ex-116 ヘカッティアブロックバベル 动作 青山有人 3D打砖块，但不正统打砖块 ex-117 YUKARI'S CREVICE 动作 みすたぁさいど☆ふぇいす 紫妹靠隙间传送的微解谜平台闯关游戏 ex-118 もてなせ！にとりちゃん 文字冒险 mizusoba（いすぃ） 爱雏大师的文字冒险游戏作，转转招待荷取 ex-119 동방 브레이크（東方Break） 动作 pictorial 横版打砖块 ex-120 なげるーみあ！ 动作 土佐 露米娅拿箱子砸怪的小解谜，甚至可以坐在扔出去的箱子上。挺好玩小游戏 ex-121 Lost Donation Box Incident 飞行射击 Nihirash! 有点那种判定大子弹稀疏体术多的复古stg感觉 ex-122 東方氷禄弾 飞行射击 LIMIT CYCLE 简单版妖精大战争？ ex-123 Fly Marisa Fly 飞行射击 2D Emotion stg，但是主要躲子弹而不是打 ex-124 東方腐卵臭っぽいもの 动作 悠遊亭 目标抓芙兰的平台跳跃式动作游戏 ex-125 Super Marisa World 动作 弐重クラスター 东方版马里奥+1 ex-126 东方梦月抄 飞行射击 - 大概是儚月抄故事的stg ex-127 ボン・メイリン（BOMB MEIRIN） 动作 D.N.A.Softwares 半个炸弹人类型，不过炸的范围是圆形而不是十字，另外可以射击打怪 ex-128 Touhou Bounce Bounce Ball 动作 EiZi 有点特殊操作的弹球打砖块那种游戏 ex-129 東方秋神録 ～ Every day of Autumn 飞行射击 黒幕機関 秋姐妹的stg ex-130 漫步在幻想乡 pv 疯帽子茶会 漫步在幻想乡歌曲pv，但是rpgmaker制作 ex-131 ⑨式 角色扮演 ちびっこ娘々 复古UI风的随机地牢rpg ex-132 東方文々。新聞～新聞大賞への道～ 模拟 苺兄貴 模拟文文发现大新闻，然后从零开始瞎编报纸的游戏 ex-133 幻想キネ子伝 〜宇佐見菫子の弾幕実習 飞行射击 学芸幻想郷研究会 自机没法射击，但是根据敌方弹幕重排屏幕区块位置，和拼图似的 ex-134 東方探偵録 弐 文字冒险 みかん茶 红魔馆主题侦探断案游戏 ex-135 東方暴れん坊天狗 飞行射击 N2De - Garena 横版stg，但是flash制作 ex-136 すい～と・くらんぶる（Suite Crumble） 音乐 すい～と らぴーぬ 大概算是4key无长条无横滑的音乐游戏 ex-137 小傘のこんにゃく大作戦 飞行射击 UTG Software 只能躲弹幕的stg ex-138 群弾 策略、射击 D.N.A.Softwares 两军对垒，但是弹幕战 ex-139 レイムノゲェム 动作 ねこもなか iwanna ex-140 東方吸闘紀 动作 さくらんぼ亭 大概星之卡比梦之泉，但是更粗糙 ex-141 ころころれいむ ちゅー / ころころれいむ 动作游戏 ReadyToCreate 灵梦可以变身阴阳玉来攻击和做点小解谜的平台跳跃 ex-142 霧雨陰陽伝 The Brawl Between Life and Death 飞行射击 Mark Li 手绘黑白风横版stg，可惜只有一关 ex-143 ゆっくりボウルDX 动作 agrippa 带点符卡的类台球游戏，还有点像高尔夫 ex-144 雛ちゃんのリポート万歳 文字冒险 mizusoba（いすぃ） 爱雏大师的文字冒险游戏作，转转去做电视报道情景 ex-145 雛ちゃんSOS 文字冒险 mizusoba（いすぃ） 爱雏大师的文字冒险游戏作，转转在森林迷路的情景 ex-146 東方月下祭 动作 無邪氣工房 类似Qix的游戏 ex-147 私のお嬢様 视觉小说 いろは 咲夜陪蕾米玩的视觉小说 ex-148 Touhou mix 音乐 kailang 仿兰空voez的音乐游戏，国人制作，多端上线 ex-149 東方大作戦 动作 大往生 解压爽游 ex-150 アリスブレイカー 动作 小松菜屋 爱丽丝骑人偶的跑酷游戏 ex-151 神魔討綺伝 ～ Magus in Mystic Geometries 动作 D.N.A.Softwares 一边躲一边射击打怪，有点现在那种地牢感觉，2un给做过一首曲子 ex-152 Mima's new life 动作 Tristama 魅魔主角横版平台跳跃类动作游戏 ex-153 The underground Heist 动作 White Pikmin 动作类，偏射击的随机地牢，ex-91哪个游戏的加强版 ex-154 フルモッコにしてやんよ! 动作 ZWEi 妹红主角横版过关，打击感有点差 ex-155 东方启示录2：核子危机 动作 九州烽火工作室 rpgmaker做的动作游戏，纯平台跳跃 ex-156 東方紅魔弾 动作 同人サークルＧＥＮ 平台跳跃类动作游戏，主弹幕，所以比较难 ex-157 Wriggle Story 动作 GlowGloat 平台跳跃类动作游戏，插点stg要素、解谜要素，但是挺有趣 ex-158 ソードマスターテンシ 动作 ぴお 画风吓人，但是拿剑砍起来挺爽，难度有点不合理 ex-159 東方幣札遊戯 动作 神奈川電子技術研究所 单版面清关的游戏，可近战可远程 ex-160 蛮々奇々~ give me neck 动作 non-study 平台跳跃类动作游戏，赤蛮奇用头当控制系回旋镖用 ex-161 クロックコープス 动作 人形機械論 咲夜射飞刀打幽灵的平面类动作爽游 ex-162 ナズーリンの探しもの 动作 Little Prayer 平台跳跃类动作游戏，属于只考操作的类型，走到终点去找到丢失的宝塔 ex-163 疾きこと文の如し 动作 α-storage 地铁跑酷式跑酷类型游戏 ex-164 こまフル 动作 礼門屋 角色可随时切换的平台跳跃动作游戏，但是血量和没有似的 ex-165 弾けぬものなどあんまりない 动作 rack pinion 一次机会几条命闯全关式动作游戏，平面型地图，画风比较纸片的感觉 ex-166 ソウルアンカー2 动作 ZWEi 平台跳跃过关式动作游戏，有些长距离对岸专门设计村纱扔锚钩钩子通过 ex-167 マリサランド·レガシー 动作 黄昏フロンティア 仿马里奥，不同尺寸角色不同能力，可以多人同屏，kk做过直播 ex-168 チルダッシュ 动作 rack pinion 有点仿马里奥，但是强制滚动卷轴 ex-169 桜花蒐集録 动作 絶望リンカエラー 3D平台跳跃动作游戏，主收集 ex-170 うどりん 动作 悠遊亭 悠遊亭经典仿洛克人游戏之一 ex-171 ネムノリズム 音乐 dBu music 形式比较简单的音游，类似muse dash，但是画面差远了 ex-172 こなぐすりの達人 音乐 すい～と らぴーぬ 跟ex-136一样 ex-173 東方探偵倶楽部 文字冒险 道草 大结界裂缝八云一家丢了俩，蓝妈找灵梦帮忙寻回紫妈修结界的故事 ex-174 どーるずうぉーきんぐ 模拟 萃符東方合同企画 养成爱丽丝的自立人形 ex-175 半月昇夜 视觉小说 道草 挂了的霖之助视角下的幻想乡 ex-176 しんれいびょーのおへや 模拟 ごましお 神灵庙系列电子宠物机 ex-177 レミリアのドキワク紅魔館～前編～ / ～後編～ 文字冒险 float counter 鬼屋找同伴 ex-178 東方弾幕崩 动作 すい～と らぴーぬ 把发出来的弹幕当砖块打 ex-179 虹色の監獄 视觉小说 毒電波新聞社 芙兰主角暗黑风视觉小说 ex-180 ゆっくりのある生活 模拟 月面玩具箱 电子宠物-油库里版 ex-181 雛ちゃんシースーロワイヤル 动作 mizusoba（いすぃ） 爱雏大师的反应力游戏作，转转吃寿司 ex-182 春告精を守れ！ 动作 ほわいとふれあ（46flare） 一心二用守护莉莉白的小游戏 ex-183 いるからぼっくす_PART1 动作 illuCalab -いるからぼ- illuCalab的小游戏合集，一个钻地，一个在伞上调，一个喂酒葫芦 ex-184 東方逢縁譚 视觉小说 とぅるてぃまどきゅーん！ 多视角的失忆妹红找记忆的视觉小说 ex-185 みらくる＠でぃざすたーず 角色扮演 すい～と らぴーぬ 有点简陋的地图探索类rpg ex-186 スワコチャンリフレクション 动作 UTG Software 愚人节特供游戏，像打砖块的打砖块 ex-187 東方ローグライク 角色扮演 ｋnow 简易版不思议迷宫 ex-188 七色の人形遣いの 続・人形創り 音乐 kurama 游戏给一遍，自己打一遍的模仿式音乐游戏 ex-189 ルーミアちゃんブロック崩し 动作 Bee Cradle（刺蜂） 给露米娅脱衣服的打砖块 ex-190 ゴムゴムぽん！ 动作 UTG Software 弹板可以斜着的打砖块，但是弹板是被“拖着走”的 ex-191 紅魔の鍵 解谜 同人サークルＧＥＮ 传统拿钥匙开门的解谜闯关游戏 ex-192 MARIALIDOLL～魔理沙伝～ 策略 すいかも▲共和国 fc《七龙珠3 悟空传》东方版 ex-193 EAT&BITE with東方 解谜 grayf Wordle那种猜单词模式的猜数字版 ex-194 妖精大回籠 解谜 ぱんついーと 可以版面回转的拿钥匙开门闯关解谜 ex-195 Touhou Yahtzee 策略 poltergasm Yahtzee快艇骰子的东方版 ex-196 东方淫乐乐 策略 漂亮同人堂 有点像windows自带纸牌那样的游戏，但这个根据牌摞张数打伤害 ex-197 妖精大穿功 解谜 ぱんついーと 解谜型射靶子游戏 ex-198 东方霁月牌 策略 千葉玖濑 抽牌类型四人棋牌对战 ex-199 東方でおちげー 解谜 FocasLens 方块下落式同色消除游戏 ex-200 東方水晶郷 解谜 ⑨、liqunsz 三消游戏 ex-201 東方どろっぷす 解谜 TMC GAMES 俄罗斯方块式搭桥让角色走到终点的解谜游戏 ex-202 東方ぱねたま 策略 天晴堂 有点挖宝形式的凑符卡条件，然后打弹幕战的游戏 ex-203 アリパチェ in Wonderworld 解谜 悠遊亭 双七合作（但是单人）进门过关解谜 ex-204 チルノでポン 解谜 無限旋律 只有横向移动的三消 ex-205 ばいなりぃすわちるの 解谜 UTG Software 一人控制镜像两个角色同时到达终点的游戏 ex-206 守矢神社の鍵 解谜 UTG Software 传统拿钥匙开门的解谜闯关游戏 ex-207 東方SRPG乱愚風 策略、角色扮演 春日町、智遊堂（ちゆうどう） 火纹类型回合制小队策略对战 ex-208 東方賭博録カグヤ 解谜 俺のマスタースパーク 多个概率小游戏合集 ex-209 波乱盤外！？香霖堂！ 策略 ルート 7回合的卡牌数值比较游戏 ex-210 東方牌乱符 策略 隣の世界（隣野みとも） 类麻将玩法 ex-211 ドSな早苗さんは切なくて霊夢ちゃんを見かけるとつい喧嘩売っちゃうの 大爆発 飞行射击 森の中の猫の小屋 早苗打灵梦的单关stg ex-212 ドSな早苗さんは切なくて小傘ちゃんを見るとすぐ虐めちゃうの 大往生 飞行射击 森の中の猫の小屋 早苗打小伞的单关stg ex-213 すたぁこいしあたっく！（Star Koishi Attack!） 飞行射击 森の中の猫の小屋 恋恋子机的循环关卡式stg ex-214 東方古魔郷 飞行射击 さいごめんのボス 红魔乡fc版 ex-215 東方環境破壊Touhou Kankyo Hakai - Parable of Irreplaceable Disposeables 射击 hp78、RaythalosM、RozenRozarai 只能捡子弹打的射击 ex-216 風 飞行射击 さくらもち製作所 带风向影响的stg ex-217 紅 飞行射击 さくらもち製作所 自机蕾米移动可以生成红雾消部分弹的stg ex-218 あやや 飞行射击 Noro 可以吹走子弹的stg ex-219 東方幻勇夢 ～ Brave and Darkness. 飞行射击 五層式洗濯機 普通单关stg，手感略滑 ex-220 Runtime Massacre 飞行射击 HP78、Lactose Intolerance、bentoreo、RozenRozarai 收集荷取类型，收集怨灵增加火力的stg ex-221 東方雨仰石 飞行射击 遊色高楼 雨淹幻想乡的著名鸽子stg ex-222 Touhou ~Unmei no Hoshi~ 東方運命の星 飞行射击 chronoDave pico8做的stg ex-223 東方紅夜翔 飞行射击 ちびっこ娘々 有点复古fc风的stg ex-224 超小傘 飞行射击 水鳥（極彩レヴェリ） neta超兄贵的stg ex-225 だんまくちくおんき / Newだんまくちくおんき 飞行射击、音乐 UTG Software 音乐节奏stg ex-226 蒐集王 飞行射击 Fairy dust 达人王 ex-227 Touhou 2: The Story of Eastern Wonderland NES Demake 飞行射击 Drillimation Systems fc风格复刻旧作封魔录 ex-228 東方虹夢化学 ～illegal Science～ 飞行射击 学芸幻想郷研究会 类似斑鸠利用颜色通关的stg ex-229 東方水晶宮 飞行射击 Fe 普通3关同人stg ex-230 萌える弾幕Stg もえだん 飞行射击 D.N.A.Softwares 弹幕躲法教学stg ex-231 ひがスト 2005 动作 前転受け身友の会 多人大乱斗 ex-232 Suwako in Pixiv 动作 UTG Software 类猫里奥的坑向平台动作游戏 ex-233 熱っ血東方格闘伝説 格斗 Mr.X、Ａ.Ｓoushi等 热血格斗东方版，出场人物挺多 ex-234 るみゃんランド 动作 魔道琥珀研究所 露米娅主角平台跳跃游戏 ex-235 東方落試合 动作 E,F,B～相手は死ぬ～ 平面式多人大乱斗 ex-236 白黒さん ～ 罰地の冒険 动作 SCN - Saikoro Club Network 忍者君阿修罗之章东方版 ex-237 鈴仙妖夢の活劇録 动作 悠遊亭 悠遊亭的又一仿洛克人游戏 ex-238 白黒大罰地 / 激！白黒大罰地 动作、射击 SCN - Saikoro Club Network 平台跳跃+远程打毛玉，难度很高 ex-239 チルノフリーザー 动作 ZWEi ⑨通过冰冻垫脚打怪的平台跳跃游戏 ex-240 Touhou project Magical Dinner below the full moon 动作冒险 chainedTan、White Pikmin、J' Camilo 咲夜到处收集食材做饭的小游戏 ex-241 PAD ATTACK 动作 galateasrbb 东方版绿色兵团 ex-242 図書館ではお静かに! 动作 専秋落 接水果式游戏 ex-243 幻想探索 にとろいど！ 动作冒险 ですのや☆ 荷取收集道具闯关的迷宫探索游戏 ex-244 走る！咲夜さん 动作 Y-Cubed 咲夜跑酷 ex-245 小町でアクション 动作 うたかたグラビティ 常见的横版动作清关游戏 ex-246 幻想郷大乱闘 动作 ごらんのすぽんさー 多人大乱斗游戏 ex-247 げんそうきょう ふぁんたじあ 动作冒险 こなぐすり、PEPOSOFT 2D风的2.5D探索游戏 ex-248 Spring Catastrophe 动作 ほわいとふれあ（46flare） 莉莉白的打怪收集道具+有点养成要素的动作游戏 ex-249 Touhou The Shrine Maiden 动作 fairyhell 有点仿三目童子的动作游戏 ex-250 妖魔ディスガイザー 动作 non-study 双人平台跳跃闯关游戏 ex-251 メディスンクイズ ～マイメランコリー～ 解谜 強鈴グリコシド 硬核东方知识+药学知识问答 ex-252 幻想砲劇詩 ～ Art of Curtain FireAggression. 策略 D.N.A.Softwares 地图比较开放的塔防 ex-253 Tactics on Fairy Fables 策略、角色扮演 ほわいとふれあ（46flare） 类似rpg那种行动条先手制的战棋 ex-254 東方十七歩 策略 illuCalab -いるからぼ- 日麻十七步的规则 ex-255 ふぉーちゅんすたー☆ぱにっく 解谜 ですのや☆ 一滑到底那种推箱子解谜 ex-256 グモンカードゲームGB 策略 S復旧アネデパミ 3张卡不太自走的自走棋 ex-257 異変のくせになまいきよ!! 策略 East Spring 塔能攻击、能挡怪、能移动的塔防 ex-258 まりさパーティ 策略 春夏冬中 大富翁加马里奥派对那种聚会派对游戏 ex-259 妖精カードローグ 策略 ほわいとふれあ（46flare） 类杀戮尖塔的卡牌游戏，但是地图没有分支路线 ex-260 パチュメンタルカード 策略 ルート 抽卡填上面前对应颜色场地的卡牌游戏 ex-261 弾幕パズル！ にとりの河登り 解谜 Keio Digital Vertex! 起点走到终点，限制步数的平面解谜 ex-262 東方風売買人（いーすととれーだーEast Trader） 策略 れつとれ 和ex-107一样的抢地游戏 ex-263 ⑨Driller 解谜 Blooming Creation 往下钻地，同颜色砖块可一块钻破的那种游戏 ex-264 ゆっくり撃っていってね! 策略 voidaste 保护食物不被油库里吃的塔防，但是食物是敌人，要给打掉 ex-265 Flee、fairies、flee! 解谜 Atrufulgium ⑨和皮丝合作闯关的双人游戏 ex-266 妖精大探双 解谜 ぱんついーと 平面解谜过关游戏，需要切换操作角色解谜 ex-267 Nitori & the One-Shot Cube 解谜 stak134 用一发子弹，凭借机制干掉所有敌人 ex-268 東方武闘外伝 解谜 夏季限定 超能力俄罗斯方块，不过方块提示槽里的方块是两人共用 ex-269 まりさとありす 解谜 ですのや☆ 一直在来回走的爱丽丝找路到达版面终点的单版面解谜 ex-270 うちの橙知りませんか？ 解谜 ルート 交替控制蓝妈和橙喵解谜过关 ex-271 雛ちゃんのリズム職場体験 音乐 mizusoba（いすぃ） 爱雏大师的音乐游戏 ex-272 ごうぞくっち 模拟 ごましお 神灵庙电子宠物第二代 ex-273 Suite Crumble 音乐 すい～と らぴーぬ 4key音乐游戏 ex-274 東方稗想録 视觉小说 とぅるてぃまどきゅーん！ 阿求主角视觉小说，稗田家的转生、记忆为主题 ex-275 Nitori's Factory 动作 NewProject 说是工厂拆机械，实际根据题目按键盘按键，有点像限定范围的打字游戏了 ex-276 秘封フラグメント 文字冒险 シカクゲームズ 从过往对话填字出当前对话答案的文字冒险游戏 ex-277 Pat The Ice Fairy 动作 Ferdy's Lab 拍拍⑨来治愈 ex-278 リズムバンキ 音乐 ぱらどっと 节奏天国空手道家的类型 ex-279 SUPER Patchouli's WHACK-A-KOA 64 动作 WRIT 打地鼠类型 ex-280 ちくしょうとあそぼ 模拟 ごましお 虹龙洞电子宠物 ex-281 霧雨探偵事務所 ～ 名探偵はじめました 文字冒险 ミストレイク遊撃隊 逆转裁判类侦探游戏 ex-282 东方逆转检事 文字冒险 墨雾归尘 逆转裁判风，梗很多 ex-283 こいしの旅 视觉小说 フォレスト 恋恋周游幻想乡的故事 ex-284 幻想小遊戯集 解谜、动作 すい～と らぴーぬ 小游戏集，问答游戏还有靠反应障碍跑之类 ex-285 東方 うー☆パチュRY ～鬼巫女の試練場～ 视觉小说、角色扮演 アルケミスト・ラボ 魔理沙帮灵梦调查大结界被破坏原因的故事 ex-286 東方永月譚 ～Capriccio of Imperishable Princess.～ 动作 キツネノヨメイリ 带剧情的打砖块 ex-287 魔理沙のコソ泥一番星! 文字冒险 キツネノヨメイリ 魔理沙去红魔馆偷书遇见的人和事 ex-288 ウルトラ健全ブロック崩し 动作 オートリ電子/特殊装甲隊 打砖块 ex-289 AerobeatPlus 音乐 Remical Soft 非东方，但是带了东方曲mod ex-290 幻想マリサカート 模拟 dBu music 赛车游戏，但是手感有点差 ex-291 チルノの東方紅防記 飞行射击 MOON GODDESS 防守类型stg，比较粗糙 ex-292 HOWLING COMMUNICATION 飞行射击 tboddy 像素风stg，限时打分 ex-293 伝説のホワイトカラス 飞行射击 弾幕魔術師リモネン 一般东方二创stg，但是难度很高 ex-294 東方妖精譚 飞行射击 アピー 画风很粗糙的stg，但是可以三自机同时上场打 ex-295 カリスマを取り戻せ 飞行射击 Hello World! 除了封面没啥让人有印象特点的stg ex-296 Thunder Faith 飞行射击 幽々燦々（ゆゆさんさん） 仿Thunder Force V代的横版难度较高的stg ex-297 幻想武勇传 ～ 儚月抄 飞行射击 幻想乡弹幕旅行社 第二次月面战争背景的stg ex-298 幻想追憶夢 ～ Lost Memory Regeneration 飞行射击 奇津祢宮 一般二创stg，资源给的有点少 ex-299 束方 嘘時空 ～ Fools_rush_in 飞行射击 トリック・ノスタルジー（JynX） JynX的仿梦时空对战stg ex-300 東方七色郷+ 飞行射击 人形機械論 横版stg，魔爱对打 ex-301 魔法少女ルーミアNANOKA 飞行射击 フラストレーション（Frustration） 横版stg，子弹不好区分，游戏整体不咋地，白瞎了立绘 ex-302 SUiCA32 飞行射击 D.N.A.Softwares 只是无限去打小萃香的游戏 ex-303 Cirno Gets Clever 飞行射击 yoship1639 收集打别人掉的IQ（属性点）来增强⑨自己IQ的横版stg，弹幕略仿原作，看好但有点难 ex-304 みすちーの交通事故 飞行射击 Javelin Studio 就一个BOSS对战的简易stg，只能蓄力攻击 ex-305 東方八華閃 飞行射击 LIMIT CYCLE 3D俯视角的stg，基本可以算作普通stg ex-306 Touhou 3: The Phantasmagoria of Dimensional Dreams NES Demake 飞行射击 Drillimation Systems fc风格复刻旧作梦时空，非常简单 ex-307 동방외요전（東方外妖傳） 飞行射击 Deer Farm 韩国产stg，会横竖stg互变，难度分配不合理 ex-308 ディガップ 飞行射击 E,F,B～相手は死ぬ～ 就只是挖石头的stg，没别的怪 ex-309 ルナチャイルドの最終防衛ライン3 飞行射击 ENAMEL SWORD！ 爽stg，略难，分数膨胀也厉害 ex-310 東方謎域関 ~ Puzzles from the Mystic Dimension 飞行射击 红石-RedstoneGate 不能射击的解谜向stg ex-311 うのとれ！ 策略 ルート 超能力uno ex-312 東方神医伝 解谜 夏季限定 多个相同色块在一起消除类型的消消乐 ex-313 I.⑨ – Intelligent Fool 解谜 illuCalab -いるからぼ- 炸掉迎面的砖块墙避免被挤下去的解谜 ex-314 東方殺 策略 Moligaloo（游戏引擎）、（东方mod未知） 三国杀东方版 ex-315 東方パズルだ全員集合？～弾は落ちても人気は落とすな～ 解谜 萃符合同企画 噗哟噗哟玩法 ex-316 東方スピード 解谜 天宮照雲 ppt做的解谜游戏 ex-317 A witch of memories 解谜 カジュアルゲームズ 微恐怖密室逃脱解谜 ex-318 ゴーストライターはたてちゃん 解谜 mizusoba（いすぃ） 羽立采风编新闻 ex-319 （未定名） 策略 Empty Earth Exit 卡牌与上下左右比数字大小的那种玩法 ex-320 story of a lost sky 策略 Feathered Melody 战棋 ex-321 东方虹龙牌 策略 我是游戏迷hh 虹龙洞卡牌打麻将 ex-322 東方タクティクス 策略 しそそふと 一个回合敌我同时会动的战棋 ex-323 波乱盤外！？香霖堂！～第弐章～ 策略 ルート 卡牌数值比较游戏，ex-209的续作 ex-324 東方碰雀牌 策略 しるふ・わーくす 只能碰的红魔馆主题麻将 ex-325 たすけて！おつかれさとり様 解谜 mizusoba（いすぃ） 根据提示猜东西 ex-326 Shrine of the Miko Dancer 解谜 Enalye、Automn'、Mrnuage、JonathKane 平面解谜，但是不能连续做同一个动作 ex-327 暇を持て余したレミリアの遊び 策略 ルート 根据规则一次出一张牌的跑得快 ex-328 幻想創縁結界 策略 ちびっこ娘々 己方塔防，然后即时战略攻占对方，有点像红警之类 ex-329 依姫めくり 策略 ルート 避免被抽的卡打死但是只有抽卡才能获胜 ex-330 霧雨農園 策略 同人サークルＧＥＮ 种田+塔防 ex-331 フェアリーゲーム 动作 闇討ちProject 三妖精去红魔馆捣乱，注意不要被抓到哦 ex-332 IBUKI 伊吹 动作 Mark Li、Prismriver Orchestra 实色风格萃香动作游戏，画面很干净手感也不错 ex-333 ゆっくり飛行玉 ～Fragile Ball Adventure～ 动作 LOG BOX 控制油库里飘进终点，但是油库里很容易碎 ex-334 ナズの宝塔探し 动作 康友いえんし 纳兹琳主角iwanna ex-335 きのコン！ ～Defend my sweet home!～ 动作 ～Alice Margatroid Project～ 爱丽丝清扫房子里的蘑菇，蘑菇长得速度越来越快，长满了就失败了 ex-336 Mikobuster 动作 Gensokyo Atomic Energy Agency 阿空主角3D洛克人，可惜没做完 ex-337 幻想郷どかすかウォーズ 动作 紅緑亭 3D大乱斗，但是因为是3D所以控制稍微麻烦点 ex-338 Castlemaze～お嬢様からの挑戦～ 动作 悠遊亭 恶魔城风格，手感和系统都模仿的很像那种 ex-339 巫女と吸血鬼 动作 kt住江 类似fc双截龙的游戏，打起来挺舒服的 ex-340 カラクリニトリ / カラクリニトリ弐 ~ Extend Mechanic Walts ~ 动作 絶望リンカエラー 灵活运用荷取各种道具跑关爬山的传统动作游戏 ex-341 早苗の信仰王への道 动作 みちるーむ 早苗守护双神建神社布教，主要坚持过时间而不是消灭捣乱的怪物 ex-342 Touhou: Hollow Hearts 动作 Yal 较为阴暗风的动作游戏，姆q秦心主角 ex-343 チルノくんの脇役最強伝説 动作 はちみつくまさん 热血格斗东方版 ex-344 チルノすてっぷ 动作 ZNP ⑨限时跳台阶的小游戏，注意不要碰到障碍物 ex-345 Touhou Shooter (Sakuya Flying Adventure) 动作 Prolophis 咲夜主角一对多的那种格斗，空中格斗 ex-346 ゲンソウフロードフロント 动作、解谜 FriendNavy 荷取主角动作解谜游戏，2.5D类型 ex-347 紅魔PANG! 动作 SPIERAL WIND PANG系列游戏东方版，但是很粗糙 ex-348 寿司VSレミリア・スカーレット 动作 ぱらどっと 蕾米主角接物品（吃的）的小游戏 ex-349 東方輝羅星 动作 the MDY 常见的横版过关类型游戏，类似魂斗罗 ex-350 Yuyuko of the Netherworld 动作 Evil_Nazgul0616 仿卡比初代的游戏 ex-351 ゆっくりスイーパー 解谜 東京組体操組 多层扫雷游戏，但是每层都比较简单 ex-352 宵闇大戦 ミリオンルーミア 策略、角色扮演 川獺アルカディア 全是露米娅的战棋游戏 ex-353 妖精大星航 解谜 ぱんついーと 通过各种道具到达终点房间的策略游戏，但是房间之间能不能走，房间四周有没有房间都会随着使用道具变化 ex-354 TouhouMino 解谜 Québec Games 俄罗斯方块 ex-355 すごろくフェアリーズ 策略 ルート 简单的多人策略图版游戏（就是马里奥聚会那种） ex-356 幻想郷史紀 策略 闇討ちProject 三国志（策略游戏那种）+战棋 ex-357 ぐるぐるすいか 策略 ですのや☆ 给简单指令来控制萃香前进的游戏，策略式动作游戏 ex-358 ムラサのブロックパズル 解谜 DDBY 村纱主角推箱子 ex-359 東方地雷原 解谜 ろくしー（LOX++） 扫雷 ex-360 不夜麻雀 -The Eternally Scarlet Young Moon- 策略 しょうが焼定食、いろは 超能力日麻 ex-361 すわとく！ 解谜 ゆず菌繁殖 一滑到底的平面解谜 ex-362 セイブ・ザ・フォックス 策略 シカクゲームズ 卡牌对战，简单数值比大小的类型，就是比完了有擦弹或者放符卡这样的其他系统 ex-363 東方果物録～とうほうふるーつろっく～ 解谜 ほわいとふれあ（46flare） 三消 ex-364 Grimoir of Alice 解谜 CopperChihuahua 游戏与附带pdf（魔法书）交互解谜的游戏，形式比较新颖但是没那么好玩 ex-365 とある天女の螺旋穿孔 解谜 Black Rock ONE 往下钻地，同颜色砖块可一块钻破的那种游戏 ex-366 IZAYOI RAILWAYS 十六夜電気鉄道 策略 @N-Factory 大富翁，但是每局有目标终点，地图也是不规则的 ex-367 UFO! 嫁と! 结婚させてくれ! 解谜 月面玩具箱 表面打冰壶，实际要“冰壶”里文字凑成句子打对方伤害 ex-368 東方プロジェクトVSネコバズーカ 策略 礼門屋 有点简陋的战棋 ex-369 言霊遊戯 椛筆譚（ことだまゆうぎ もみぴったん） 解谜 角煮餅 纵横字谜形式，不过这边给的空更多而且给的条件更宽泛，但是条件大多有个数要求 ex-370 東方ちぇむぶれむ 策略、角色扮演 智遊堂（ちゆうどう） 比较正宗的战棋游戏 ex-371 東方ディアブロ トレジャーハンターG 动作 紅緑亭 早期3D动作类地牢探索 ex-372 東方戦騎譚 ～ DrunkTankies Battle in the Eastern 动作、弹幕射击 Chronicle Station、D.N.A.Softwares 带点策略的动作弹幕射击闯关 ex-373 幻想の狼 动作 Under the Gun 东方版战场之狼 ex-374 ⑨快跑 ~ BakaRun 动作 八霧游戏制作组 有点类似地铁跑酷，目标只是到达终点 ex-375 ぞろぞろぞふぃ 动作 オートリ電子/特殊装甲隊 也是一个阿燐召唤幽灵打小怪的游戏 ex-376 てゐの奇天烈な探検、てゐの奇妙な冒険 动作 ルート 稍微有点粗制的普通动作闯关游戏，而且难度比较高 ex-377 剣客綺麗伝 动作 正経同人、漫桜椛ゲーム研究所 你说说你给打斗类动作游戏的攻击还加限制干什么！ ex-378 東方反逆劇 动作 はちみつくまさん、神奈川電子技術研究所 选择不同攻击方式把关卡内小怪全干掉，有些关卡确实爽游，我也做了视频展示玩法 ex-379 Desperation of Alcoholic Dream 动作 Ocean Dreams 萃香主角动作游戏，但是判定恶心 ex-380 That's How Sumireko's Roach Stomping Mafia Works! 动作 ChairGTables 平台跳跃类动作游戏，有点蔚蓝感觉 ex-381 東方宝嬌旅 动作 悠遊亭 略简陋的动作游戏，存档点还不回复血量 ex-382 Touhou Madness Wrath 动作 Prolophis 街机三国志类型格斗 ex-383 東方爛漫華 动作 白玉しょこらいふ uuz主角平台跳跃 ex-384 東方偽異伝 动作 - 红魔乡流程的灵异传 ex-385 I wanna make it breaking out 动作 水鳥＆carua boss带些东方元素的iw ex-386 東方迷怪洞 紅 动作 MOON GODDESS 动作闯关，操作难受，画风很有该社团特点 ex-387 お面紛失！？ こころの幻想郷旅 动作 シグナスA-1 秦心主角仿Rabi-Ribi动作游戏 ex-388 爱丽丝的冒险 动作 酒之雀 爱丽丝主角动作小游戏，轻微解谜 ex-389 東方エクスプローラー 动作、角色扮演 にじいろひつじ 地牢打怪类型act，不过判定很严 ex-390 東方天爛舞 动作 頂点α 3D地面的格斗游戏，画风比较华丽但是不算好玩 ex-391 東方猫場撃 飞行射击 礼門屋 动作游戏引擎做的stg，判定很大，手感偏怪 ex-392 Reimu Learns Time Travel 飞行射击 SongSing B不是消弹而是时光回溯的小品stg ex-393 Touhou 4: Lotus Land Story NES Demake 飞行射击 Drillimation Systems fc风格复刻旧作幻想乡 ex-394 東方魔出現 〜 Devil's Emergence 飞行射击 PatchMixolydic 仿旧作风，接近现在的手感，但是只有一关就鸽了 ex-395 矢田寺成美弾幕連 飞行射击 夢幻泡影リョウショウカカン 单boss的bossrush ex-396 东方拉比岛 飞行射击 MUA魔改组 辉针城换了rabiribi的一些角色魔改来的stg ex-397 白色景楽園 飞行射击 星空茶屋（RATTA 3/きみどり。） 约等于妖妖梦路线的横版stg，难度略高，但资源挺多 ex-398 Touhou 5: Mystic Square NES Demake 飞行射击 Drillimation Systems fc风格复刻旧作怪绮谈 ex-399 Touhou Scarlet Labyrinth 飞行射击 buskerdog 有点像动作闯关，但是路上是stg，不算好玩 ex-400 あおぞらのチルノちゃん 飞行射击 星空茶屋（RATTA 3/きみどり。） 鼠标控制的stg，但是鼠标过于灵敏 ex-401 东方花蝴蝶 飞行射击 生还绮想曲 上古老梗 ex-402 泰西Project 飞行射击 Akari、Laochailan、mia等 欧美自制引擎的stg，很像原作，但是要难点 ex-403 東方陰陽葬～Spirits in Memetic Paradise 飞行射击 3Hu Waiting Room danmoko引擎的stg，没什么突出特点 ex-404 東方氷佺暴 ~ Rampage of the Strongest! 飞行射击 Kevin Mink (Kevinmonitor) 街机风单关，计时比谁分高 ex-405 半魂武芸帖 飞行射击 Y-Cubed 妖梦和半灵灵魂互换，半灵学着控制本体射击、打斗，偏act ex-406 Little Heroine Playset 飞行射击 Team Shanghai Hourai 上海蓬莱主角stg，弹幕比较单调，流程也短 ex-407 동방화귀전（東方火鬼傳） 飞行射击 TEAM DEER FARM 横竖卷轴同时存在的stg，和之前外妖傳基本一样 ex-408 東方風魔録～ The Story of Eastern Wind 飞行射击 Helios Create 封魔录的新作风重置版，略难 ex-409 東方撃煉記 飞行射击 MOON GODDESS 通过打怪掉的道具改变射击形式的stg，只要miss就会回到初始弹幕，用初始弹幕很难打 ex-410 東方妖精郷～Trifling Fairy Wars～ 飞行射击 香坂全 自机敌人都是妖精的stg，偏难 ex-411 Sentimental Gensoukyou（センチメンタル幻想郷） 视觉小说 セブンスヘブンMAXION 霖之助由一个小纸条逛遍幻想乡的视觉小说 ex-412 東方チルノ戦車 射击 ウォルター連合 横版卷轴但是只能在地面上射击的小游戏 ex-413 紅魔館へようこそ 视觉小说 のるん♪ 关于红魔馆的各种短篇小说集 ex-414 誰彼ダイアログ 视觉小说、解谜 シカクゲームズ 根据一组给出的词反推要选中的关键词的文字解谜 ex-415 Touhou Mecha: Hell's Rising 视觉小说 Dai-Sukima Dan 欧美的地灵殿主题视觉小说 ex-416 東方遊々蒐III 动作 猫扇風機 小游戏合集 ex-417 紅魔館の危機 视觉小说 うわのそら 红魔馆众人在内忧外患情况下自救的视觉小说 ex-418 東方まみぞう 10ヘンゲームス 动作、解谜、策略 cvELD 猯藏主题的小游戏合集 ex-419 Typing Of Kyouko 教育 Icoreate 东方要素的打字游戏 ex-420 ビギナー闘牌伝説コガサ 视觉小说、策略 M.A.L. 视觉小说方式教人打日麻的游戏 ex-421 东方幽幻簿~Memories of the Flower. 视觉小说 东方幽幻簿制作委员会 小说的游戏改，但是只改了一章 ex-422 ミスチーズ！ ～ナズと愉快な仲間たち～ 文字冒险 Icoreate 纳兹琳调查异变开始的小故事 ex-423 蓮子は可愛そうな夢見るマエリベリーの顔に落書きするのが楽しすぎる 动作 Slowbroski22, Ferdy's Lab, Sorasu (Slascoplerd), HakanaiBlue 莲子在熟睡梅莉脸上画画恶搞的小游戏 ex-424 东方万事屋 文字冒险、动作 崩坏一番工作室 外界人误入幻想乡，在霖之助帮助下开店接委托的小游戏集 ex-425 東方紅恋菓 文字冒险、动作、解谜 かもぷろげくと 美咲cp美铃主角的文字冒险，加上一些小游戏 ex-426 真説・月天永夜録 视觉小说 融解エメノイル 咲夜与永琳之间的故事，对零设写小说的感觉 ex-427 幻想ガーデン物語 模拟经营 智遊堂（ちゆうどう） 东方版星露谷，但是简略 ex-428 Conveyance of Connection: Gensokyo Space Agency 模拟经营 MagpieTeahouse 借用红魔馆造火箭的设定，但是游戏极度精简 ex-429 妖精生活録 视觉小说 氷結寝具 养妖精的视觉小说，像桌面宠物 ex-430 魔法少女ミラクル☆こちや / 魔法少女ミラクル☆こちや ~ Arcadia ~ 文字冒险 月光プロダクツ 早苗进入幻想乡之前的故事，多人物线 ex-431 WriggleSpell 动作 GlowGloat 莉格露主角动作游戏，横版清关收集类，攻击手段比较少 ex-432 Yosei Survivors 动作 dBu music 吸血鬼幸存者类型 ex-433 今の見たのか！？リグル・ナイトバグ 动作 Slowbroski22, Ferdy's Lab, Sorasu (Slascoplerd), HakanaiBlue 莉格露主角类型跑酷，玩起来很舒服 ex-434 霊夢のハチャメチャ大捜索 动作 悠遊亭 中规中矩类洛克人动作游戏 ex-435 リリーブラックと黒人形 动作 ほわいとふれあ（46flare） 类似马里奥，需要通过换人系统（莉莉黑白切换）解决道中 ex-436 東風谷早苗の神風とともに 动作 反歩堂 仿星之卡比，比较短，能力也少 ex-437 幻想郷プロレス～マッスルタッグマッチ～ 动作 しまねこ工房 fc筋肉人翻版 ex-438 SMASH T.H. 动作、射击 もりそば置き場 正邪主角平面动作射击，就是四面八方堆怪朝你冲过来你一边躲一边打 ex-439 幻想郷防衛軍 动作 11th November 不知道防卫什么的3D动作游戏，建模比较难绷 ex-440 文ちゃんDASH 动作 苺兄貴 强制滚动卷轴型平台跳跃跑酷 ex-441 幻想のハルトマン 动作、射击 Magic Arcade 仿洛克人exe的，上steam但被律师函干下去挺出名的 ex-442 おっくまん 动作 ビット 阿空主角洛克人 ex-443 東方文殿生存 Touhou Library Survivors 动作、射击 Alexander Taylor 吸血鬼幸存者，但是比本文前面那个（ex-432）在系统设计上要好点， ex-444 東方平文録 动作 悠遊亭 啥系统也没有的普通横版清关动作，手感很差 ex-445 Yuuto Ichika's One Time Wonder 动作 ChairGTables 原创主角在幻想乡找人打架的游戏，这个魔法系统稍微有点意思 ex-446 シャンハイと謎の魔導書 动作 闇討ちProject 小爱放一群人偶去打怪的3D动作游戏，有点群殴的样子但不够壮观 ex-447 東方変菓伝 ~ Highly Responsive to Pancakes 动作 Python 仿灵异传系统的动作游戏，角色都换成了新作 ex-448 RAIN Project - a touhou fangame 动作 Kirisame Jump 早期steam东方同人之一，横版动作，按键比较难受 ex-449 東方皇桜記 动作 MOON GODDESS 只有比较短攻击范围的射击为攻击方式，面对敌人打过来的远程弹幕比较难躲 ex-450 東方無明剣 -Unorganized Heroes- 动作 INSIDE SYSTEM 通过换宝石的一个系统打怪提升宝石经验来提升能力，系统比较新颖但是打起来很憋屈，大多数时候还是躲着怪跑 $(function(){$(\"#gameListTable\").tablesorter({sortReset:true,sortRestart:true,headers:{0:{sorter:\"text\"},4:{sorter:false}}});});"}],"posts":[{"title":"正则表达式","slug":"正则表达式","date":"2023-08-16T16:25:40.000Z","updated":"2024-10-21T16:28:22.126Z","comments":true,"path":"2023/08/17/正则表达式/","link":"","permalink":"https://neko-horikawaraiko.github.io/2023/08/17/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"推荐一个正则表达式测试网站（也可以学习，但是主要是对写的正则做解释的功能很舒服）：https://regexr-cn.com/ 其他语言中，\\与后面的字符合起来就表示转义或者插入特殊字符 Java中，\\表示在正则表达式中插入特殊字符，所以需要转义时需要写\\\\，所以要匹配换行符需要使用\\\\n，插入一个反斜杠要使用\\\\ 下表中反斜杠含义以通用为准（非Java），斜体字表示某个特殊模式，而不是该字符串本身 模式 含义 备注 \\ 将下一字符标记为特殊字符、文本、反向引用或八进制转义符 \\n匹配换行符，\\\\匹配反斜杠，\\.匹配点，\\(匹配括号 ^ 匹配字符串开始位置 如果设置了RegExp对象Multiline属性，^还会与\\n或\\r之后的位置匹配 $ 匹配字符串结束位置 如果设置了RegExp对象Multiline属性，$还会与\\n或\\r之前的位置匹配 * 零次或多次匹配前面的字符或子表达式 * 等效于 &#123;0,&#125; + 一次或多次匹配前面的字符或子表达式 + 等效于 &#123;1,&#125; ? 零次或一次匹配前面的字符或子表达式 ? 等效于 &#123;0,1&#125; {n} n 是非负整数。正好匹配 n 次 {n,} n 是非负整数。至少匹配 n 次 {n,m} m 和 n 是非负整数，其中 n &lt;= m。匹配至少 n 次，至多 m 次 m 和 n 之间的逗号两侧不能插入空格 ? 在任何其他限定符（*、+、?、{n}、{n,}、{n,m}）之后时，匹配模式是”非贪心的” “非贪心的”模式匹配搜索到的、尽可能短的字符串，而默认的“贪心的”模式匹配搜索到的、尽可能长的字符串。例如，在字符串&quot;oooo&quot;中，&quot;o+?&quot;只匹配单个”o”，而&quot;o+&quot;匹配所有”o”。 . 匹配除\\r、\\n之外的任何单个字符 若要匹配包括”\\r\\n”在内的任意字符，请使用诸如”[\\s\\S]”之类的模式 (pattern) 成组匹配 pattern 并捕获该匹配的子表达式 创建子表达式或者一个引用，引用供下面所说 \\n 模式来引用 (?:pattern) 成组匹配 pattern，但不捕获该匹配的子表达式 (?=pattern) 成组先行搜索匹配 pattern ，但不捕获该匹配 先行搜索会匹配 pattern，但是不消耗该 pattern 作为匹配到的表达式。“消耗”指匹配到对应模式的字符串后，下次搜索匹配就从该字符串之后开始。这里不消耗就是下次搜索匹配从 pattern 内开始 (?!pattern) 成组先行搜索不匹配 pattern ，但不捕获该匹配 x|y 匹配 x 或 y 例如，`”z [xyz] 字符集。匹配包含的任一字符 例如，&quot;[abc]&quot;匹配&quot;plain&quot;中的&quot;a&quot; [^xyz] 反向字符集。匹配未包含的任何字符 例如，&quot;[^abc]&quot;匹配&quot;plain&quot;中&quot;p&quot;，&quot;l&quot;，&quot;i&quot;，&quot;n&quot; [a-z] 字符范围。匹配指定范围内的任何字符 [^a-z] 反向范围字符。匹配不在指定的范围内的任何字符 \\b 匹配一个字边界，即字与空格间的位置 例如，&quot;er\\b&quot;匹配&quot;never&quot;中的&quot;er&quot;，但不匹配&quot;verb&quot;中的&quot;er&quot; \\B 非字边界匹配 例如，&quot;er\\b&quot;匹配&quot;verb&quot;中的&quot;er&quot;，但不匹配&quot;never&quot;中的&quot;er&quot; \\cx 匹配 x 指示的控制字符 例如，\\cM 匹配 Control-M 或回车符。x 的值必须在 A-Z 之间。如果不是这样，则假定 c 就是”c”字符本身。 \\d 数字字符匹配 \\d等效于 [0-9] \\D 非数字字符匹配 \\D等效于 [^0-9] \\f 换页符匹配 \\f等效于 \\x0c 和 \\cL \\n 换行符匹配 \\n等效于 \\x0a 和 \\cJ \\r 匹配一个回车符 \\r等效于 \\x0d 和 \\cM \\s 匹配任何空白字符 空白字符，包括空格、制表符、换页符等。\\s等效于[ \\f\\n\\r\\t\\v] \\S 匹配任何非空白字符 \\S等效于[^ \\f\\n\\r\\t\\v] \\t 制表符匹配 \\t等效于 \\x09 和 \\cL \\v 垂直制表符匹配 \\v等效于 \\x0b 和 \\cK \\w 匹配任何字类字符，包括下划线 \\w等效于[A-Za-z0-9_] \\W 与任何非单词字符匹配 \\W等效于[^A-Za-z0-9_] \\xn 匹配 n，此处的 n 是一个十六进制转义码 十六进制转义码必须正好是两位数长。例如，&quot;\\x41&quot;匹配&quot;A&quot;。&quot;\\x041&quot;与&quot;\\x04&quot;&amp;&quot;1&quot;等效 \\num 匹配 num，此处的 num 是一个正整数。到捕获匹配的反向引用 例如，(.)\\1匹配两个连续的相同字符，其中(.)表示换行外任意一个字符，\\1表示对第1个分组(.)匹配到的字符再引用一次，可以匹配到&quot;daazzz&quot;中的&quot;aa&quot;和3-4位置的&quot;zz&quot;。(\\w)(.)a\\2匹配到&quot; dads hgagx&quot;中的&quot;hgag&quot;而匹配不到&quot; dad&quot; \\n 标识一个八进制转义码或反向引用 如果 \\n 前面至少有 n 个捕获子表达式，那么 n 是上述的反向引用。否则，如果 n 是八进制数 (0-7)，那么 n 是八进制转义码 \\nm 标识一个八进制转义码或反向引用 如果 \\nm 前面至少有 nm 个捕获子表达式，那么 nm 是上述的反向引用。如果 \\nm 前面至少有 n 个捕获，则 n 是上述的反向引用，后面跟有字符 m。如果两种前面的情况都不存在，则 \\nm 匹配八进制值 nm，其中 n 和 m 是八进制数字 (0-7) \\nml 标识一个八进制转义码 只有当 n 是八进制数 (0-3)，m 和 l 是八进制数 (0-7) 时，匹配八进制转义码 nml，其余与上述分析相同 \\un 匹配 n，其中 n 是以四位十六进制数表示的 Unicode 字符 例如，\\u00A9 匹配版权符号 (©)","categories":[{"name":"学习","slug":"学习","permalink":"https://neko-horikawaraiko.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"《Java语言程序设计 基础篇 原书第10版》学习笔记","slug":"《Java语言程序设计 基础篇 原书第10版》学习笔记","date":"2023-08-16T16:17:40.000Z","updated":"2024-10-21T16:28:22.121Z","comments":true,"path":"2023/08/17/《Java语言程序设计 基础篇 原书第10版》学习笔记/","link":"","permalink":"https://neko-horikawaraiko.github.io/2023/08/17/%E3%80%8AJava%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%20%E5%9F%BA%E7%A1%80%E7%AF%87%20%E5%8E%9F%E4%B9%A6%E7%AC%AC10%E7%89%88%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"本文称为笔记，但是基本上是直接在代码中标注各种用法与注意事项。 一、基础部分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985986987988989990991// package IntroductionToJava; // 声明该文件（类）放在哪个包中，不写则放在默认包。声明时这一句前面不能有注释也不能有空白//import java.util.*; // 导入包中的所有类import java.io.BufferedInputStream;import java.io.BufferedOutputStream;import java.io.DataInputStream;import java.io.DataOutputStream;import java.io.EOFException;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.PrintWriter;import java.io.RandomAccessFile;import java.math.BigDecimal;import java.math.BigInteger;import java.math.RoundingMode;import java.util.ArrayList;import java.util.Arrays; // 仅导入一个类import java.util.HashMap;import java.util.Locale;import java.util.Random;import java.util.Scanner;// Java是大小写敏感语言，大小写不同表示不同的标识符// 命名规范：类名每个单词首字母大写（帕斯卡命名法），变量名方法名第一个单词首字母小写，其余首字母大写（(小)驼峰命名法），// 常量名所有字母大写，单词间下划线连接// 编译器将.java文件（源代码）中所有类分别编译成.class文件（字节码），Java虚拟机（JVM）解释执行字节码，每次只解释并执行一步字节码// Java文件名必须与文件里的唯一public类名相同public class IntroductionToJavaBasic &#123; // main函数为程序入口，方法头永远都这样写，必须public static void main，形参String[] public static void main(String []args) &#123; &#125; // 类内数据、方法的可见性修饰符（注意protected，在包内，不是子类也可见） // | 类内可见 | 包内可见 | 子类可见 | 包外可见 // public | √ | √ | √ | √ // protected | √ | √ | √ | // (空) | √ | √ | | // private | √ | | | public void fun1() &#123; // 杂项小点 // 由于浮点数精确度问题，比如100000000.0+0.000000001=100000000.0，相加的时候最好从小数加到大数 int intNum; // 不初始化时无默认值，如果使用则编译报错 final double PI = 3.1415926; // final声明常量 Scanner input = new Scanner(System.in); // System.in标准输入设备，默认键盘。Scanner可以从控制台或者文件读取数据 System.out.print(&quot;Enter a number for radius: &quot;); // System.out标准输出设备，默认显示器 double radius = input.nextDouble(); double area = Math.pow(radius, 2) * PI; // java也定义了常量Math.PI // println()输出函数，字符串连接可以直接用+，一对引号里的字符串常量不能跨行，要显示跨行需要\\n System.out.println(&quot;The radius: &quot; + radius + &quot;,\\nthe area of circle: &quot; + area); // 格式化输出，输出后不换行。常用格式标识符：%b布尔，%c字符，%d整数，%f浮点，%e科学计数法，%s字符串，%%百分号 // 格式中整数表示至少显示多长（空格+内容，对于数字含小数点与小数部分），小数表示小数点后一定保留多少位，负号表示左对齐 System.out.printf(&quot;The radius: %f,\\nthe area of circle: %.2f\\n&quot;, radius, area); input.close(); int i = 1; int j = 2; System.out.println(&quot;i + j is &quot; + i + j); // i + j is 12 (+号左结合，按字符串拼) System.out.println(&quot;i + j is &quot; + (i + j)); // i + j is 3 &#125; private void fun2() &#123; // 基本数据类型8种 // 数字字面量数字之间可以加下划线连接 byte byteNum = 0; //8位带符号整数 short shortNum = 0; //16位带符号整数 int intNum = 789_78; //32位带符号整数，78978 long longNum = 0; //64位带符号整数 float floatNum = 0.0f; //32位浮点数 double doubleNum = 0.0; //64位浮点数 boolean b = true; char c = &#x27;A&#x27;; // 2字节（16位）长度 &#125; protected void fun3() &#123; // 从标准输入设备读取输入，读取到不正确范围或者类型的值会出现运行时错误 Scanner input = new Scanner(System.in); byte byteValue = input.nextByte(); short shortValue = input.nextShort(); int intValue = input.nextInt(); long longValue = input.nextLong(); float floatValue = input.nextFloat(); double doubleValue = input.nextDouble(); String s1 = input.next(); // 读以空白字符结束的字符串（&#x27; &#x27;空格、&#x27;\\t&#x27;制表、&#x27;\\f&#x27;换页、&#x27;\\r&#x27;回车、&#x27;\\n&#x27;换行) String s2 = input.nextLine(); // 读一整行文本，以按下回车键为结束标志 // 注意不要在上述nextByte()等数字输入、next()这些方法之后用nextLine() input.close(); &#125; // 数组在java中是对象 void fun4() &#123; // 一维数组 int[] intArray1; // 声明方式1，建议使用 int intArray2[]; // 声明方式2，适用于C/C++程序员习惯 // 仅这样声明时只是创建了一个可以去引用一个数组的“引用变量”，此时值为null，但是编译器可能会直接不给通过 // 此时也不能给数组内元素赋值，因为并没有引用一个真正的数组 // 创建一个数组，赋值给变量，数组必须指定大小（可以是变量），且创建后无法更改大小 // 不给数组内元素赋值时，各元素数值型默认值为0，char型默认值为&#x27;\\u0000&#x27;(\\\\u表示unicode，后跟4位16进制数)，boolean型默认值为false，引用型默认null double[] doubleArray1 = new double[10]; doubleArray1[0] = 10; double[] doubleArray2 = &#123;4.3, 5.5&#125;; // 用数组初始化语法声明、创建、初始化数组，数组大小等于括号内元素个数 // double[] doubleArray3; // ×，数组初始化语法不能写成分开形式 // doubleArray3 = &#123;4.3, 5.5&#125;; // ×，数组初始化语法不能写成分开形式 // double[] doubleArray2 = new double[]&#123;4.3, 5.5&#125;; // ×，数组初始化语法不能使用指定维度方式 System.out.print(new double[]&#123;6, 7.7&#125;); // 匿名数组，但是此时[]内不能填大小 char[] city = &#123;&#x27;D&#x27;, &#x27;a&#x27;, &#x27;l&#x27;, &#x27;l&#x27;&#125;; System.out.println(city); // char[]可以直接 单独 打印出来成一个字符串，不用循环， // 但是如果用+连接其他东西打印出来就不是字符串了 String[] stringArray = &#123;&quot;df&quot;&#125;; System.out.println(stringArray); // 默认调用了String[]的toString()实例方法 // 比如上述打印出来[Ljava.lang.String;@7344699f，[（一个左方括号）表示一维数组， // L和后面的;表示数组内含有类或者接口（不含时没有L），后面是类型名，一个@字符，最后是该数组的哈希码 // 数组复制 int[] intArray3 = &#123;7, 2, 3, 5, 9&#125;; int[] intArray4 = new int[6]; // 目标数组大小不小于源数组(对于方法①②) // intArray4 = intArray3; // 仅复制了引用，即intArray3和intArray4都指向intArray3指的数组， // 此时intArray4原来指向的数组没有被引用，会被垃圾回收 // 数组内容复制正确方法①：使用循环挨个元素复制（略） // 方法②：arraycopy方法，从源数组某位置拷贝到目标数组某位置，拷贝多长 System.arraycopy(intArray3, 0, intArray4, 0, intArray3.length); // 方法③：clone方法 intArray4 = intArray3.clone(); // 数组方法 Arrays.sort(doubleArray2); // 排序 Arrays.parallelSort(doubleArray2); // 多线程排序 Arrays.sort(intArray3, 0, 3); // 局部排序 Arrays.parallelSort(intArray3, 0, 3); // 多线程局部排序 Arrays.binarySearch(doubleArray2, 3); // 在按升序排好的数组中二分查找，找不到会插入并返回带符号的+1下标，即-(插入下标+1) Arrays.equals(doubleArray1, doubleArray2); // 数组是否相同，需要内容、顺序都相同，而类型不同数组无法调用equals方法 Arrays.fill(doubleArray1, 5); // 全部填入5 Arrays.fill(doubleArray2, 1, 3, 5); // 1-3位置填入5 Arrays.toString(intArray3); // 数组转字符串，带有默认格式 // 数组foreach循环见fun7 &#125; void fun5() &#123; // 多维数组 int[][] intMatrix1; // 声明方式1，建议使用 int intMatrix2[][]; // 声明方式2，适用于C/C++程序员习惯 int[][] intMatrix3 = new int[5][5]; int[][] intMatrix4 = &#123; &#123;1, 2, 3&#125;, &#123;4, 5, 6&#125;, &#123;7, 8, 9&#125; &#125;; int[][] intMatrix6 = &#123; // 锯齿数组 &#123;1, 2, 3&#125;, &#123;2, 3&#125; &#125;; int[][] intMatrix7 = new int[4][]; // 后面几维长度可以省略，但第一维的长度必须指定，虽然指定了但是里面没有实际的数组，取值会报错 &#125; void fun6() &#123; // 选择结构 boolean b = true; boolean b2 = false; if (b) &#123; //... &#125; else if (b2) &#123; //... &#125; int someInt = 1; switch (someInt) &#123; case 0:break; case 1: //存在没有break的case最好注释一下 case 2:break; default: &#125; &#125; void fun7() &#123; // 循环结构 int count = 0; while (count &lt; 100) &#123; // ... &#125; do &#123; // ... &#125; while (count &lt; 100); for (int i = 0; i &lt; 100; i++) &#123; // ... &#125; // 使用break;跳过整个循环过程 // 使用continue;跳过本次循环直接进入下一次循环（与判断） // 数组专属循环：foreach循环 double[] doubleArray = &#123;3.3, 4.4, 5&#125;; for (double e : doubleArray) &#123; System.out.println(e); &#125; &#125; // 基本数据类型参数为值传递，对象类型参数为引用传递（实际上为传引用变量值的值传递，但由于是引用变量，所以可以修改变量所指对象的内容） void fun8(int i, int[] j) &#123; // ... &#125; // 方法重载，同方法名不同形参列表（形参类型或者个数不同） // 只是形参名/修饰符/返回值类型不同的话还是和被重载的是同一个方法，报重定义错 // 注意歧义错误，指调用一个方法时，可以匹配上重载的多个方法，这几个匹配同样精确，会编译报错，要修改调用的实参或者修改方法形参 void fun8(int i, int j) &#123; // ... &#125; // 可变长参数列表，被当做数组对待，必须声明在形参列表最后一个的位置，且最多只能有一个可变长参数 void fun9(double... numbers) &#123; // ... &#125; // 形参返回值都可以是二维数组，数组传给形参仍然是传引用 int[][] fun10(int[][] numbers) &#123; return numbers; &#125; void fun11() &#123; // 数学函数 Math.sin(Math.PI); Math.cos(0); Math.tan(0); Math.asin(0); Math.acos(0); Math.atan(0); Math.toDegrees(Math.PI / 2); Math.toRadians(30); Math.exp(1); Math.log(Math.E); Math.log10(10); Math.pow(2, 3); Math.sqrt(4); Math.ceil(4.5); // 向上取整，返回双精度的整数 Math.floor(4.5); // 向下取整，返回双精度的整数 Math.rint(4.5); // 向最近整数取整，如果小数是0.5这种的向最近偶数取整，返回双精度的整数 Math.round(4.5); // 向最近整数取整，如果小数是0.5这种的不管正负，向+0.5的整数取整，单精度/双精度小数返回int/long整数 Math.max(2, 3); Math.min(2, 3); Math.abs(-3.4); Math.random(); // 0.0 &lt;= Math.random() &lt; 1.0 &#125; void fun12() &#123; // 字符方法 Character.isDigit(&#x27;0&#x27;); // 是否数字 Character.isLetter(&#x27;A&#x27;); // 是否字母 Character.isLetterOrDigit(&#x27;9&#x27;); // 是否字母或数字 Character.isLowerCase(&#x27;d&#x27;); // 是否小写 Character.isUpperCase(&#x27;A&#x27;); // 是否大写 Character.toLowerCase(&#x27;A&#x27;); // 转小写 Character.toUpperCase(&#x27;a&#x27;); // 转大写 Character.valueOf(&#x27;c&#x27;); // 转为Character Character.toString(&#x27;c&#x27;); // 转字符串 Character.compare(&#x27;c&#x27;, &#x27;d&#x27;); // 比较 Character.digit(&#x27;c&#x27;, 16); // 字符（的unicode码）用某进制表示下的数值 Character.isWhitespace(0); // 是否是Java定义的空白符 Character.isSpaceChar(0); // 是否是Unicode定义的空白符 Character ch = &#x27;c&#x27;; ch.charValue(); &#125; void fun13() &#123; // 字符串方法，String类内容不可变 String str = &quot;Welcome to Java&quot;; // 字符串常量创建String String str2 = new String(&quot;Welcome to Java&quot;); // 字符串常量创建String String str3 = new String(new char[]&#123;&#x27;W&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;&#125;); // 字符数组创建String char[] chars = &quot;Java&quot;.toCharArray(); // String创建字符数组 String str4 = &quot;Welcome to Java&quot;; boolean b1 = str == str2; // false，字符串使用new创建String时，不会往常量池内存入该字符串，变量引用堆上常量池外一个普通的字符串对象 boolean b2 = str == str4; // true，字符串直接量创建String时，直接往常量池内存入该字符串，称为“限定字符串”对象，变量引用常量池内的这个字符串对象 str2 = str2.intern(); // 常量池内没有该字符串时先复制一份进去（有就不起作用），然后返回常量池内对象的引用 boolean b3 = str == str2; // true str.length(); &quot;Welcome&quot;.length(); // 长度为7 &quot;&quot;.length(); // 长度为0 str.charAt(0); str.substring(3); // 从3开始到末尾的子字符串 str.substring(0, 6); // 0 &lt;= substring &lt; 6的子字符串（参数是开始结束的index，不是开始index和长度） str.concat(&quot; hahaha&quot;); // 实参字符串连接到str字符串后面，等于 str + &quot; hahaha&quot; str.toUpperCase(); // 全转大写 str.toLowerCase(); // 全转小写 str.trim(); // 去掉两侧空白字符，如空格、\\t等 str.equals(&quot;Welcome&quot;); // 是否相等 // str == &quot;Welcome&quot; // == 比较的是是否相同对象 str.equalsIgnoreCase(&quot;Welcome&quot;); // 是否相等，忽略大小写 str.compareTo(&quot;Welcome&quot;); // 比较大小，按字典序，str小于&quot;Welcome&quot;则返回小于0，等于则返回0，大于则返回大于0 str.compareToIgnoreCase(&quot;Welcome&quot;); // 比较大小，忽略大小写 str.startsWith(&quot;Welcome&quot;); // 是否开头 str.endsWith(&quot;Welcome&quot;); // 是否结尾 str.contains(&quot;Welcome&quot;); // 是否包含 str.indexOf(&#x27;e&#x27;); // 字符出现的第一个位置 str.indexOf(&#x27;e&#x27;, 3); // 从某位置开始，字符出现的第一个位置 str.indexOf(&quot;come&quot;); // 字符串出现的第一个位置 str.indexOf(&quot;come&quot;, 3); // 从某位置开始，字符串出现的第一个位置 str.lastIndexOf(&#x27;e&#x27;); // 字符出现的最后一个位置 str.lastIndexOf(&#x27;e&#x27;, 3); // 从某位置开始，字符出现的最后一个位置 str.lastIndexOf(&quot;come&quot;); // 字符串出现的最后一个位置 str.lastIndexOf(&quot;come&quot;, 3); // 从某位置开始，字符串出现的最后一个位置 // 正则说明见正则markdown文件 str.replace(&quot;el&quot;, &quot;df&quot;); // 所有匹配的地方替换 str.replace(&#x27;e&#x27;, &#x27;s&#x27;); // 所有匹配的地方替换 str.replaceFirst(&quot;ed&quot;, &quot;df&quot;); // 第一个匹配（正则）的地方替换 str.replaceAll(&quot;ed&quot;, &quot;df&quot;); // 所有匹配（正则）的地方替换 str.split(&quot;e&quot;); // 按某正则标识分割字符串，该正则标识不会出现在分割产生的数组中 str.matches(&quot;Welcome.*&quot;); // 符合某正则 str.getChars(2, 4, chars, 1); // 从str取下标[2,4)的字符替换chars字符数组从1开始的位置，注意字符替换到的位置不能超过chars的最大下标 String.format(&quot;%7.2f&quot;, 45.556); // 返回一个格式化字符串 // 字符串转数字 Integer.parseInt(&quot;3&quot;); Double.parseDouble(&quot;3.5&quot;); // 数字转字符串 str = 0 + &quot;&quot;; String.valueOf(0); Integer.toString(0); // 基本类型、字符数组转字符串 String.valueOf(&#x27;c&#x27;); String.valueOf(new char[]&#123;&#x27;W&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;&#125;); String.valueOf(2.44); String.valueOf(true); &#125; void fun14() &#123; // 时间日期 java.util.Date currentDate = new java.util.Date(); // 为当前时间创建一个Date对象 java.util.Date someDate = new java.util.Date(2333); // 创建一个1970.1.1 0点往后指定毫秒数的Date对象 currentDate.getTime(); // 从1970.1.1 0点到currentDate所指时间的毫秒 currentDate.toString(); // 日期时间的字符串表示 someDate.setTime(42); // 设定新时间 &#125; void fun15() &#123; // 随机数，种子相同时生成的随机数列也相同 Random random1 = new Random(); // 当前时间为种子创建一个Random对象 Random random2 = new Random(42); // 特定值为种子创建一个Random对象 random1.nextInt(); // 返回随机int random1.nextInt(4); // 返回 0 &lt;= 随机值 &lt; 4 的随机int random1.nextInt(2, 5); // 返回 2 &lt;= 随机值 &lt; 5 的随机int random1.nextLong(); random1.nextLong(3); random1.nextLong(2, 5); random1.nextDouble(); // 0 &lt;= 随机值 &lt; 1 的随机double random1.nextDouble(4); // 0 &lt;= 随机值 &lt; 4 的随机double random1.nextDouble(2, 5); // 2 &lt;= 随机值 &lt; 5 的随机double random1.nextFloat(); // 0 &lt;= 随机值 &lt; 1 的随机float random1.nextFloat(4); random1.nextDouble(2, 5); &#125; void fun16() &#123; // 基本数据类型的包装类，包装类对象与相应值之间可以自动转换 Integer intNum1 = 5; // 直接赋值 Integer intNum2 = new Integer(5); // new方法（已废弃），改用valueOf() Integer intNum3 = new Integer(&quot;5&quot;); // new方法传入字符串（已废弃），改用valueOf() Integer intNum4 = Integer.MAX_VALUE;// 最大值最小值（Byte/Short/Integer/Long） Double doubleNum = Double.MAX_VALUE;// 最大正值最小正值（Double/Float） Character charValue = &#x27;c&#x27;; Boolean boolValue = false; // 各个数值类型都有的方法 Integer.compare(1, intNum1); // 比较，返回-1,0,1来指示大小 Double.compare(3.3, 0.3); Integer.toString(2); // 转换字符串 Integer.valueOf(&quot;2&quot;); // 转换数值 Integer.valueOf(2); Integer.parseInt(&quot;3&quot;); // 转换数值 Double.parseDouble(&quot;3.3&quot;); intNum1.compareTo(intNum4); // 比较，返回-1,0,1来指示大小 intNum1.byteValue(); // 转换成其他类型数值 intNum3.shortValue(); intNum3.intValue(); intNum4.longValue(); intNum1.doubleValue(); intNum1.floatValue(); // 特有方法 Integer.parseInt(&quot;1A&quot;, 16); // 以某进制转换字符串为数值，字符串表示的数字必须符合该进制的表示法（比如2进制不能出现2之类） String.format(&quot;%x&quot;, 26); // 上述的反向转换 // Boolean型方法 Boolean.parseBoolean(&quot;true&quot;); // 字符串转boolean Boolean.toString(false); // boolean转字符串 Boolean.valueOf(&quot;false&quot;); // 转为Boolean Boolean.valueOf(false); Boolean.compare(false, false); // 比较 Boolean.logicalAnd(false, boolValue); // 逻辑运算 Boolean.logicalOr(false, false); Boolean.logicalXor(false, false); boolValue.booleanValue(); // 取值 boolValue.toString(); // 转字符串 boolValue.compareTo(false); // 比较 // 部分Character型方法见fun9 &#125; void fun17() &#123; // BigInteger、BigDecimal任意大小任意精度的数 BigInteger a = new BigInteger(Long.MAX_VALUE + &quot;&quot;); // 字符串方式初始化 BigInteger b = new BigInteger(&quot;2&quot;); BigInteger c = a.multiply(b); // a*b c = a.add(b); // a+b c = a.subtract(b); // a-b c = a.divide(b); // a/b BigDecimal ad = new BigDecimal(&quot;1.0&quot;); // 字符串方式初始化 BigDecimal bd = new BigDecimal(&quot;3&quot;); BigDecimal cd = ad.multiply(bd); // ad*bd cd = ad.add(bd); // ad+bd cd = ad.subtract(bd); // ad-bd // cd = ad.divide(bd); // ad/bd，计算结果无限小数会抛异常 cd = ad.divide(bd, 20, RoundingMode.UP);// 使用指定小数长度和舍入方式的方法避免上述异常 &#125; void fun18() &#123; // StringBuilder StringBuffer，可更改的String，StringBuffer用于多线程访问，StringBuilder用于单线程访问 StringBuilder builder = new StringBuilder(); // 创建容量16的空StringBuilder builder = new StringBuilder(5); // 创建容量5的空StringBuilder builder = new StringBuilder(&quot;welcome&quot;); // 带初始内容的StringBuilder char[] chars = &#123;&#x27;f&#x27;, &#x27;s&#x27;, &#x27;e&#x27;, &#x27;d&#x27;&#125;; builder.append(chars); // 添加字符数组到后面 builder.append(chars, 2, 3); // 添加字符数组从2及以后的3个字符到后面 builder.append(&quot;fe&quot;); // 添加字符串/String到后面 builder.append(3); // 添加基本类型的值到后面 builder.delete(1, 2); // 删除[1,2)之间的字符 builder.deleteCharAt(3); // 删除位置3的字符 builder.insert(4, chars); // 插入字符数组到指定位置 builder.insert(4, chars, 2, 3); // 插入字符数组从2及以后的3个字符到指定位置 builder.insert(4, &quot;fe&quot;); // 插入字符串/String到指定位置 builder.insert(4, 3); // 插入基本类型的值到指定位置 builder.replace(0, 1, &quot;ddd&quot;); // [0,1)替换为新字符串，长度可不同 builder.reverse(); // 反转字符串 builder.setCharAt(0, &#x27;0&#x27;); // 替换指定位置字符 builder.toString(); // 返回字符串 builder.capacity(); // builder的容量（能存的字符数量，会自动增加不会自动减小，永远不小于length()） builder.length(); // builder中字符串长度（实际存的字符数量） builder.setLength(10); // 设置其中字符串新长度（不改变容量，比原来length大则在字符串后添加空字符&#x27;\\u0000&#x27;补齐，比原来length小则其中字符串截断） builder.charAt(3); // 返回下标位置的字符 builder.substring(3); // 从下标开始到末尾的子字符串 builder.substring(0, 2); // 下标为[0,2)的子字符串 builder.trimToSize(); // 减小容量至字符串长度 &#125; void fun19() &#123; // ArrayList可变长列表（数组） ArrayList&lt;Double&gt; doubleArray = new ArrayList&lt;&gt;(); // 声明、创建列表（列表所存为对象类型，没法存基本类型） ArrayList&lt;Double&gt; doubleArray2 = new ArrayList&lt;Double&gt;(); // 实质同上 Double[] doubles = &#123;3.0, 4.5, 7.2&#125;; doubleArray2 = new ArrayList&lt;&gt;(Arrays.asList(doubles)); // 普通数组转列表 doubles = new Double[doubleArray2.size()]; doubleArray2.toArray(doubles); // 列表转普通数组（doubleArray2直接复制到doubles中） doubleArray.add(3.0); // 添加到末尾 doubleArray.add(1, 4.0); // 添加到下标位置处（下标&lt;=size） doubleArray.contains(2.0); // 是否包含元素 doubleArray.get(1); // 获取下标所指元素 doubleArray.set(1, 5.0); // 设置（更新）下标所指元素（下标&lt;size） doubleArray.indexOf(4.0); // 第一个匹配该元素的下标，没有则返回-1 doubleArray.lastIndexOf(4.0); // 最后一个匹配该元素的下标，没有则返回-1 doubleArray.isEmpty(); // 是否为空 doubleArray.remove(1); // 移除下标所指元素 doubleArray.remove(3.0); // 移除指定元素 doubleArray.size(); // 列表大小 doubleArray.clear(); // 清空列表 doubleArray.toString(); // 返回列表的字符串表示法 java.util.Collections.sort(doubleArray); // 列表的排序方法 // 数组排序方法用java.util.Arrays.sort()，见fun4 java.util.Collections.max(doubleArray); // 最大值 java.util.Collections.min(doubleArray); // 最小值 java.util.Collections.shuffle(doubleArray); // 随机打乱 for (Double d : doubleArray) &#123; // 数组列表循环，与普通数组相同，见fun7 &#125; &#125; void fun20() &#123; // HashMap散列表，无序容器 HashMap&lt;Integer, String&gt; mMap = new HashMap&lt;/*Integer, String*/&gt;(); HashMap&lt;Integer, String&gt; mMap2 = new HashMap&lt;&gt;()&#123;&#125;; mMap.put(1, &quot;null&quot;); // 添加键值对 mMap.put(3, &quot;sojdo&quot;); mMap.putAll(mMap2); // 添加另一个HashMap mMap.putIfAbsent(4, &quot;saaa&quot;); // 如果没有key则添加 mMap.replace(3, &quot;aaa&quot;); // key替换为新value mMap.size(); // 大小 mMap.isEmpty(); // 是否空 mMap.containsKey(1); // 是否含某个key mMap.containsValue(&quot;null&quot;); // 是否含某个value mMap.keySet(); // 所有key mMap.values(); // 所有value mMap.get(1); // 获取key对应的value mMap.remove(3); // 移除某个键值对 mMap.clear(); // 清空HashMap for (Integer i : mMap.keySet()) &#123;&#125; for (String s : mMap.values()) &#123;&#125; &#125; void fun21() &#123; // File文件管理类 File file1 = new File(&quot;pathname&quot;); // 用指定路径名创建File对象，创建目录或文件 file1 = new File(&quot;directory&quot;, &quot;pathname&quot;); // 用指定目录路径+子路径名创建File对象，创建目录或文件 File file2 = new File(file1, &quot;pathname&quot;); // 用目录File对象+子路径名创建File对象，创建目录或文件 file1.exists(); // 对象代表的文件/目录是否存在 file1.canRead(); // 对象代表的文件/目录是否可读 file1.canWrite(); // 对象代表的文件/目录是否可写 file1.isDirectory(); // 对象代表的是否是目录 file1.isFile(); // 对象代表的是否是文件 file1.isAbsolute(); // 对象代表的文件/目录是否是绝对路径创建 file1.isHidden(); // 对象代表的文件/目录是否隐藏 file1.getAbsolutePath(); // 返回对象初始化使用的路径名的绝对路径 try &#123; file1.getCanonicalPath(); // 返回对象代表的文件/目录的规整后绝对路径 &#125; catch (IOException e) &#123;&#125; file1.getName(); // 返回对象初始化使用的路径名的文件名/目录名 file1.getPath(); // 返回对象初始化使用的路径名（约等于getParent() + getName()） file1.getParent(); // 返回对象初始化使用的路径名的父目录 file1.lastModified(); // 返回对象代表的文件/目录的最后修改时间 file1.length(); // 返回对象代表的文件的文件大小，目录则返回0 file1.listFiles(); // 返回对象代表的目录内的文件 file1.delete(); // 删除对象代表的文件/目录 file1.renameTo(file2); // 将对象代表的文件/目录换成指定名字（重命名/移动文件） file1.mkdir(); // 创建对象代表的目录 file1.mkdirs(); // 创建对象代表的目录及其父目录 &#125; void fun22() throws FileNotFoundException&#123; // 文本类文件读写PrintWriter、Scanner，网络文件URL File file1 = new File(&quot;null.txt&quot;); PrintWriter pw1 = new PrintWriter(file1); // 用File对象创建PrintWriter对象 PrintWriter pw2 = new PrintWriter(&quot;filename&quot;);// 用文件名字符串创建PrintWriter对象 Scanner scanner1 = new Scanner(file1); // 用File对象创建Scanner对象。Scanner可以从控制台或者文件读取数据 Scanner scanner2 = new Scanner(&quot;acb&quot;); // 用String对象创建Scanner对象 pw1.print(&quot;dd&quot;); // 写入字符串 pw1.print(&#x27;d&#x27;); // 写入字符 pw1.print(new char[]&#123;&#x27;a&#x27;, &#x27;b&#x27;&#125;); // 写入字符数组 pw1.print(3); // 写入int/long/float/double/boolean pw1.println(&quot;dd&quot;); // 同上，但是多加一个换行 pw1.println(&#x27;d&#x27;); pw1.println(new char[]&#123;&#x27;a&#x27;, &#x27;b&#x27;&#125;); pw1.println(3); pw1.printf(&quot;dd%d&quot;, 3); // 格式化输出 pw1.close(); pw2.close(); // next()、nextByte()...为“标记读取方法”，先删分隔符，从第一个非分隔符开始读取一段数据，直到分隔符为止，且将分隔符留下 // nextLine()读取一行，从当前位置开始直到行分隔符为止，所以使用控制台读取数字时，若连续使用nextInt()、nextLine()，而用户使用回车作为输入结束，则nextLine()读取出空值 // 因为nextInt()读取了数字到行分隔符截止，并留下了分隔符，nextLine()读取剩下的（什么都没有）到行分隔符，所以读取空值 scanner1.hasNext(); // 是否还有更多数据 scanner1.nextLine(); // 读取下一行，以换行结束 scanner1.next(); // 读取下一段数据作为字符串返回（一段以分隔符作为划分标准，默认为Java空白符，即Character.isWhitespace） scanner1.nextByte(); // 读取下一段数据作为byte值返回 scanner1.nextShort(); scanner1.nextInt(); scanner1.nextLong(); scanner1.nextFloat(); scanner1.nextDouble(); scanner1.useDelimiter(&quot;,&quot;); // 更换分割符 scanner1.useRadix(16); // 更换获取数字基数 scanner1.useLocale(Locale.CHINA); // 更换区域属性（影响某些格式读取，比如小数，123,123区域是德国时读取为123.123，区域是中国时读取为123123.0） scanner1.reset(); // 重置为默认分割符、默认基数、默认区域 scanner1.close(); scanner2.close(); // try-with-resource方式，try跟一个圆括号里面声明及创建资源，该资源需要继承自AutoCloseable，后面花括号里使用资源 // 结束时这种方式不需要手动close，程序会自动调用close try ( PrintWriter pr3 = new PrintWriter(file1);// 声明与创建资源需要在同一行语句，不过可以多行创建多个资源 Scanner scanner3 = new Scanner(file1); ) &#123; pr3.print(&quot;dd&quot;); scanner3.hasNext(); &#125; // 网络文件URL读取 try &#123; java.net.URL url = new java.net.URL(&quot;http://www.baidu.com&quot;); Scanner input = new Scanner(url.openStream()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; void fun23() throws FileNotFoundException, IOException &#123; // 二进制文件读写，根类二进制IO类InputStream/OutputStream，二进制文件IO类（字节读取）FileInputStream/FileOutputStream // 二进制文件IO类（基本数据类型基类）FilterInputStream/FilterOutputStream，二进制文件IO类（基本数据类型）DataInputStream/DataOutputStream // 带缓冲区二进制文件IO类BufferedInputStream/BufferedOutputStream，二进制文件IO类（对象类型）ObjectInputStream/ObjectOutputStream // 随机位置IO类RandomAccessFile // 可以使用try-with-resource方式声明二进制文件IO类对象 // FileInputStream/FileOutputStream方法全部继承自InputStream/OutputStream File file1 = new File(&quot;null.dat&quot;); FileInputStream fis1 = new FileInputStream(file1); // 用File对象创建FileInputStream对象 FileInputStream fis2 = new FileInputStream(&quot;filename&quot;); // 用文件名字符串创建FileInputStream对象 fis1.read(); // 读下一个字节，没有可读的返回-1 byte[] bts = new byte[133]; fis1.read(bts); // 读取bts.length个字节到数组bts中，返回实际读取的字节，没有可读的返回-1 fis1.read(bts, 10, 11); // 读取11个字节到数组bts中从第10位开始的位置，返回实际读取的字节，没有可读的返回-1 fis1.available(); // 返回可读字节数估计值 fis1.skip(82); // 跳过且丢弃指定字节数，返回实际跳过的字节数 fis1.markSupported(); // 输入流是否支持mark()和reset()方法 fis1.mark(5); // 在输入流中标记当前位置，5为mark标记失效前可读取的最大字节数（但实际上与这个数字和输入流的具体类型两者有关） fis1.reset(); // 输入流重新定位到最后一次调用mark()方法时的位置 fis1.close(); // 关闭流 fis2.close(); FileOutputStream fos1 = new FileOutputStream(file1); // 用File对象创建FileOutputStream对象 FileOutputStream fos2 = new FileOutputStream(&quot;filename&quot;); // 用文件名字符串创建FileOutputStream对象 FileOutputStream fos3 = new FileOutputStream(file1, true); // 参数2设为true为向文件中追加 fos1.write(65); // 将指定字节写出到输出流(写出去的是表示65的字节，按数字读出来就是65，按字符读出来就是&#x27;A&#x27;) fos1.write(bts); // 将bts数组中所有字节写出到输出流 fos1.write(bts, 1, 3); // 将bts数组中从1开始的3个字节写出到输出流 fos1.flush(); // 写出在缓冲区中的所有字节 fos1.close(); // 关闭流 fos2.close(); fos3.close(); // 写入与读取需要配套使用 DataInputStream dis1 = new DataInputStream(fis1); // 用InputStream对象创建DataInputStream对象 DataOutputStream dos1 = new DataOutputStream(fos1); // 用OutputStream对象创建DataOutputStream对象 dis1.readBoolean(); // 读一个boolean值 dis1.readByte(); // 读一个byte值 dis1.readUnsignedByte(); // 读一个无符号byte值 dis1.readChar(); // 读一个字符值 dis1.readFloat(); // 读一个float值 dis1.readDouble(); // 读一个double值 dis1.readInt(); // 读一个int值 dis1.readLong(); // 读一个long值 dis1.readShort(); // 读一个short值 dis1.readUnsignedShort(); // 读一个无符号short值 dis1.readLine(); // 读一行字符（已废弃，SDK文档指明读取不准确） dis1.readUTF(); // 以UTF格式读字符串 dos1.writeBoolean(false); // 写一个boolean值 dos1.writeByte(41); // 写一个参数的低位字节 dos1.writeBytes(&quot;sce&quot;); // 写一个字符串中各字符的低位字节 dos1.writeChar(&#x27;1&#x27;); // 写一个字符（2字节） dos1.writeChars(&quot;daa&quot;); // 写一个字符串中所有字符（每个字符2字节） dos1.writeFloat(8.1f); // 写一个float值 dos1.writeDouble(3.12); // 写一个double值 dos1.writeInt(42); // 写一个int值 dos1.writeLong(6903912313L);// 写一个long值 dos1.writeShort(45); // 写一个short值 dos1.writeUTF(&quot;xia&quot;); // 以UTF格式写字符串 dis1.close(); dos1.close(); // readUTF/writeUTF注意事项：writeUTF会先写入2字节无符号数字作为长度信息，所以写入时需要对过长的字符串进行分片，读取是同样是分片读取再拼接 // writeBytes、writeChars、writeUTF使用区别：writeBytes适用于全都是ASCII码的字符组成的字符串； // writeChars写入2字节字符的序列，用readChar读取适当长度；writeUTF适用于存在ASCII之外字符（如中文）的字符串，读取时可以自动确定读取长度 // 检测文件尾 try &#123; try (DataInputStream dis2 = new DataInputStream(fis1)) &#123; while (true) &#123; System.out.println(dis2.readInt()); &#125; &#125; &#125; catch (EOFException e) &#123; // 用EOFException检测文件尾 // handle exception &#125; // 带缓冲区的IO类，方法同FileInputStream/FileOutputStream一样，全部继承自InputStream/OutputStream BufferedInputStream bis1 = new BufferedInputStream(fis1); // 用InputStream对象创建BufferedInputStream对象（默认缓存大小512字节） BufferedInputStream bis2 = new BufferedInputStream(fis1, 1024); // 用InputStream对象创建BufferedInputStream对象（缓存大小1024字节） BufferedOutputStream bos1 = new BufferedOutputStream(fos1); // 用OutputStream对象创建BufferedOutputStream对象（默认缓存大小512字节） BufferedOutputStream bos2 = new BufferedOutputStream(fos1, 1024);// 用OutputStream对象创建BufferedOutputStream对象（缓存大小1024字节） bis1.close(); bis2.close(); bos1.close(); bos2.close(); // 对象IO类，可写入的对象必须实现java.io.Serializable接口，但该接口并不需要多实现什么方法 ObjectInputStream ois1 = new ObjectInputStream(bis1); // 用InputStream对象创建ObjectInputStream对象 ObjectOutputStream oos1 = new ObjectOutputStream(bos1); // 用OutputStream对象创建ObjectOutputStream对象 oos1.writeObject(new java.util.Date()); try &#123; java.util.Date date1 = (java.util.Date)(ois1.readObject()); &#125; catch (ClassNotFoundException e) &#123; // ... &#125; // 随机位置IO类RandomAccessFile RandomAccessFile raf1 = new RandomAccessFile(&quot;null.dat&quot;, &quot;rw&quot;); // 用文件名创建RandomAccessFile对象，指定可读可写模式 RandomAccessFile raf2 = new RandomAccessFile(file1, &quot;r&quot;); // 用文件对象创建RandomAccessFile对象，指定可读模式 raf1.setLength(0); // 设置文件大小为0字节（清空原文件内容） raf1.seek(0); // 文件指针移动到文件开头 raf1.writeInt(42); raf1.writeChar(&#x27;D&#x27;); raf1.seek(Integer.BYTES); raf1.readChar(); raf1.length(); // 获取文件大小（字节） &#125; void fun24() &#123; // 日历日期 java.util.Calendar calendar = new java.util.GregorianCalendar(2002, 00, 14); // GregorianCalendar公历，2002-01-14，月份以0为开始 // 日历域部分常量 int value = java.util.Calendar.YEAR; // 年 value = java.util.Calendar.MONTH; // 月（0表示一月） value = java.util.Calendar.DATE; // 日 value = java.util.Calendar.HOUR; // 小时（12小时制） value = java.util.Calendar.HOUR_OF_DAY; // 小时（24小时制） value = java.util.Calendar.MINUTE; // 分钟 value = java.util.Calendar.SECOND; // 秒 value = java.util.Calendar.DAY_OF_WEEK; // 一周内第几天（1-7表示星期日-星期六） value = java.util.Calendar.DAY_OF_MONTH; // 一月内第几天，等于DATE value = java.util.Calendar.DAY_OF_YEAR; // 一年内第几天（1为第一天） value = java.util.Calendar.WEEK_OF_MONTH; // 一月内第几周（1为第一周） value = java.util.Calendar.WEEK_OF_YEAR; // 一年内第几周（1为第一周） value = java.util.Calendar.AM_PM; // 上午还是下午（0-上午，1-下午） calendar.get(java.util.Calendar.DATE); // 返回一个给定日历域（年月日小时等上述常量）的值 calendar.set(java.util.Calendar.DATE, 3); // 给指定日历域设指定值 calendar.set(2001, 10, 12, 23, 9, 2); // 设置指定日历 calendar.getActualMaximum(java.util.Calendar.DATE);// 获取该日历对象某日历域的最大值 calendar.add(java.util.Calendar.DATE, 2); // 给指定日历域增加指定数量时间 calendar.getTime(); // 获取该日历对应的Date日期对象 calendar.setTime(new java.util.Date()); // 使用指定Date日期对象设置日历的时间 &#125; // 迭代器 // 迭代器仅适用于集合类（Collection，包括List、Set、Queue，如Vector、ArrayList、HashSet）， // List 接口实例存储的是有序的，可以重复的元素，可以动态增长，查找元素效率高，插入删除效率低，插入和删除会引起其他元素位置改变 // Set 接口实例存储的是无序的，不重复的数据，可以动态增长，查找元素效率低，插入删除效率高，插入和删除不会引起元素位置改变 void fun25() &#123; ArrayList&lt;String&gt; als = new ArrayList&lt;&gt;(); java.util.Iterator&lt;String&gt; its = als.iterator(); its.hasNext(); // 是否有下一个元素 its.next(); // 返回下一个元素 its.remove(); // 移除下一个元素 // 可以认为iterator所指的位置在元素与元素之间的夹缝，一开始iterator则处在第0个元素前，此时所有“下一个元素”都是指第0个元素 &#125; // 异常处理 // 如果发生的错误需要调用者处理，则方法应当抛出异常。如果发生的错误简单、可预见，则应局部处理掉而不抛出异常。如果发生的异常本方法中可以处理，则不要抛出异常 void fun26() &#123; Scanner input = new Scanner(System.in); int number1 = input.nextInt(); int number2 = input.nextInt(); // 方法1：主动终止，不推荐，应当让调用者决定是否直接退出程序 System.out.println(quotient1(number1, number2)); // 方法2：try-catch异常 try &#123; // try块内执行正常语句 System.out.println(quotient2(number1, number2)); &#125; catch (ArithmeticException e) &#123; // catch块指定可以捕获的异常类型，执行异常处理 System.out.println(e.getMessage()); &#125; catch (Exception ee) &#123; // catch块要按照异常类型从子类到父类顺序出现，因为父类的catch块可以捕获所有子类异常，否则永远不会走到子类catch块（当然不一定出现直接父类的catch块） System.out.println(ee.getMessage()); &#125; finally &#123; // finally块一定会执行，即使try或者catch中出现了return语句。如果出现了finally块，则可省略catch块 input.close(); &#125; // 抛出必检异常的方法必须用try-catch块处理，且抛出的异常必须都要处理 try &#123; fun27(1); &#125; catch (IOException ei)&#123; System.out.println(ei.getMessage()); &#125; catch (ClassNotFoundException ec) &#123; System.out.println(ec.getMessage()); &#125; // JDK7加入的多捕获特性，多个异常处理方式相同时可以这样简化写，但是如果有继承关系的类会不让写子类，比如 IOException | Exception 中IOException报错 try &#123; fun27(1); &#125; catch (IOException | ClassNotFoundException e)&#123; System.out.println(e.getMessage()); // 描述该对象的信息（构造函数传入的String） e.toString(); // 返回 类名: 描述该对象的信息 e.printStackTrace(); // 控制台上打印对象及调用堆栈信息（约等于 toString + getStackTace） e.getStackTrace(); // 获取该对象相关的堆栈跟踪元素的数组，堆栈跟踪元素中存储了抛出异常的方法、所在类、行号等信息 &#125; // 异常无法再本函数内处理，或者希望调用者关注到这个异常，那么可以重新抛出这个异常 try &#123; System.out.println(quotient2(number1, number2)); &#125; catch (Exception e) &#123; // ... 做些退出方法之前要做的事 throw e; // 重新抛出异常给调用者 &#125; // 链式异常，抛出的新异常附带上原始异常的信息 try &#123; chainExceptionMethod1(); &#125; catch (Exception e) &#123; e.printStackTrace(); // 打印chainExceptionMethod1中创建的链式异常 &#125; /* * 从异常根类（Throwable）分出的异常类型： * 系统错误（Error）：Java虚拟机抛出，表示内部系统错误，极少发生，但是发生了基本只能终止程序，例如 * 链接错误（LinkageError）：A依赖B，但是A编译后B进行了改动而不兼容 * 虚拟机错误（VirtualMachineError）：Java虚拟机崩溃，或者运行所需资源耗尽 * 异常（Exception）：表示程序或外部环境引起的错误，可以由程序捕获处理，例如 * 类未找到异常（ClassNotFoundException）：试图使用一个不存在的类 * 输入输出异常（IOException）：如无效输入、读文件超过文件尾、打开不存在的文件等。子类有InterruptedlOException、EOFException、FileNotFoundException * 运行时异常（RuntimeException）：程序设计错误，例如 * 算数异常（ArithmeticException）：整数除以0、数字溢出等 * 空指针异常（NullPointerException）：null引用变量访问对象 * 索引超边界异常（IndexOutOfBoundsException）：数组下标超出范围 * 非法参数异常（IllegalArgumentException）：传给方法的参数非法或者不合适 * RuntimeException、Error及它们的子类称为免检异常，Java不强制要求编写代码捕获或声明免检异常。其他异常称为必检异常，指编译器强制程序员检查并使用try-catch块处理这些异常 */ &#125; // 方法1：主动终止，不推荐，应当让调用者决定是否直接退出程序 int quotient1(int number1, int number2) &#123; if (number2 == 0) &#123; System.out.println(&quot;Divisor cannot be zero&quot;); System.exit(1); // 直接退出程序 &#125; return number1 / number2; &#125; // 方法2：try-catch异常 int quotient2(int number1, int number2) &#123; if (number2 == 0) &#123; throw new ArithmeticException(&quot;Divisor cannot be zero&quot;);// 抛异常 &#125; return number1 / number2; &#125; public static void chainExceptionMethod1() throws Exception &#123; try &#123; chainExceptionMethod2(); &#125; catch (Exception e) &#123; throw new Exception(&quot;New from method1&quot;, e); // 创建一个链式异常。如果不带参数e，则fun20中只会打印该方法的异常信息， // 不会打印chainExceptionMethod2中的异常（因为捕获到的异常对象e未使用） &#125; &#125; public static void chainExceptionMethod2() throws Exception &#123; throw new Exception(&quot;New from method2&quot;); &#125; // 必检异常必须在方法头声明异常，免检异常不需要 // 如果一个方法在父类没声明异常，则子类不能通过重写来声明异常 void fun27(int i) throws ClassNotFoundException, IOException &#123; // 声明异常（关键字throws，多个异常中间用逗号分隔） if (i == 1) &#123; throw new ClassNotFoundException(); &#125; throw new IOException(); &#125; // lambda表达式 // 形式 (type1 param1, type2 param2, ...) -&gt; expression 或者 (type1 param1, type2 param2, ...) -&gt; &#123; statements; &#125; // 形参可以省略类型声明；形参只有一个时可以省略圆括号；不需要形参时可省略形参，但此时需要保留圆括号 // 方法体如果主体只有一个表达式则编译器会自动推断返回值，大括号则需要语句块内指定返回值 // 只适用于只含有一个方法的接口（也称为功能接口或者单抽象方法接口） void fun28() &#123; // 相当于声明了一个实现了L1接口的类即一个该类实例，并将其中唯一的m方法实现为System.out.println(&quot;null&quot;); ，使用声明的匿名实例调用lambdaFun1 lambdaFun1(() -&gt; System.out.println(&quot;null&quot;)); // 相当于声明了一个实现了L2接口的类，并将其中唯一的m方法实现为System.out.println(L); ，以及调用了m方法 lambdaFun2(L -&gt; System.out.println(L)); // 相当于声明了一个实现了L3接口的类，并将其中唯一的m方法实现为&#123; return d + d2; &#125; ，以及调用了m方法 lambdaFun3((d, d2) -&gt; &#123; return d + d2; &#125;); &#125; void lambdaFun1(LambdaInterface1 l1) &#123; l1.m(); &#125; void lambdaFun2(LambdaInterface2 l2) &#123; l2.m(3); &#125; void lambdaFun3(LambdaInterface3 l3) &#123; l3.m(3, 5); &#125; // 枚举 // 枚举类型命名类似一个类，类型值命名类似常量，枚举类型变量是引用变量 // 枚举是Object类和Comparable接口、Serializable接口子类，继承了Object类所有方法和Comparable接口的compareTo方法 // 类内枚举编译为 IntroductionToJavaBasic$MyDay.class，类外枚举编译为 MyColor.class // 类内枚举需要声明为静态成员，而不能声明在方法中，static关键字可省略 /*static*/ enum MyDay &#123;MONDAY, FRIDAY&#125;; void fun29() &#123; MyColor color = null; color = MyColor.RED; color.compareTo(MyColor.GREEN); // 枚举值之间的序号差 color.name(); // 枚举值对应的名字 color.ordinal(); // 枚举值对应的序号 MyColor.values(); // 枚举类所有枚举值 MyColor.valueOf(&quot;RED&quot;); // 字符串对应的枚举常量，该枚举常量必须存在 color.colorInfo(); // 枚举自定义方法 switch (color) &#123; case GREEN: break; case BLUE: break; case RED: break; default: &#125; for (MyColor m : MyColor.values()) &#123;&#125; &#125;&#125;// -------- 自定义异常 ----------// 自定义异常类，可以继承自任意异常类，但是如果自定义了最好还是继承自必检异常比如Exception等，而不是RuntimeException等免检异常class InvalidRadiusException extends Exception &#123; private double radius; public InvalidRadiusException(double radius) &#123; super(&quot;Invalid radius&quot; + radius); this.radius = radius; &#125; public double getRadius() &#123; return radius; &#125;&#125;class CircleWithCustomException &#123; private double radius; public CircleWithCustomException() throws InvalidRadiusException &#123; // 使用了自定义必检异常，所有抛异常的方法都要声明抛出异常 this(1.0); &#125; public CircleWithCustomException(double newRadius) throws InvalidRadiusException &#123; setRadius(newRadius); &#125; public double getRadius() &#123; return radius; &#125; public void setRadius(double newRadius) throws InvalidRadiusException &#123; if (newRadius &gt;= 0) &#123; radius = newRadius; &#125; else &#123; throw new InvalidRadiusException(newRadius); &#125; &#125;&#125;class SerializableClass implements java.io.Serializable &#123; private int v1; private static double v2; // 静态变量不会序列化 private transient UnerializableClass v3;// 未声明实现java.io.Serializable的类无法序列化，要使SerializableClass可序列化需要加transient关键字忽略掉&#125;class UnerializableClass &#123;&#125;interface LambdaInterface1 &#123; void m();&#125;interface LambdaInterface2 &#123; void m(double d);&#125;interface LambdaInterface3 &#123; double m(double d, double d2);&#125;enum MyColor &#123; RED, GREEN, BLUE; // 枚举类可以有自己的构造函数、方法，但是构造函数必须private private MyColor() &#123; System.out.println(&quot;Constructor called for : &quot; + this.toString()); &#125; public void colorInfo() &#123; System.out.println(&quot;Universal Color&quot;); &#125;&#125;; 二、基础部分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373public class IntroductionToJavaClassInterface &#123; public static void main(String[] args) &#123; &#125; void fun1() &#123; ExampleClass1 eClass1 = new ExampleClass1(); System.out.println(eClass1.defaultInt); // 使用成员变量 System.out.println(eClass1.classInt); // 使用静态变量，不推荐 System.out.println(ExampleClass1.classInt); // 使用静态变量 System.out.println(eClass1.getDoubleNum()); // 调用方法 System.out.println(eClass1.getClassInt()); // 调用静态方法，不推荐 System.out.println(ExampleClass1.getClassInt());// 调用静态方法 // 内部类对象创建方式 OuterClass outerObj = new OuterClass(); OuterClass.InnerClass innerObj = outerObj.new InnerClass(); // 非静态内部类 OuterClass.StaticInnerClass innerObj2 = new OuterClass.StaticInnerClass(); // 静态内部类 &#125; // 多态、动态绑定 void fun2() &#123; BaseClass bClass = null; bClass = new SubClass(); // 多态：父类型变量可以引用子类型对象，可以给将子类实例传给父类型参数 bClass.description(); // 动态绑定：对象调用父类还是子类的重写实例方法，是看对象的实际类型而不是声明类型。 // 调用时查找方法实现会沿着继承链向上找，调用找到的第一个实现。此处调用SubClass.description() // 注意：匹配方法签名和绑定方法实现不同。编译器根据声明类型匹配方法签名，虚拟机在运行时根据实际类型动态绑定方法实现 if (bClass instanceof SubClass) &#123; // instanceof 测试变量所指对象是否是某个类的实例 SubClass sClass = (SubClass)bClass; // 父类变量转换为子类变量需要强制转换，且父类变量必须实际引用的是子类实例 &#125; &#125; // 判断相同 void fun3() &#123; BaseClass bcls1 = new BaseClass(); BaseClass bcls2 = new BaseClass(); System.out.println(bcls2.equals(bcls1)); // equals默认实现为==，false System.out.println(bcls2 == bcls1); // 是否同一对象，false bcls2 = bcls1; System.out.println(bcls2.equals(bcls1)); // true System.out.println(bcls2 == bcls1); // true SubClass scls1 = new SubClass(1); SubClass scls2 = new SubClass(1); System.out.println(scls2.equals(scls1)); // equals被重载，true System.out.println(scls2 == scls1); // 是否同一对象，false scls2 = scls1; System.out.println(scls2.equals(scls1)); // true System.out.println(scls2 == scls1); // true &#125;&#125;// 同一文件中其他类不能public，因此也只能从包内访问到，包外不可见// 类前可见性修饰符只有public和空，没有private、protected// 类的字段与方法介绍class ExampleClass1 &#123; // 字段（属性）：实例变量（对象变量），静态变量（类变量） // 一般字段和方法声明可以在类中按任意顺序出现，不写可见性修饰符则默认public int intNum; int intNum2 = intNum + 1; // 除了这种一个字段需要别的字段的值来初始化的情况 double doubleNum; // 实例变量，数值类型不写初始值时默认值0 String str; // 引用类型变量默认值null boolean b; // boolean类型变量默认值false char c; // char类型变量默认值&#x27;\\u0000&#x27; int defaultInt = 1; // 带默认初始值的实例变量 private double doubleNum2; static int classInt = 3; // 静态变量，类的多个实例共有，需要外部设置时最好提供单独的方法进行设置，而不是与实例变量共用初始化方法 // 构造方法，默认public，但是可以private以避免用户创建该类实例 // 类中没有任一构造方法时，编译器自动提供一个无参且方法体为空的构造方法，即 ExampleClass1() &#123;&#125; // 但是类中有任一带参构造方法时，无参的构造方法不会生成，作为基类会编译失败 ExampleClass1() &#123; doubleNum = 1; &#125; ExampleClass1(double newDoubleNum) &#123; doubleNum = newDoubleNum; &#125; // 方法：实例方法、静态方法（类方法） // 私有字段需要给外部提供访问器（getter）、修改器（setter）时，约定俗成方法名用get、set开头 double getDoubleNum() &#123; // 实例方法可以调用静态方法、实例方法，访问静态变量、实例变量 return doubleNum; &#125; static int getClassInt() &#123; // 静态方法，只能调用静态方法、访问静态变量，不能调用实例方法、访问实例变量 return classInt; &#125; // 用System.out.print(object)之类打印一个对象时是调用的该对象的toString方法，见IntroductionToJavaBasic.java的fun4 // 为了给出更多信息应当在自己的类重写toString方法 public String toString() &#123; return &quot;intNum&quot; + intNum; &#125;&#125;// 类的this使用方法、获取被隐藏的字段class ExampleClass2 &#123; private int i; private static double k = 0; ExampleClass2() &#123; this(1); // 使用this调用另外的构造方法，且本方法中其他语句要在这个调用之后 &#125; ExampleClass2(int intNum) &#123; i = intNum; &#125; void setI(int i) &#123; this.i = i; // 同名局部变量会隐藏类的相应字段，但是可以通过this来重新引用到 &#125; static void setK(int k) &#123; ExampleClass2.k = k; // 而静态变量可以且只能通过类名来引用到 &#125;&#125;// 直接在类中加main方法来测试/*public class MyCircle &#123; public static void main(Strings[] args) &#123; MyCircle circle = new myCircle(); System.out.println(circle.getArea()); &#125; double radius; // 构造方法 MyCircle() &#123; radius = 1; &#125; MyCircle(double newRadius) &#123; radius = newRadius; &#125; // 方法 double getArea() &#123; return radius * radius * Math.PI; &#125; double getPerimeter() &#123; return 2 * radius * Math.PI; &#125; void setRadius(double newRadius) &#123; radius = newRadius; &#125;&#125;*/// 内部类// 1.内部类编译成的类名为OuterClass$InnerClass// 2.内部类可以直接引用所有定义在外部类的数据和方法，包括私有。// 3.内部类可以使用可见性修饰符定义// 4.内部类可以使用static定义，此时外面访问内部类需要使用外部类的名字访问，内部类无法访问非静态的外部类成员// 5.从外面创建内部类对象：内部类非静态与静态创建方式不同，见IntroductionToJavaClassInterface.fun1注释class OuterClass &#123; public class InnerClass &#123;&#125; static public class StaticInnerClass &#123;&#125; public void fun() &#123; // 匿名内部类，同时定义内部类且创建内部类实例 // 1.必须继承某基类或者实现某接口，但是不能写extends或者implements // 2.匿名内部类必须实现父类或者接口中所有抽象方法 // 3.匿名内部类的“创建”是使用无参构造方法创建的，就是代码中基类或者接口后的一对小括号 // 4.匿名内部类编译成的类名为OuterClass$n，n代表第几个出现的内部类 new Edible() &#123; public String howToEat() &#123; return &quot;fun&quot;; &#125; &#125;; &#125;&#125;// 不可变类、不可变对象// 指字段全部私有、没有setter、没有返回可变引用变量字段的getterclass ExampleImmutableClass &#123; private int id; // 私有基本类型变量且没有对应setter，可以 private String name; // 私有引用变量没有setter，String不可变getter返回的也就不可变，可以 // private java.util.Date dateCreated; // ×，私有引用变量没有setter，但是getter返回Date是可变对象，不能出现 public ExampleImmutableClass(int ssn, String newName) &#123; id = ssn; name = newName; // dateCreated = new java.util.Date(); &#125; public int getId() &#123; return id; &#125; public String getName() &#123; return name; &#125; // public java.util.Date getDateCreated() &#123; // return dateCreated; // &#125;&#125;// 类继承，超类（父类、基类）// 其实没标注extends的类也是一个类的子类，是java.lang.Object类的子类class BaseClass &#123; private String strParam; public BaseClass() &#123;&#125; public BaseClass(String str) &#123; strParam = str; &#125; public String getStrParam() &#123; return strParam; &#125; public void setStrParam(String str) &#123; strParam = str; &#125; public void description() &#123; System.out.println(&quot;BaseClass&quot;); &#125; protected void exFun() &#123; &#125; // final方法不可被子类重写 public final void finalfun() &#123; &#125;&#125;// 类继承，次类（子类、扩展类、派生类），仅有单继承，无多重继承// 子类继承所有基类的public方法（即可以用子类对象调用基类声明的public方法），但是不继承父类构造函数// 子类对父类数据域的访问同其他外部类一样，可以直接访问public字段，只能通过父类提供的getter、setter访问private字段class SubClass extends BaseClass &#123; private int intParam; public SubClass() &#123; super(); // 调用父类构造方法，必须出现在子类构造方法第一行，不能使用父类名字调用父类构造方法如BaseClass() intParam = 42; &#125; public SubClass(int i) &#123; // 不显式调用父类构造方法，编译器则会先隐式调用父类的无参构造方法 // 即使类内构造方法互相调用，对父类的构造方法的隐式调用也只调用一次，位置是第一个被调用的本类构造函数（外部new或者子类调用之类）最开始 intParam = i; &#125; public SubClass(int i, String str) &#123; super(str); intParam = i; &#125; public int getIntParam() &#123; return intParam; &#125; public void setIntParam(int i) &#123; intParam = i; &#125; public void fun(String str) &#123; setStrParam(str); // 调用父类方法，也可写作super.setStrParam(str); &#125; // 方法重写，返回值类型、方法名、形参类型数量顺序（即返回值类型与方法签名）要完全相同 // 父类方法在子类中可见才再能被重写，如果父类是private方法，则这个方法就与父类的那个方法完全互相独立 // 父类静态方法没法在子类中重写，子类静态方法会隐藏父类同返回值类型与方法签名的静态方法，父类该方法可用父类名.静态方法名调用 @Override // 重写标注，表示被标注的方法必须重写父类的一个方法，否则编译器报错 public void description() &#123; super.description(); // 调用父类该方法，但是SubClass的子类就没法调到BaseClass的description方法了（即super.super.description();语法错误） System.out.println(&quot;SubClass&quot;); &#125; // 重写比较相等方法示例，注意形参类型为Object而不是具体某个类型 @Override public boolean equals(Object o) &#123; if (o instanceof SubClass) &#123; return intParam == ((SubClass)o).getIntParam(); &#125; else &#123; return this == o; &#125; &#125; // 重写父类方法可以扩大可访问性，但是不能缩小 @Override public void exFun() &#123; super.exFun(); &#125; // final方法不可重写 // @Override // public void finalfun()&#123;&#125;&#125;// final类不可被继承final class FinalClass&#123;&#125;// class SubFinalClass extends FinalClass&#123;&#125;// 抽象类，不可创建此类实例，可以不含有抽象方法abstract class AbsClass &#123; private int intNum; // 即使public也不能被外部调用来初始化，只能用于子类super来调用 public AbsClass() &#123; this.intNum = 1; &#125; public void setIntNum(int intNum) &#123; this.intNum = intNum; &#125; public int getIntNum() &#123; return intNum; &#125; // 抽象方法，只定义不实现，只能出现在抽象类中，不能是静态方法 public abstract void someFun(); public void someFunToBeAbs() &#123; System.out.println(&quot;someFunToBeAbs&quot;); &#125;&#125;class DeriveAbsClass extends AbsClass&#123; @Override public void someFun() &#123; System.out.println(&quot;DeriveAbsClass&quot;); &#125;&#125;abstract class DeriveAbsClass2 extends AbsClass &#123; // 有必要时，子类可将父类非抽象方法覆盖为抽象方法 @Override public abstract void someFunToBeAbs();&#125;// 接口，不可创建接口实例，一个接口可以继承自多个接口（接口有多继承，类没有），接口类型变量可以引用所有实现该接口的对象（类似于基类类型变量）/* public */ interface Edible &#123; // 接口数据域都是public static final的（常量），方法都是public abstract的（抽象方法） public static final int K = 1; // 可省略为int K = 1; public abstract String howToEat(); // 可省略为String howToEat();&#125;// 接口多继承interface MultiInterface&lt;E&gt; extends Comparable&lt;E&gt;, Cloneable, Edible&#123;&#125;class Orange extends BaseClass implements Edible, Comparable&lt;Orange&gt;, Cloneable &#123; // 继承只能继承一个，接口可以实现多个 Integer size; java.util.Date dt; @Override public String howToEat() &#123; return &quot;Eat&quot;; &#125; // Comparable&lt;E&gt; 可比较泛型接口，实现接口的类要指明泛型的类，实现compareTo()方法，返回正、负、0值。实现了可比较接口的类就可以使用sort排序 @Override public int compareTo(Orange o) &#123; return size.compareTo(o.size); &#125; // Cloneable 可克隆接口，不含有方法，称为“标记接口”，表示某个类有某特定属性。自定义类继承Cloneable接口时必须覆盖实现clone()方法 @Override public Object clone() throws CloneNotSupportedException &#123; // return super.clone(); // 浅复制 // 深复制，对引用对象手动调用复制，以便拷贝出副本而不是仅仅拷贝一个引用 Orange orangeClone = (Orange)super.clone(); orangeClone.dt = (java.util.Date)(dt.clone()); return orangeClone; &#125;&#125;","categories":[{"name":"学习","slug":"学习","permalink":"https://neko-horikawaraiko.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://neko-horikawaraiko.github.io/tags/Java/"}]},{"title":"《Objective-C高级编程 iOS与OS X多线程和内存管理》阅读笔记","slug":"《Objective-C高级编程 iOS与OS X多线程和内存管理》阅读笔记","date":"2023-05-05T11:34:43.000Z","updated":"2024-10-21T16:28:22.121Z","comments":true,"path":"2023/05/05/《Objective-C高级编程 iOS与OS X多线程和内存管理》阅读笔记/","link":"","permalink":"https://neko-horikawaraiko.github.io/2023/05/05/%E3%80%8AObjective-C%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%20iOS%E4%B8%8EOS%20X%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/","excerpt":"","text":"1.2 内存管理/引用计数 以alloc、new、copy、mutableCopy开头（驼峰命名法）的函数返回的对象归调用者持有（retainCount增加1），函数内不持有（所以[[NSObject alloc] init]，调用alloc时就已经增加了引用计数） 不以上述四种开头函数返回的对象，调用者并不持有（retainCount不增加），（MRC情况下）一般这种函数内调用autorelease方法放到自动释放池中（这里相当于自动释放池也持有了对象）。（ARC中没有调用autorelease方法，但对象也会自动注册到自动释放池，销毁的只是函数内的变量）在手动管理内存中，可以调用retain方法来持有返回的对象 123456789101112// MRC中，返回给调用者持有 给调用者但是调用者不持有 两种方法书写方式- (id)allocObject &#123; id obj = [[NSObject alloc] init]; return obj;&#125;- (id)object &#123; id obj = [[NSObject alloc] init]; [obj autorelease]; return obj;&#125;// ARC中，两种方法书写方式相同，都是allocObject那种，区别是编译器是否自动加autorelease 在手动管理内存中，自己不持有的对象不要释放（即不调用release方法） autorelease方法实际上把对象加到了对象所在层次的自动释放池的一个数组中，自动释放池调用drain时这些对象全部调一遍release方法 1.3 ARC规则 所有权修饰符__strong，__weak，__unsafe_unretained，__autoreleasing，其中__strong，__weak，__autoreleasing修饰的变量可以自动初始化为nil 修饰传统静态数组（[]声明的）时数组内的各对象内容也会是nil（数组本身并不是nil） 修饰传统动态数组id __strong *obj、NSObject * __strong *obj不保证指针变量obj可以自动初始化为nil 一般不写默认是__strong修饰符，是持有、强引用含义，变量超出作用域时变量销毁，强引用失效，自动释放对象（相当于调一次release） 123id obj = [[NSObject alloc] init];// 等于id __strong obj = [[NSObject alloc] init]; __weak修饰符的变量，不持有、弱引用，如果被赋给一个归调用者持有的对象会报警告，如id __weak obj = [[NSObject alloc] init]; //报警告。变量出作用域时不会进行释放操作，变量指向的对象被销毁时变量自动置nil __unsafe_unretained修饰符的变量，不持有、不强也不弱引用。ARC不管理这个修饰符修饰的变量，现在基本不用该修饰符 __autoreleasing修饰的变量如果在@autoreleasepool块内，就是自动注册到了自动释放池 12345@autoreleasepool &#123; id /* __strong */ obj = [NSArray array]; // obj持有对象，array方法内部对象也注册到了自动释放池，持有+2 // 退出autoreleasepool块时obj销毁，持有-1，自动释放池注册的对象释放，持有-1，对象就销毁&#125; 显示指定__autoreleasing修饰符的变量必须为自动变量（局部变量、函数及方法参数） 访问__weak修饰的变量引用的对象时，实际上是通过一个新的带有__autoreleasing修饰的临时变量访问到对象（每次访问变量都将引用到的对象注册到释放池一次，即使变量是同一个），因为需要保证在访问过程中对象一直存在，即 123456id __weak obj1 = obj0; // obj0是__strong变量NSLog(@&quot;class=%@&quot;, [obj1 class]);// 等于id __weak obj1 = obj0;id __autoreleasing tmp = obj1;NSLog(@&quot;class=%@&quot;, [tmp class]); id的指针或对象的指针中间其实默认是__autoreleasing修饰符，即id *obj;实际上为id __autoreleasing *obj;，NSObject **obj;实际上为NSObject * __autoreleasing *obj;，不论是声明还是形参 123456789101112// 比如方法- (BOOL)performOperationWithError:(NSError **)error &#123; // 发生错误 *error = [[NSError alloc] initWithDomain:MyAppDomain code:errorCode userInfo:nil]; return NO;&#125;// 理解为 - (BOOL)performOperationWithError:(NSError * __autoreleasing *)error;// 调用NSError *error = nil;[obj performOperationWithError:&amp;error];// 函数内的error对象自动注册到自动释放池，调用者不需要管// 此处调用不需要所有权修饰符一致的原因：编译器自动转化了，传进去的是 NSError __autoreleasing *tmpError = error; 所有权修饰符一致： 12345678NSError *error = nil;NSError * __strong *pError = &amp;error;NSError __weak *error = nil;NSError * __weak *pError = &amp;error;NSError __unsafe_unretained *error = nil;NSError * __unsafe_unretained *pError = &amp;error; ARC有效时，以init开头（驼峰命名法）的方法也归调用者持有，不注册到自动释放池。init开头的方法必须为实例方法，必须返回对象，返回的对象必须是id、本类、本类的父类、本类的子类四种类型中的一个。比如返回void、方法名为initialize等情况不适用该规则 ARC有效时，dealloc内只做废弃对象时必须的处理，如删除注册的代理、观察者对象等。方法内不能调[super dealloc]，且废弃对象不能手动调[obj dealloc]，编译器都会自己调 ARC有效时，对象型变量不能作为C结构体成员，因为编译器不知道结构体成员的初始化和废弃时间（因为C语言规约没有规定），而ARC是要求编译器来管理对象生存周期的 123456789// 下面写法不能编译通过struct Data &#123; NSMutableArray *arr;&#125;// 下面写法可以编译通过，要注意内存管理struct Data &#123; NSMutableArray __unsafe_unretained *arr;&#125; ARC有效时，id类型与void *类型互相转换需要__bridge转换 123id obj = [[NSObject alloc] init];void *p = (__bridge void *)obj;id p = (__bridge id)p; __bridge相关（无缝桥接） __bridge可以实现Objective-C与C语言变量 和 Objective-C与Core Foundation对象之间的互相转换，不会改变对象的持有状况，OC的对象仍然ARC管，引用计数不变，C的数据结构C管，手动释放。但是如果C对象转到OC对象，OC对象使用强引用接收，该对象的OC部分引用计数会+1 __bridge_retained用于将OC变量转换为C语言变量 或 将OC对象转换为Core Foundation对象，OC部分引用计数不变，C部分引用计数多1，ARC仍然管理该对象在OC部分的引用计数，在C部分的“引用计数”手动管 __bridge_transfer用于将C语言变量转换为OC变量 或 将Core Foundation对象转换为OC对象，OC部分引用计数多1，C部分引用计数少1，ARC仍然管理该对象在OC部分的引用计数，在C部分的“引用计数”手动管 传统静态数组使用：正常用，没区别 声明：id objs[10] 使用：array[0] = [[NSObject alloc] init];... 数组内对象自动释放 传统动态数组使用： 声明时用指针且手动初始化nil：id __strong *array = nil;、NSObject * __strong *array = nil;。 分配entries个内存块且初始化为0：array = (id __strong *)calloc(entries, sizeof(id));或malloc函数分配+memset置0 使用：array[0] = [[NSObject alloc] init];... 手动释放所有元素与数组本身：for(NSUInteger i = 0; i &lt; entries; i++) &#123; array[i] = nil; &#125; free(array); 注意：禁止使用memcpy和realloc，可能造成对象重复废弃等问题 2.2 Blocks模式 block声明：^ 返回值类型 (参数列表) {表达式}，其中返回值类型、参数列表可省略 返回值类型一定可省略，省略时根据表达式块内return表达式返回的类型自动确定返回值类型，没有return时返回值类型为void，多个return时return返回的类型必须相同。不省略时返回值类型需要与表达式块内return表达式返回的类型相容 参数列表在表达式块内不需要时可以省略 123^void (void) &#123; printf(&quot;Blocks\\n&quot;); &#125;// 可省略为^&#123; printf(&quot;Blocks\\n&quot;); &#125; block作为函数参数与返回值 123456789101112131415161718192021222324// ①void func(int (^blk)(int)) &#123; ...&#125;// ②int (^func()(int)) &#123;// block类型包在函数名与函数形参列表两侧，函数返回值位置写block类型返回值，// 函数名前写插入记号^，函数参数列表后写block类型的小括号包起的参数列表，// 最后用小括号从插入记号前包到block类型的参数列表后 return ^(int count) &#123; return count + 1; &#125;;&#125;typedef int (^blk_t)(int);// typedef后简化为// ①void func(blk_t blk) &#123; ...&#125;// ②blk_t func() &#123; return ^(int count) &#123; return count + 1; &#125;;&#125; block可以直接用也可以赋给指针来用 12345typedef int (^blk_t)(int);blk_t blk = ^(int count) &#123; return count + 1; &#125;;blk(10); // 直接用blockblk_t *blkptr = &amp;blk;(*blkptr)(10); // 指针用block block捕获自动变量（局部变量）的注意事项 block声明时直接捕获其内部所需变量的瞬时值 12345int val = 0;void (^blk)(void) = ^&#123; printf(&quot;val = %d&quot;, val);&#125;;val = 1;blk();// 打印 val = 0 block内修改所捕获的变量时要加__block修饰符，或者自动变量改为静态/全局变量 1234__block int val = 0;void (^blk)(void) = ^&#123; val = 1; printf(&quot;val = %d&quot;, val); &#125;;blk();// 编译通过，打印 val = 1 block调用OC变量的方法不会编译错误，编译错误只会发生在对没加__block修饰符的变量进行赋值（修改）的情况 123456789101112131415161718NSMutableArray array = [[NSMutableArray alloc] init];void (^blk)(void) = ^&#123; id obj = [[NSObject alloc] init]; [array addObject:obj];&#125;;// 编译通过NSMutableArray array = [[NSMutableArray alloc] init];void (^blk)(void) = ^&#123; array = [[NSMutableArray alloc] init];&#125;;// 编译失败__block NSMutableArray array = [[NSMutableArray alloc] init];void (^blk)(void) = ^&#123; array = [[NSMutableArray alloc] init];&#125;;// 编译通过 block没法对C语言数组进行捕获，可使用指针解决 1234567891011const char text[] = &quot;hello&quot;;void (^blk)(void) = ^&#123; printf(&quot;%c\\n&quot;, text[2]);&#125;;// 编译失败const char *text = &quot;hello&quot;;void (^blk)(void) = ^&#123; printf(&quot;%c\\n&quot;, text[2]);&#125;;// 编译通过 2.3 Blocks的实现2.3.1 Block的实质 2.3.2 截获自动变量值 -&gt;（基本类型变量、静态/全局变量） block实例的转换与解释 1234567891011121314151617181920// 源代码 test.m，捕获自动变量、捕获全局变量int global_val = 1;static int static_global_val = 2;int main() &#123; static int static_val = 3; int dmy = 256; int val = 10; const char *fmt = &quot;val = %d\\n&quot;; int (^blk)(int) = ^(int count) &#123; global_val *= 1; static_global_val *= 2; static_val *= 3; printf(fmt, val); return count; &#125;; blk(42); return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081//--------------转换后的源代码 test.cpp----------------int global_val = 1;static int static_global_val = 2;// 通用block信息结构体struct __block_impl &#123; void *isa; int Flags; //标志 int Reserved; //今后版本升级所需区域 void *FuncPtr; //函数指针&#125;;// 具体对应block的实现struct __main_block_impl_0 &#123; //含有通用信息结构体指针、对应block描述信息结构体指针、捕获的自动变量 struct __block_impl impl; struct __main_block_desc_0 *Desc; int *static_val; const char *fmt; int val; //构造函数 __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int *_static_val, const char *_fmt, int _val, int flags = 0) : static_val(_static_val), fmt(_fmt), val(_val)&#123; impl.isa = &amp;_NSConcreteStackBlock; //所以是一个OC的_NSConcreteStackBlock类的实例 impl.Flags = flags; impl.FuncPtr = fp; //对应block内容转换成的C函数指针赋值 //没赋值所以impl.Reserved = 0 Desc = desc; &#125;&#125;;// 对应block内容转换成C函数static int __main_block_func_0(struct __main_block_impl_0 *__cself, int count) &#123;// __cself相当于C++的this，或者OC的self，指向转换后的对应block实现 // （局部）静态变量使用指针承接 int *static_val = __cself-&gt;static_val; // 局部变量按传进来的值使用 const char *fmt = __cself-&gt;fmt; int val = __cself-&gt;val; // 全局变量访问方式不变 global_val *= 1; static_global_val *= 2; (*static_val) *= 3; //（局部）静态变量使用指针访问 printf(fmt, val); return count;&#125;// 对应block描述信息结构体，声明结构体+定义初始化一个实例static struct __main_block_desc_0 &#123; unsigned long reserved; //今后版本升级所需区域 unsigned long Block_size; //转换后对应block实现的大小&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;int main() &#123; static int static_val = 3; int dmy = 256; int val = 10; const char *fmt = &quot;val = %d\\n&quot;; //使用外面__main_block_func_0（block转换出来的函数）、__main_block_desc_0_DATA（对应block描述信息）、自动变量， //调用构造函数生成一个__main_block_impl_0结构体实例，赋值到int (*)(int)类型的blk //就是结构体的地址转成了函数指针 int (*blk)(int) = ((int (*)(int))&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, &amp;static_val, fmt, val, 0x22000000)); //blk转为__block_impl类型找到FuncPtr，将FuncPtr指针转为int (*)(__block_impl *, int)类型的函数指针， //再将blk转为__block_impl类型作为实参传进去，进行函数调用。对应源代码blk(42); //FuncPtr使用(void *)__main_block_func_0赋值，__main_block_func_0第一形参应为__main_block_impl_0类型， //但是传进一个(__block_impl *)blk实参，由于C里结构体指针间可以随意转换，__main_block_impl_0的第一个成员就是__block_impl结构体， //所以(__block_impl *)blk是可以转为(__main_block_impl_0 *)并找到里面存的自动变量比如__cself-&gt;fmt的 //个人推测转成__block_impl类型是因为这个是个基本结构体，每个block第一个成员就是，方便转换统一的代码 ((int (*)(__block_impl *, int))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk, 42); return 0;&#125; 根据上述代码，block不支持修改所捕获的变量的原因为：不符合程序员所想要的实现（block内改了实际上没反映到外部变量上） 根据上述代码，block不能捕获数组的原因为 123456789char a[10] = &#123;2&#125;;void (^blk)(void) = ^&#123; a[0] = 0; &#125;;// 假如编译通过，生成的代码为static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123; int a[10] = __cself-&gt;a; //C语言不允许[]数组相互赋值，因为a是数组名，代表数组地址，是个常量 a[0] = 0;&#125;// 所以编译不通过 2.3.3 __block说明符 -&gt;（__block基本类型变量）123456789101112// 源代码 test.m，捕获带__block修饰符的自动变量int main() &#123; __block int mutval = 10; __block int mutval2 = 2; void (^blk)(void) = ^&#123; mutval = 1; mutval2 = 42; &#125;; blk(); return 0;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697//--------------(带__block修饰符的自动变量)转换后的源代码 test.cpp----------------// 通用block信息结构体struct __block_impl &#123; void *isa; int Flags; //标志 int Reserved; //今后版本升级所需区域 void *FuncPtr; //函数指针&#125;;// 具体对应__block变量信息结构体，在__main_block_impl_0外面是为了可以在不同block中使用__block变量struct __Block_byref_mutval_0 &#123; void *__isa; __Block_byref_mutval_0 *__forwarding; //为什么有这个在下面解释 int __flags; int __size; int mutval; //承载原变量值的成员&#125;struct __Block_byref_mutval2_1 &#123; void *__isa; __Block_byref_mutval2_1 *__forwarding; int __flags; int __size; int mutval2;&#125;;// 具体对应block的实现struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; __Block_byref_mutval_0 *mutval; __Block_byref_mutval2_1 *mutval2; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_mutval_0 *_mutval, __Block_byref_mutval2_1 *_mutval2, int flags=0) : mutval(_mutval-&gt;__forwarding), mutval2(_mutval2-&gt;__forwarding) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;;// 对应block内容转换成C函数static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123; __Block_byref_mutval_0 *mutval = __cself-&gt;mutval; __Block_byref_mutval2_1 *mutval2 = __cself-&gt;mutval2; (mutval-&gt;__forwarding-&gt;mutval) = 1; //为什么使用__forwarding在下面解释 (mutval2-&gt;__forwarding-&gt;mutval2) = 42;&#125;static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123; // BLOCK_FIELD_IS_BYREF表示对__block变量进行内存管理 _Block_object_assign((void*)&amp;dst-&gt;mutval, (void*)src-&gt;mutval, 8/*BLOCK_FIELD_IS_BYREF*/); _Block_object_assign((void*)&amp;dst-&gt;mutval2, (void*)src-&gt;mutval2, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123; _Block_object_dispose((void*)src-&gt;mutval, 8/*BLOCK_FIELD_IS_BYREF*/); _Block_object_dispose((void*)src-&gt;mutval2, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;// 对应block描述信息结构体，声明结构体+定义初始化一个实例static struct __main_block_desc_0 &#123; unsigned long reserved; unsigned long Block_size; void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*); void (*dispose)(struct __main_block_impl_0*);&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;int main() &#123; __attribute__((__blocks__(byref))) __Block_byref_mutval_0 mutval = &#123; (void*)0, (__Block_byref_mutval_0 *)&amp;mutval, 0, sizeof(__Block_byref_mutval_0), 10 &#125;; __attribute__((__blocks__(byref))) __Block_byref_mutval2_1 mutval2 = &#123; (void*)0, (__Block_byref_mutval2_1 *)&amp;mutval2, 0, sizeof(__Block_byref_mutval2_1), 2 &#125;; void (*blk)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_mutval_0 *)&amp;mutval, (__Block_byref_mutval2_1 *)&amp;mutval2, 0x22000000)); ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk); return 0;&#125; 2.3.4 Block存储域 block种类与存储位置：block在全局变量位置声明的、block中不使用（捕获）自动变量这两种情况下，block是_NSConcreteGlobalBlock类型；对block发送copy消息创建的block是_NSConcreteMallocBlock类型 block所属类 存储位置 调用copy方法的效果 _NSConcreteStackBlock 栈 从栈复制到堆 _NSConcreteGlobalBlock 程序数据区 无效果 _NSConcreteMallocBlock 堆 增加引用计数 ARC有效时，函数返回一个block时，（函数内在栈上创建block，且没有手动拷贝到堆上）编译器会自动返回一个拷贝到堆上的block ARC有效时，传一个block给函数使用时，需要看函数的实现有没有适当复制该block。Cocoa框架内带usingBlock的方法、GCD的API这两种情况不需要手动复制。其他看情况要复制到堆上给函数或者海曙内自己复制到堆上 注：私下测试中，block中不使用（捕获）自动变量时，还是_NSConcreteStackBlock（Apple clang version 13.1.6 (clang-1316.0.21.2.5)，API Objective-C 2.0） 2.3.5 __block变量存储域 __block修饰的变量，对block发送copy消息复制到堆上时，block本身与用到的__block变量一块被复制到堆上。在block从栈复制到堆上时， 原来__block修饰的变量在栈上，则现在复制到堆上并被复制到堆上的block持有 原来__block修饰的变量在堆上，则现在直接被复制到堆上的block持有 如果__block修饰的变量被多个block引用，第一次随block被复制到堆上时__block修饰的变量发生复制并被block持有，其他block也复制到堆上时__block修饰的变量只改引用计数 堆上使用的__block修饰的变量声明周期与正常相同，block不使用它了，就被释放（引用计数-1），没有block使用它（引用计数=0）就被废弃 __block修饰的变量转化成的结构体中 __forwarding初始化时，是用自己的地址赋值（指向栈上结构体自己） 复制到堆上后，栈上和堆上的__forwarding都更新为堆上结构体地址（指向堆上的结构体） 所以在转化后对这种变量使用时都使用__forwarding来找到正确的同一个变量（大概是有堆上都能找到堆上，没堆上就找到栈上？），在非block内对__block修饰的变量的修改就对应修改了堆上那个结构体。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; __Block_byref_mutval_0 *mutval; __Block_byref_mutval2_1 *mutval2; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_mutval_0 *_mutval, __Block_byref_mutval2_1 *_mutval2, int flags=0) : mutval(_mutval-&gt;__forwarding), mutval2(_mutval2-&gt;__forwarding) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;;static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123; __Block_byref_mutval_0 *mutval = __cself-&gt;mutval; __Block_byref_mutval2_1 *mutval2 = __cself-&gt;mutval2; (mutval-&gt;__forwarding-&gt;mutval) = 1; (mutval2-&gt;__forwarding-&gt;mutval2) = 42;&#125;int main() &#123; __attribute__((__blocks__(byref))) __Block_byref_mutval_0 mutval = &#123; //... (__Block_byref_mutval_0 *)&amp;mutval, //... &#125;; __attribute__((__blocks__(byref))) __Block_byref_mutval2_1 mutval2 = &#123; //... (__Block_byref_mutval2_1 *)&amp;mutval2, //... &#125;; void (*blk)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_mutval_0 *)&amp;mutval, (__Block_byref_mutval2_1 *)&amp;mutval2, 0x22000000)); ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk); // FuncPtr即__main_block_func_0，传入上面初始化的blk为实参。blk里用(__Block_byref_mutval_0 *)&amp;mutval初始化__main_block_impl_0构造函数 // 的 __Block_byref_mutval_0 *_mutval 形参，取其中的__forwarding给__Block_byref_mutval_0 *mutval成员赋值， // 所以是栈上的结构体的地址。所以__main_block_func_0里变量mutval = __cself-&gt;mutval指向栈的结构体。 // block拷贝到堆之后，栈上结构体里面__forwarding会变为堆上__forwarding地址，mutval是栈上结构体变量， // mutval-&gt;__forwarding找到堆上结构体，mutval-&gt;__forwarding-&gt;mutval找到堆上结构体内承载原变量值的成员 return 0;&#125; 2.3.6 截获对象 2.3.7 __block变量和对象 -&gt;（对象、__block对象）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130// 源代码 test.m，捕获自动变量arraytypedef void (^blk_t)(id);int main(void) &#123; blk_t blk; __block NSObject *nsobj = [[NSObject alloc] init]; &#123; id array = [[NSMutableArray alloc] init]; blk = [^(id obj) &#123; [array addObject:obj]; NSLog(@&quot;array count = %ld&quot;, [array count]); nsobj = [[NSObject alloc] init]; &#125; copy]; &#125; blk([[NSObject alloc] init]); blk([[NSObject alloc] init]); blk([[NSObject alloc] init]); return 0;&#125;//--------------转换后的源代码 test.cpp----------------// 部分简化为OC用法// 通用block信息结构体struct __block_impl &#123; void *isa; int Flags; //标志 int Reserved; //今后版本升级所需区域 void *FuncPtr; //函数指针&#125;;// 通用 block捕获的__block对象 的拷贝与释放函数static void __Block_byref_id_object_copy_131(void *dst, void *src) &#123; _Block_object_assign((char*)dst + 40, *(void * *) ((char*)src + 40), 131);&#125;static void __Block_byref_id_object_dispose_131(void *src) &#123; _Block_object_dispose(*(void * *) ((char*)src + 40), 131);&#125;typedef void (*blk_t)(id);struct __Block_byref_nsobj_0 &#123; void *__isa; __Block_byref_nsobj_0 *__forwarding; int __flags; int __size; // 对象型__block变量专有拷贝与释放函数 void (*__Block_byref_id_object_copy)(void*, void*); void (*__Block_byref_id_object_dispose)(void*); NSObject *__strong nsobj;&#125;;struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; // 前面说ARC下C结构体内不能有__strong的OC对象，而这里运行时库明确了复制到堆上和废弃的时机， // 所以这个对象可以存在。但是需要__main_block_desc_0增加copy和dispose函数来管理 __strong id array; __Block_byref_nsobj_0 *nsobj; // by ref __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __strong id _array, __Block_byref_nsobj_0 *_nsobj, int flags=0) : array(_array), nsobj(_nsobj-&gt;__forwarding) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;;static void __main_block_func_0(struct __main_block_impl_0 *__cself, __strong id obj) &#123; __Block_byref_nsobj_0 *nsobj = __cself-&gt;nsobj; // bound by ref __strong id array = __cself-&gt;array; // bound by copy // 简化为OC [array addObject:obj]; NSLog(@&quot;array count = %ld&quot;, [array count]); (nsobj-&gt;__forwarding-&gt;nsobj) = [[NSObject alloc] init];&#125;static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123; // 对象赋值，相当于retain // BLOCK_FIELD_IS_OBJECT表示对OC对象进行内存管理 _Block_object_assign((void*)&amp;dst-&gt;array, (void*)src-&gt;array, 3/*BLOCK_FIELD_IS_OBJECT*/); // BLOCK_FIELD_IS_BYREF表示对__block变量进行内存管理 _Block_object_assign((void*)&amp;dst-&gt;nsobj, (void*)src-&gt;nsobj, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123; // 对象释放，相当于release _Block_object_dispose((void*)src-&gt;array, 3/*BLOCK_FIELD_IS_OBJECT*/); _Block_object_dispose((void*)src-&gt;nsobj, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;static struct __main_block_desc_0 &#123; size_t reserved; size_t Block_size; void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*); void (*dispose)(struct __main_block_impl_0*);&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;// 部分简化为OCint main(void) &#123; blk_t blk; __attribute__((__blocks__(byref))) __Block_byref_obj_0 obj = &#123; (void*)0, (__Block_byref_obj_0 *)&amp;obj, 0x2000000, sizeof(__Block_byref_obj_0), __Block_byref_id_object_copy_131, __Block_byref_id_object_dispose_131, [[NSObject alloc] init]; &#125;; &#123; id array = [[NSMutableArray alloc] init]; blk = ((void (*)(__strong id))&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, array, (__Block_byref_nsobj_0 *)&amp;nsobj, 0x22000000)); blk = [blk copy]; &#125; ((void (*)(__block_impl *, __strong id))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk, [[NSObject alloc] init]); ((void (*)(__block_impl *, __strong id))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk, [[NSObject alloc] init]); ((void (*)(__block_impl *, __strong id))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk, [[NSObject alloc] init]); return 0;&#125; __main_block_copy_0/__main_block_dispose_0或者__main_block_desc_0.copy/dispose这些在block复制到堆上以及堆上block被废弃时自动调用，复制时机： block调copy方法时 block作为函数返回值被返回时 block赋值给某类的__strong id成员变量或者对应类型的成员变量时 作为实参传给Cocoa框架内带usingBlock的方法、GCD的API时 以上的后三种情况之外，在block中使用自动变量时，推荐调用copy方法将block从栈复制到堆上，避免使用的自动变量超作用域销毁，而废弃掉自动变量所指的对象 如果捕获的是__weak变量，结构体仍然生成，但是不管带不带__block，只要__weak引用的对象被销毁了，__weak变量都变成nil 如果捕获的是__unsafe_unretained变量，结构体仍然生成，但是不管带不带__block，编译器不会做多余处理（像是__weak变量的赋nil） __autoreleasing修饰符与block连用没有规定，不要用，甚至__autoreleasing修饰符与__block连用会编译失败 2.3.8 block循环引用1234567891011121314151617181920212223242526typedef void (^blk_t)(void);@interface MyObj : NSObject&#123; blk_t _blk;&#125;@end@implementation MyObj- (id)init &#123; self = [super init]; if (self) &#123; _blk = ^&#123; NSLog(@&quot;self = %@&quot;, self); &#125;; &#125; return self;&#125;- (void)dealloc &#123; NSLog(@&quot;dealloc&quot;);&#125;@endint main () &#123; id o = [[MyObj alloc] init]; NSLog(@&quot;%@&quot;, o); return 0;&#125; 上述代码块中，o持有_blk，由于块出括号就要销毁，所以块复制到堆上并且赋给_blk，同时块持有self，于是出现循环引用 下面也同样是循环引用，因为成员变量用的时候也是通过对象来找成员变量，也是捕获了self 1234567891011121314151617181920@interface MyObj : NSObject&#123; blk_t _blk; id _obj;&#125;@end@implementation MyObj- (id)init &#123; self = [super init]; if (self) &#123; // 实际上等于 NSLog(@&quot;_obj = %@&quot;, self-&gt;_obj); _blk = ^&#123; NSLog(@&quot;_obj = %@&quot;, _obj); &#125;; &#125; return self;&#125;- (void)dealloc &#123; NSLog(@&quot;dealloc&quot;);&#125;@end 解决方法如下， 使用__weak变量（此时应为对象持有的块，块中的tmp必定指向对象，所以不用判断nil） 12345if (self) &#123; // 以前没有__weak的时候，此处也可以用__unsafe_unretained id __weak tmp = self; _blk = ^&#123; NSLog(@&quot;self = %@&quot;, tmp); &#125;&#125; 使用__block变量，但是需要额外调用执行 12345678910111213141516171819202122232425262728@implementation MyObj- (id)init &#123; self = [super init]; if (self) &#123; __block id tmp = self; _blk = ^&#123; NSLog(@&quot;self = %@&quot;, tmp); // 置空操作，减少tmp带来的引用计数 tmp = nil; &#125;; &#125; return self;&#125;- (void)execBlock &#123; _blk();&#125;- (void)dealloc &#123; NSLog(@&quot;dealloc&quot;);&#125;@endint main () &#123; id o = [[MyObj alloc] init]; NSLog(@&quot;%@&quot;, o); // 必须调用execBlock方法执行一下块的代码，否则会循环引用内存泄漏（tmp没有取消对self的引用） [o execBlock]; return 0;&#125; 上述__block变量方法优点为：可自由控制对象持有时间，不必在不能使用__weak时使用__unsafe_unretained修饰符。缺点为：必须执行block内的代码，如果任何情况下都不执行则仍然会造成内存泄漏 2.3.9 copy/release ARC无效时 对栈上block调copy方法来复制并持有（retain无用），对堆上block调用retain/copy方法来持有，对堆上block调用release方法来释放 上述copy可换为Block_copy()的C函数，release可换为Block_release()的C函数 注意：使用__block来避免循环引用：__block修饰的对象类型自动变量不会被块retain，不被__block修饰的对象类型自动变量却会被块retain（此时__block相当于ARC下的__unsafe_unretained） 3.2 GCD的API3.2.1 Dispatch Queue Dispatch Queue（派发队列）有两种：Serial Dispatch Queue（串行派发队列），FIFO，使用一个线程，执行完一个任务再派发下一个任务进去执行；Concurrent Dispatch Queue（并发派发队列），FIFO，使用多个线程，不用等前一个任务执行完就可以派发下一个任务去执行，但是同时执行的任务数量取决于当前系统状态 派发队列获取方式有两种，3.2.2直接创建和3.2.3获取系统提供的 3.2.2 dispatch_queue_create dispatch_queue_create生成的派发队列个数是无上限的 生成串行派发队列时注意，一个队列对应使用一个线程（所以不同任务指派到不同串行派发队列上实际会形成并行效果），但如果生成太多队列会消耗大量内存，引起大量上下文切换，降低系统响应 所以应在解决多线程更新同一个资源导致数据竞争时使用串行派发队列（不同线程对同一个资源的更新操作放在同一个串行派发队列中） 生成并发派发队列时，虽然也可以生成无限多个，但是系统内核只使用有效管理的线程，不会发生串行派发队列的问题 dispatch_queue_create创建队列，参数一为队列名，可以为NULL，但是建议按照逆序域名方式命名（如com.example.gcd.mySerialQueue），因为该名称会出现在调试器中以及崩溃日志中表示为相应队列名称；参数二为队列特征，一般只有下面三种填法 123456// 创建串行派发队列dispatch_queue_t serialQueue = dispatch_queue_create(&quot;mySerialQueue&quot;, NULL);dispatch_queue_t serialQueue = dispatch_queue_create(&quot;mySerialQueue&quot;, DISPATCH_QUEUE_SERIAL);// 创建并发派发队列dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;myConcurrentQueue&quot;, DISPATCH_QUEUE_CONCURRENT); 非ARC下，需要通过dispatch_release()释放，通过dispatch_retain()持有 即使生成的队列在 block通过dispatch_async()派发到这个队列上 后立刻dispatch_release()释放，也不会有问题，因为block会dispatch_retain()来持有这个队列，block执行结束后dispatch_release()释放队列，队列才被废弃 3.2.3 Main Dispatch Queue/Global Dispatch Queue Main Dispatch Queue（主队列）将任务派发到主线程，属于串行派发队列 Global Dispatch Queue（全局并发队列）将任务派发到系统创建的多个其他线程，属于并发派发队列，但是并不保证执行任务的实时性 全局派发队列优先级有四种 12345678// 获取主队列dispatch_queue_t mainDispatchQueue = dispatch_get_main_queue();// 获取全局并发队列：高优先级、默认优先级、低优先级、后台优先级dispatch_queue_t globalDispatchQueueHigh = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0);dispatch_queue_t globalDispatchQueueDefault = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);dispatch_queue_t globalDispatchQueueLow = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0);dispatch_queue_t globalDispatchQueueBackground = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0); 非ARC中，对主队列和全局并发队列执行dispatch_release()和dispatch_retain()无效，也不会产生影响 3.2.4 dispatch_set_target_queue 用处1：变更所创建队列的优先级 123456// 创建的串行或并发派发队列优先级与全局并发队列的默认优先级相同dispatch_queue_t serialQueue = dispatch_queue_create(&quot;mySerialQueue&quot;, NULL);dispatch_queue_t globalDispatchQueueBackground = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0);// 将参数一的派发队列优先级设定为参数二的全局并发队列的优先级（参数一不可传入主队列或者系统提供的全局并发队列）dispatch_set_target_queue(serialQueue, globalDispatchQueueBackground); 用处2：作成执行阶层 123456789101112dispatch_queue_t serialQueue = dispatch_queue_create(&quot;mySerialQueue&quot;, NULL);dispatch_queue_t myQueue1 = dispatch_queue_create(&quot;myQueue1&quot;, NULL);dispatch_queue_t myQueue2 = dispatch_queue_create(&quot;myQueue2&quot;, NULL);dispatch_queue_t myQueue3 = dispatch_queue_create(&quot;myQueue3&quot;, NULL);dispatch_set_target_queue(myQueue1, serialQueue);dispatch_set_target_queue(myQueue2, serialQueue);dispatch_set_target_queue(myQueue3, serialQueue);dispatch_async(myQueue1, ^&#123; NSLog(@&quot;Queue1&quot;); &#125;);dispatch_async(myQueue2, ^&#123; NSLog(@&quot;Queue2&quot;); &#125;);dispatch_async(myQueue3, ^&#123; NSLog(@&quot;Queue3&quot;); &#125;); 那么上述本来并行执行的myQueue1、myQueue2、myQueue3，在目标队列serialQueue（串行队列）上只能同步执行（如果serialQueue是个并发队列则并不会产生同步执行的效果），执行顺序按照哪个myQueue先被加入任务块，哪个myQueue先执行，执行完了才执行下一个queue内安排的任务（即使任务、dispatch_set_target_queue分布在不同的方法中） 如果都是并发queue加入目标串行队列，那么所有任务块严格按照加入先后串行执行，就像是任务块直接按顺序添加入目标串行队列 如果都串行和并发两种queue加入目标串行队列，那么第一个任务块加入哪个queue，哪个queue先执行，但是在目标串行队列上，并发queue的任务块执行顺序可以被串行queue打断，串行queue的任务块执行顺序无法被并发queue打断（某个串行queue所有任务整个插入并发queue的执行顺序中，插队） 但是目标队列毕竟也是队列，也可以往里添加任务，如果是myQueue（串行或并发queue）和目标serialQueue都安排了任务块，那么在任务块执行顺序表现上，第一个任务块加入哪个queue，哪个queue先执行，serialQueue表现与上述并发queue的表现相同 3.2.5 dispatch_after 在指定时间将任务块加入队列 1234// 生成参数一时间的参数二纳秒数后的时间dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, 3ull * NSEC_PER_SEC);// 参数一时间时用dispatch_async加入任务块dispatch_after(time, dispatch_get_main_queue(), ^&#123; NSLog(@&quot;3 seconds.&quot;); &#125;); dispatch_time()常用于生成相对时间，dispatch_time_t dispatch_walltime(const struct timespec *_Nullable when, int64_t delta);常用于生成绝对时间（参数一是timespec时间格式结构体） 3.2.6 Dispatch Group 等待派到不同队列（或者并发队列）的一组block执行完之后做些事情时使用 1234567891011dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);// 创建dispatch groupdispatch_group_t group = dispatch_group_create();// 添加到dispatch group及dispatch queuedispatch_group_async(group, queue, ^&#123; NSLog(@&quot;blk0&quot;); &#125;);dispatch_group_async(group, queue, ^&#123; NSLog(@&quot;blk1&quot;); &#125;);dispatch_group_async(group, queue, ^&#123; NSLog(@&quot;blk2&quot;); &#125;);// group内所有任务做完后执行dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123; NSLog(@&quot;Done.&quot;); &#125;); 如果仅仅想等待一组做完而不想再执行什么，dispatch_group_notify可换为 12345// 仅等待，但调用这个函数的线程会停止，一直在该函数中不会返回，直到到达等待的时间点。// 参数二为等待到什么时候，DISPATCH_TIME_FOREVER表示永久等待且中途无法取消，DISPATCH_TIME_NOW表示立即返回，// 或者类似3.2.5中生成一个时间点赋值在这// 可根据返回值进行分支判断，时间内一组任务成功全部做完则返回0，否则返回非0dispatch_group_wait(group, DISPATCH_TIME_FOREVER); 3.2.7 dispatch_barrier_async 并发队列中加一个与其他操作互斥的操作（比如写入）时使用 123456789dispatch_queue_t queue = dispatch_queue_create(&quot;com.example.gcd&quot;, DISPATCH_QUEUE_CONCURRENT);dispatch_async(queue, blk0_reading);dispatch_async(queue, blk1_reading);dispatch_async(queue, blk2_reading);dispatch_barrier_async(queue, blk_writing);// 此操作会前面操作并发后单独执行，执行完了后面操作再并发dispatch_async(queue, blk3_reading);dispatch_async(queue, blk4_reading);dispatch_async(queue, blk5_reading);dispatch_async(queue, blk6_reading); 3.2.8 dispatch_sync 用法简单，但是容易产生死锁 12345// 主线程中死锁：dispatch_queue_t queue = dispatch_get_main_queue();dispatch_sync(queue, ^&#123; NSLog(@&quot;Hello&quot;); &#125;);// 不仅是主线程，只要是dispatch_sync回调用该函数的线程都死锁，因为函数要等待块执行结束才能退出，// 而函数要执行完了才能给队列添加块（块要等待函数执行结束才能添加），所以死锁 3.2.9 dispatch_apply dispatch_sync执行完了才退出的特点和dispatch group执行一组任务特点相结合的API 12345678dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);// 参数一执行块的次数，参数二追加到的队列，参数三执行的block，block是带参数的，从0开始每次进来加一// 比如可以用于对数组中各个对象执行某个块dispatch_apply(10, queue, ^(size_t index) &#123; NSLog(@&quot;%zu&quot;, index);&#125;);// 上面函数添加的块都执行完了才退出，才能执行下面的代码NSLog(@&quot;done&quot;); 3.2.10 dispatch_suspend/dispatch_resume 对队列进行挂起、继续 1234// 挂起队列，已经执行完的就执行完了，没执行的就暂停执行dispatch_suspend(queue);// 挂起的队列恢复执行dispatch_resume(queue); 3.2.11 Dispatch Semaphore 信号量，用于比同步派发队列和dispatch_barrier_async更细粒度进行排他性处理的场景 等待的方式使用，等待信号量大于等于1时可安全操作 123456789101112// 形参表示给信号量初始化的值dispatch_semaphore_t semaphore = dispatch_semaphore_create(1);// 等待信号量变成大于等于1，并且给信号量减1，然后返回。此时进入排他性处理：我（们）开始处理了，下一个等等再来// 如果是forever，则等待到大于等于1时返回，返回值0// 如果是某特定时间点，则等待到大于等于1时返回值0，没等待到大于等于1时返回值非0dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);// 上述函数返回值0时安全处理（并不一定信号量为0）...// 处理完了给信号量用下列函数加一，表示已经处理完了，下一个可以不用等了dispatch_semaphore_signal(semaphore); 3.2.12 dispatch_once 绝对只执行一次的代码，多线程可保证百分百安全，单例模式 1234static dispatch_once_t pred;dispatch_once(&amp;pred, ^&#123; // ...只执行一次的代码&#125;); 3.2.13 Dispatch I/O 大文件分割成多个块使用多个线程并列读取，提升文件读取速度 12345678910111213// 创建一个dispatch io通道类型变量，参数一是io通道属性，实参二选一：DISPATCH_IO_STREAM流式读写，// DISPATCH_IO_RANDOM随机读写；参数二是文件描述符；参数三创建的dispatch queue；参数四是错误处理blockdispatch_io_t pipe_channel = dispatch_io_create(DISPATCH_IO_STREAM, fd, queue, ^(int error) &#123; // 错误处理&#125;)// 设置一次读取的大小dispatch_io_set_low_water(pipe_channel, SIZE_MAX);// 读数据dispatch_io_read(pipe_channel, 0, SIZE_MAX, queue, ^(bool done, dispatch_data_t _Nullable data, int error) &#123; // 读完的每一部分数据流在这做处理&#125;); 3.3 GCD实现 dispatch queue通过结构体和链表，实现为FIFO队列，FIFO队列管理的是追加到queue的block。但是block不是直接加到FIFO队列里，而是加入一个dispatch_continuation_t类型结构体（里面也存储着相应的执行上下文），结构体再加入FIFO队列 加入到dispatch queue的block执行时 libdispatch（提供dispatch queue的组件）取出block对应的dispatch_continuation_t结构体，调用pthread_workqueue_additem_up函数（由更底层的libc组件提供pthread API）并传递进去相关信息 pthread_workqueue_additem_up通知workqueue（由最底层XNU系统提供）增加要执行的项目 workqueue根据传进来的信息判断是否生成一个新的线程来处理项目，处理项目时执行pthread_workqueue函数，函数调用libdispatch的回调函数，回调函数执行block block执行完之后进行通知dispatch group结束、释放dispatch_continuation_t结构体等操作，然后准备执行下一个block Dispatch Source是XNU系统内核发生各种事件时的处理方法，可根据需要选择使用 Dispatch Source种类名称（目前） 事件内容 DISPATCH_SOURCE_TYPE_DATA_ADD 自定义事件，变量增加 DISPATCH_SOURCE_TYPE_DATA_OR 自定义事件，变量OR DISPATCH_SOURCE_TYPE_DATA_REPLACE 自定义事件，变量Replace DISPATCH_SOURCE_TYPE_MACH_SEND MACH端口发送 DISPATCH_SOURCE_TYPE_MACH_RECV MACH端口接收 DISPATCH_SOURCE_TYPE_MEMORYPRESSURE 内存报警 DISPATCH_SOURCE_TYPE_PROC 进程相关事件监听，如进程退出、创建子线程等 DISPATCH_SOURCE_TYPE_READ 可读取文件映像时响应 DISPATCH_SOURCE_TYPE_SIGNAL 接收到UNIX信号时响应 DISPATCH_SOURCE_TYPE_TIMER 定时器 DISPATCH_SOURCE_TYPE_VNODE 文件状态监听，如文件删除、移动、重命名等 DISPATCH_SOURCE_TYPE_WRITE 可写入文件映像时响应 12345678910111213141516171819202122232425// 创建一个dispatch source，此处以定时器为例，参数一为上列表格内种类常量，参数二为要监听的系统句柄，传入什么看source常量的说明// 参数三是描述细节信息，传入什么看source常量的说明，参数四是处理该事件的block执行在哪个线程上dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_main_queue());// 定时器特有，设置定时器触发时刻、下次开始定时的间隔时间、可允许的事件误差dispatch_source_set_timer(timer, dispatch_time(DISPATCH_TIME_NOW, 15ull * NSEC_PER_SEC), DISPATCH_TIME_FOREVER, 1ull * NSEC_PER_SEC);// dispatch source发生时的处理blockdispatch_source_set_event_handler(timer, ^&#123; NSLog(@&quot;wakeup&quot;); // 用完后必须取消并释放dispatch source，否则该dispatch source会一直活动 dispatch_source_cancel(timer); timer = NULL;&#125;);// 如果有需要在取消dispatch source时有自定义行为，则定义这个函数，比如进行内存、资源释放等dispatch_source_set_cancel_handler(timer, ^&#123; NSLog(@&quot;canceled&quot;);&#125;);// 开始执行dispatch source，如果是开始执行还可以使用dispatch_active()；dispatch_resume(timer);// 暂停dispatch source时也是使用dispatch_suspend()，但是次数要与dispatch_resume匹配","categories":[{"name":"学习","slug":"学习","permalink":"https://neko-horikawaraiko.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"https://neko-horikawaraiko.github.io/tags/Objective-C/"}]},{"title":"《Effective Objective-C 2.0 编写高质量iOS与OS X代码的52个有效方法（第二版）》笔记","slug":"《Effective Objective-C 2.0 编写高质量iOS与OS X代码的52个有效方法（第二版）》笔记","date":"2023-02-17T10:34:00.000Z","updated":"2024-10-21T16:28:22.125Z","comments":true,"path":"2023/02/17/《Effective Objective-C 2.0 编写高质量iOS与OS X代码的52个有效方法（第二版）》笔记/","link":"","permalink":"https://neko-horikawaraiko.github.io/2023/02/17/%E3%80%8AEffective%20Objective-C%202.0%20%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E4%B8%8EOS%20X%E4%BB%A3%E7%A0%81%E7%9A%8452%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89%E3%80%8B%E7%AC%94%E8%AE%B0/","excerpt":"","text":"1.了解Objective-C语言的起源 oc在运行期才会检查对象类型、查找要执行的方法 oc对象实例放在堆中，在int、char等非对象类型与指针一般放在栈中 2.在类的头文件中尽量少引入其他头文件 用到其他类时使用@class关键字前向声明 遵循协议无法使用前向声明，则在分类中声明遵循该协议@implementation ClassA ()&lt;Protocol&gt; 3.多用字面量语法，少用与之等价的方法 值@1 @2.5f @YES @&#39;a&#39; @(x*y) 不可变数组@[@&quot;cat&quot;, @&quot;dog]; 不可变字典@&#123;@&quot;FirstName&quot;:@&quot;Matt&quot;, @&quot;age&quot;:@28&#125;; 上述字面量语法创建的数值、数组、字典为不可变对象 用字面量创建这些数组、字典对象在遇到nil时会抛异常，而使用arrayWithObjects:之类的方法遇到nil会直接提前结束而不报异常 4.多用类型常量，少用#define预处理指令 static const NSTimeInterval kAnimationDuration = 0.3; 123456// 全局常量// &quot;XXX.h&quot;extern NSString *const EOCStringConstant; // 声明// &quot;XXX.m&quot;NSString *const EOCStringConstant = @&quot;VALUE&quot;; // 定义 常量名称：只在某“编译单元”（.m文件）中可用时前缀加k，整个项目都可用时以相关联的类名为前缀 加static保证只在本文件有用，不加则默认为变量创建外部符号，其他文件中同名变量会报错 在每个用到这个全局变量的.m都写extern，或者在.h文件中写了而.m包含该.h效果相同 5.用枚举表示状态、选项、状态码 实现枚举所用的数据类型取决于编译器 需要多个选项可用时，各选项的值定为2的幂次，以便通过按位或组合 用NS_ENUM或者NS_OPTIONS宏定义枚举类型时可指明所使用的底层数据类型 处理枚举类型的switch语句不写default分支，以便添加新枚举项时编译器提醒开发者未处理所有枚举 6.理解“属性”这一概念 用@property生成的实例变量，为在属性名前加前缀下划线 在类实现中使用@dynamic可禁止编译器对属性自动合成存取方法与实例变量，但是访问这些属性不会报警示 12345678@interface EOCPerson : NSManagerObject@property NSString *fistName;@property NSString *lastName;@end@implementation EOCPerson@dynamic firstName, lastName;@end atomic（默认）、nonatomic：是否原子性 readwrite（默认）、readonly：外部读写性。可以对外公开为只读，而在分类中重新定义为读写（第27条） assign对简单值类型赋值；strong“拥有”，保留新值，释放旧值，再把新值设置上去；weak“非拥有”，不保留新值，不释放旧值，所指对象销毁时该属性清空；unsafe_unretained对对象类型的assign，“非拥有”，所指对象销毁时属性值不清空；copy深拷贝 getter=&lt;name&gt;name换为方法名，重设属性的获取方法名；setter=&lt;name&gt;name换为方法名，重设属性的设置方法名，不常见 注意自己实现相应存取方法时要对应所声明的特质，比如声明特质有copy，自定设置方法中就要深拷贝相关对象 即使不是存取方法，比如是初始化方法，也要遵循上述规则。这个特殊情况存在就是因为不应在初始化方法、销毁方法中调用存取方法（第7条） iOS开发中属性基本全部为nonatomic，因为并不能保证线程安全（iOS机制决定？）而且会严重增加性能消耗 7.在对象内部尽量直接访问实例变量 对象内部读取数据使用实例变量，写入数据使用属性 特例：初始化方法与dealloc方法使用实例变量读写数据（子类可能会重写设置方法）。特例的特例：带初始化的实例变量在超类且无法直接访问到，只能使用设置方法 特例：惰性初始化的数据使用属性读取数据 8.理解“对象等同性”这一概念 检测自定义对象等同性需要实现isEqual:方法和hash方法，相同对象的hash码必须相同 根据需要对所需属性进行检测以判断对象是否相同，不要盲目全部判断 hash算法要尽量计算速度快且哈希碰撞率低 9.以“类族模式”隐藏实现细节 类族模式把实现细节隐藏在公共接口后面，如UIButton类的+ (UIButton*)buttonWithType:(UIButtonType)type;方法，通过工厂模式创建具体的button类型 从类族的公共抽象基类继承出子类时需要阅读开发文档，明确数据存储方式、需要重写的方法等细节 10.在既有类中使用关联对象存放自定义数据 最好，当自己需要实现某一子类来存放相关信息，却无法使用超类的机制创建自定子类实例时，可以使用“关联对象”存放信息。因为这种做法会引入引用环等bug “关联对象”指定的内存管理语义和属性定义时的内存管理语义相似 设置方式：void objc_setAssociatedObject(id object, void* key, id value, objc_AssociationPolicy policy)以给定的policy（内存管理语义），给object的key设定相应value。通常使用静态全局变量做key。（类比NSDictionary，但是NSDictionary对key相等内部实现是判断isEqual:，而关联对象的key相等内部判断是需要指针相等，因此使用静态全局变量做key） 11.理解objc_msgSend的作用 向对象发送消息相当于在该对象上调用objc_msgSend()方法并传递参数进去 12.理解消息转发机制 完整过程（两大阶段） 动态方法解析：问接收者能否动态添加方法来处理传来的“未知的selector” 完整的消息转发机制：上一阶段无法动态添加时 问接收者看看有没有其他对象可以处理这条消息，若有则转给那个对象（备援接收者，replacement receiver） 若没有，系统则将消息全部细节封装到NSInvocation对象中，让接收者设法处理 动态方法解析：对象无法解读消息，调用自己类的+(BOOL)resolveInstanceMethod:(SEL)selector或者+(BOOL)resolveClassMethod:(SEL)selector判断能不能添加方法处理selector。需要相关代码已经写好，在需要时直接插到类中就可以的那种情况，常用来实现@dynamic属性。举例： 123456789101112131415id autoDictionatyGetter(id self, SEL _cmd);void autoDictionarySetter(id self, SEL _cmd, id value);+ (BOOL)resolveInstanceMethod:(SEL selector) &#123; NSString *selectorString = NSStringFromSelector(selector); if (/* selector is from a @dynamic property */) &#123; if ([selectorString hasPrefix:@&quot;set&quot;]) &#123; Class_addMethod(self, selector, (IMP)autoDictionarySetter, &quot;v@:@&quot;); &#125; else &#123; Class_addMethod(self, selector, (IMP)autoDictionaryGetter, &quot;@@:&quot;); &#125; return YES; &#125; return [super resolveInstanceMethod:selector];&#125; 备援接收者：对象可以通过+(id)forwardingTargetForSelector:(SEL)selector返回可以处理该消息（selector）的对象，比如对象将可以处理消息的子对象返回 完整的消息转发：创建NSInvocation对象，将selector、目标（target）、参数等所有细节包含其中。消息派发系统（message-dispatch system）将该消息对象指派给目标对象。对象可以通过调用-(void)forwardInvocation:(NSInvocation*)invocation改变调用目标，将消息转给新对象。这种方式与备援接受者方式相同，故常常当需要改变消息内容（追加参数、改变selector等）时才会进行方法实现。并且若发现某操作不应由本类处理，则需调用超类同名方法。 13.用“方法调配技术”调试“黑盒方法” 使用另一份实现替换原有的方法实现，称为“方法调配”。一般只在调试程序时候才用此技术，向“完全不知道具体实现”的黑盒方法的原有实现中添加新功能，比如增加日志记录功能。该种方法不宜滥用。 在选择子映射表（selector table）中，每个选择子（selector）名称映射一个方法实现，在表中以IMP类型函数指针表示。“方法调配”技术就是通过调用特定方法操作该表实现的。 举例 123Method originalMethod = class_getInstanceMethod([NSString class],@selector(lowercaseString));Method swappedMethod = class_getInstanceMethod([NSString class],@selector(uppercaseString));method_exchangeImplementations(originalMethod, swappedMethod); 14.理解“类对象”的用意 编译器会假定id类型的对象可以响应所有消息 123456789101112131415161718192021222324252627282930313233343536373839404142434445// class为objc_class *类型的结构体typedef struct objc_class *Class;// objc-private.hstruct objc_object &#123; isa_t isa;&#125;// objc-runtime-new.hstruct objc_class : objc_object &#123; ...... // 包含Class ISA; Class superclass; cache_t cache; // 方法缓存 class_data_bits_t bits; // &amp; FAST_DATA_MASK之后，在class_rw_t *中获取类的具体信息 ......&#125;struct class_rw_t &#123; uint32_t flags; uint32_t version; const class_ro_t *ro; method list t * methods; // 方法列表 property_list_t *properties; // 属性列表 const protocol _list_t * protocols; // 协议列表 Class firstSubclass: Class nextSiblingClass; char *demangledName;&#125;struct class_ro_t &#123; uint32_t flags; uint32_t instanceStart; uint32_t instanceSize; // instance对象占用的内存空间#ifdef __LP64__ uint32_t reserved;#endif const uint8_t * ivarLayout; const char *name; // 类名 method_list_t * basevethodList; protocol_list_t * baseProtocols; const ivar_list_t * ivars; // 成员变量列表 const_uint8_t * weakIvarLayout; property_list_t *baseProperties;&#125; 每个继承自NSObject根类（根类：NSObject、NSProxy）的对象最终都会包含一个objc_object结构体，即首个成员都是一个Class类型的isa指针。此处“对象”包含实例对象、类对象、元类对象。[obj class]与object_getClass(obj);可以获取到类对象，object_getClass([ClassName class]);可以获取到元类对象。某个类的类对象和元类对象在内存中都只有一个。 实例对象结构：isa指针（指向类对象）、成员变量（花括号声明的+属性生成的）的值。 类对象结构：isa指针（指向元类对象）、super_class指针（指向父类对象，根类NSObject类对象的此指针指向nil）、属性（property声明的那些）的信息、对象方法（-开头的方法）的信息、协议的信息、成员变量的信息（比如变量类型、变量名等）等（类对象中也是存这些信息的结构体指针，指向外部结构体，实际信息存在外部结构体中）。不包含父类的属性、成员变量、方法等 元类对象结构：isa指针（指向NSObject的元类对象）、super_class指针（指向父类的元类对象，根类NSObject元类对象的此指针指向NSObject类对象）、类方法（+开头的方法）的信息等 ) 查询类型信息（判断是否为某个类实例）： isMemberOfClass:判断对象是否为某类的实例 isKindOfClass:判断对象是否为某类及其派生类的实例 [object class] == [ClassName class]判断对象是否为某类实例（对象的-(Class)class实例方法和类的+(Class)class类方法都是返回类对象，此处判断类对象是否为同一个）。但是最好不用这种方法，因为可能object是代理对象，class方法返回来的是NSProxy为根类的子类。 15.用前缀避免命名空间冲突 类的实现文件中所用的C函数及全局变量属于“顶级符号”（top-level symbol），容易与其他文件比如库的使用者的代码中出现命名冲突，需要加上前缀避免冲突 16.提供“全能初始化方法”（“指定初始化方法”） 一个类多个初始化方法中，需要在文档指明哪一个是全能初始化方法，其他初始化方法使用默认值调用全能初始化方法，或者在不应调用其他初始化方法时抛出异常（不常用） 子类的全能初始化方法与父类不同时，从父类继承而来的那个全能初始化方法应被复写（其中再调用子类的全能初始化方法） 如果父类初始化方法不适用于子类，子类应复写这个方法并抛异常 17.实现description方法 NSLog中%@打印方式调用类的description方法，自定义类想要输出有用信息需要复写该方法。方法实现可以借用NSDictionary来打印，即 12345678- (NSString*)description &#123; return [NSString stringWithFormat:@&quot;&lt;%@: %p, %@&gt;&quot;, [self class], self, @&#123;@&quot;title&quot;:_title, @&quot;latitude&quot;:@(_latitude)&#125; ];&#125; 调试过程中LLDB的po命令调用类的debugDesctiption方法，该方法内默认调用description方法，可以通过复写debugDesctiption方法在调试中输出更详细信息 18.尽量使用不可变对象 “不可变”指readonly 可以在分类中（.m文件）重新声明暴露在外（.h文件）的属性，并将暴露属性的readonly特质改为readwrite，但是其他特质必须保持不变 需要可变的集合（指set、dictionary等）实现功能时，公开的属性中使用NSSet、NSArray等不可变集合，通过方法来对内部实现的可变集合进行修改 19.使用清晰而协调的命名方式 方法名：驼峰命名法，开头小写，后面每个单词首字母大写 类、协议名：Pascal命名法，每个单词首字母大写，但是前面一般有两三个大写字母前缀 方法命名 起名像是读一个句子。使用词语全称string而不是类似str这种简称（int这种参数类型的除外） 属性值XXX的获取方法命名“XXX”，设置方法命名“setXXX”。特例是BOOL属性，其获取方法一般命名“isXXX” 返回值若是新创建的，方法名的首个词应为返回值类型 如果方法返回一个非属性的BOOL，应当根据其功能选用has或者is位前缀 把表示参数类型的名词放在紧靠参数的前面，如NSString类的- (NSUInteger)lengthOfBytesUsingEncoding:(NSStringEncoding)enc中的Encoding，指参数类型为NSStringEncoding get前缀保留给使用参数来输出结果的那些方法。比如NSString类的- (void)getCharacters:(unichar *)buffer range:(NSRange)range方法，buffer为输出结果的参数，此方法则用get前缀 如果方法要在当前对象上执行操作，命名就要包含这个操作的动词。如果这个操作需要参数，则在动词后添加名词说明。比如上例中的get操作，后跟Characters名词 20.为私有方法名加前缀 OC没法控制一个方法是私有还是公共，给司机有方法加前缀可以与共有方法区分开 苹果公司保留了单下划线前缀作为私有方法的方式，自己的私有方法需要添加与之不同的前缀 21.理解Objective-C错误模型 只在极其罕见的情况抛异常（比如创建抽象基类的实例等）处理严重错误，抛异常以后程序直接退出，不再考虑编写“异常安全”代码 处理不严重错误时可以使用委托方法将NSError信息转给委托对象来处理错误，或者把错误信息放在NSError“输出参数”（使用传入的参数来输出数据）中返回给调用者 22.理解NSCopying协议 想要自己的类的实例可以拷贝，就要实现NSCopying协议（的copyWithZone方法） 如果自定义对象有可变和不可变版本，就要实现NSCopying协议和NSMutableCopying协议（mutableCopyWithZone） copy方法返回对象不可变版本（如NSArray），mutableCopy方法返回对象可变版本（如NSMutableArray），不论本来对象可变还是不可变 拷贝对象一般实行浅拷贝，除非相关文档中说以深拷贝实现，或者需要寻找对象有无深拷贝方法（如NSSet类的- (instancetype)initWithSet:(NSSet&lt;ObjectType&gt; *)set copyItems:(BOOL)flag方法，通过flag控制是否深拷贝）。如果自定义对象需要深拷贝，可考虑另外实现深拷贝方法 23.通过委托与数据源协议进行对象间通信 将委托对象应该支持的接口定义成协议，在协议中把可能需要处理的事件定义成方法 委托对象：含有被委托对象的强指针；声明遵守协议，实现协议方法，在被委托对象发消息过来（调用协议中的方法）时处理后续事项 被委托对象：含有委托对象的弱指针@property (nonatomic, weak) id&lt;XXXDelegate&gt; delegate;，进行事件处理，并将处理好的结果发消息（调用协议中的方法）出去 如果有必要（反复查询委托对象是否相应某选择子比较耗性能时等），可实现还有位域的结构体，将委托对象能否相应相关协议方法这一信息缓存其中，使用时只判断相应位域的值即可。如 12345678910111213141516171819202122232425@interface EOCNetworkFetcher : NSObject@property (nonatomic, weak) id&lt;EOCNetworkFetcherDelegate&gt; delegate;@end@interface EOCNetworkFetcher () &#123; struct &#123; unsigned int didReceiveData : 1; unsigned int didFailWithError : 1; unsigned int didUpdateProgressTo : 1; &#125; _delegateFlags;&#125;@end@implementation EOCNetworkFetcher- (void)setDelegate:(id&lt;EOCNetworkFetcherDelegate&gt;)delegate &#123; _delegate = delegate; _delegateFlags.didReceiveData = [delegate respondsToSelector:@selector(networkFetcher:didReceiveData:)]; _delegateFlags.didFailWithError = [delegate respondsToSelector:@selector(networkFetcher:didFailWithError:)]; _delegateFlags.didUpdateProgressTo = [delegate respondsToSelector:@selector(networkFetcher:didUpdateProgressTo:)];&#125;//...@end 24.将类的实现代码分散到便于管理的数个分类中 类过于臃肿时，可以根据功能将不同函数放入不同分类 可以将应当“私有”的方法建一个“Private”分类，在本程序库内使用，而对外隐藏实现细节 25.总是为第三方类的分类名称加前缀 向第三方类（不管是苹果给的原生类或者第三方库下载来的类）中添加分类、方法时，要加上含有自己特点的前缀，避免分类、方法间互相覆盖 26.勿在分类中声明属性 在“class-continuation分类”之外的其他分类中，都无法向类中增加实例变量，所以声明了属性编译器也没法将实例变量合成出来。所以属性一般定义在主接口中（及class-continuation分类中），而其他分类中可以定义属性的存取方法 27.使用“class-continuation分类”隐藏实现细节 “class-continuation分类”是一个没有名字的分类（括号里没有名字），且必须定义在类的主实现文件（.m）里。它是唯一能声明实例变量的分类 因此如果想把公开的只读属性扩展为内部可读写，也只能在“class-continuation分类”中做 不想让外人知道的遵守的协议也可在“class-continuation分类”中声明 不想让外人知道的私有方法也可在“class-continuation分类”中声明（声明是不强制要求的，但是声明了，类都拥有什么方法会比较清晰） 28.通过协议提供匿名对象 不想让人知道哪个具体类型、类型不重要而里面有没有某些方法才重要，之类的情况可以用遵守某协议的id匿名对象来表示 29.理解引用计数 ARC（自动引用计数）环境中与引用计数相关的方法无法使用（retain、release、autorelease、dealloc、retainCount） 引用计数&gt;0时对象存活，=0时对象销毁。保留与释放操作对应递增递减引用计数 循环引用导致内存泄漏，通常使其中一个改为弱引用，或者外界命令其中某个对象不再强引用（保留）另一个对象来打破循环 30.以ARC简化引用计数 ARC会在代码中合适地方插入“保留”与“释放”代码，使用ARC时程序员可基本不用再管内存管理 以alloc、new、copy、mutableCopy开头的函数返回的对象归调用者所有（OC的命名规则），调用者负责释放。但实际上ARC也帮忙处理了这些，所以也不用考虑内存管理 ARC只负责OC对象的内存管理，比如CoreFoundation对象不归ARC管理，还需要手动调用CFRetain/CFRelease。 31.在dealloc方法中只释放引用并解除监听 在ARC中，普通的OC对象释放已经默认实现，不需要再手动释放。只有一些特殊情况才重写dealloc方法 如30条所说的CoreFoundation对象需要在dealloc方法调用CFRetain/CFRelease来释放 注册（register）的键值观测（KVO）、NSNotificationCenter等通知需要在dealloc方法取消注册 对象持有的大开销资源或系统内稀缺资源，如文件描述符、套接字、大块内存等不在dealloc中释放，而是实现类似名为close等的方法释放，并且与使用者约定使用完资源要调用这个方法 dealloc中尽量不要调用其他方法，而执行异步任务的方法、只能在对象正常状态下执行的方法、属性存取方法等坚决不能在dealloc中调用 32.编写“异常安全代码”时留意内存管理问题 手动管理内存时，try块内创立的对象需要清理干净，比如在finally块中调用release ARC的默认情况下不生成处理安全异常所需的代码，因为会增大程序包且降低运行效率。OC++模式时编译器会自动打开标志来生成处理安全异常所需的代码 33.以弱引用避免保留环 将保留环中某些引用设为unsafe_unretained或者weak可以避免保留环成环，不过现在一般使用weak。unsafe_unretained引用的对象在被回收后，该引用仍然指向对象；而weak引用的对象在被回收后，引用置空，所以更安全一些 34.以“自动释放池块”降低内存峰值 目前常用的@autorelease写法为更轻便的自动释放池，可以放在循环大量创建对象那个循环体里来自动释放临时对象，降低内存峰值 35.用“僵尸对象”调试内存管理问题 将NSZombieEnabled环境变量设为YES可以开启“僵尸对象”，此对象由要回收的对象转化而成（实际上不回收，只是运行期转为僵尸对象），此对象可响应所有选择子，具体实现为打印一条消息并终止程序 36.不要使用retainCount retainCount可能会根据编译器具体实现、方法内所做操作而有与直觉不同的数值，所以反正不要用就对了 37.理解“块”这一概念 块是一种闭包，语法类似于C++的匿名函数，以^开头，如 123int (^addBlock)(int a, int b) = ^(int a, int b) &#123; return a + b;&#125;; 块可以捕获声明它的那个范围内的所有变量，比如声明它的函数内的局部变量。类的实例方法内声明的块可以捕获实例变量，当然此时连带self也一起捕获 块捕获的变量是对象时会拥有它（强引用），因此类中声明的块要注意保留环问题，比如类的实例（self）拥有其他对象，其他对象拥有块，块拥有self 块捕获的变量一般不可变。需要改变时，该变量要在声明的开头加__block修饰符，如 1234567NSArray *array = @[@1, @2, @3];__block NSInteger count = 0;[array enumerateObjectUsingBlock:^(NSNumber *number, NSUInteger idx, BOOL *stop) &#123; if ([number compare:@2] == NSOrderedAscending) &#123; count++; &#125; &#125;]; 块定义在大括号里为分配在栈上，出了大括号就自动回收了。想要保留块需要给它发送copy消息，块就变为拷贝一份到堆上，就可以用ARC管理堆上这个的生命周期（大概也是属性使用copy修饰的原因？） 1234567891011void (^block)();if (/* some condition */) &#123; block = [^&#123; NSLog(@&quot;Block A&quot;); &#125; copy];&#125; else &#123; block = [^&#123; NSLog(@&quot;Block B&quot;); &#125; copy];&#125;block(); 38.为常用的块类型创建typedef 需要时可用typedef创建块的类型别名以便于使用 12typedef void(^EOCCompletionHandler)(NSData *data, NSError *error);- (void)startWithCompletionHandler:(EOCCompletionHandler)completion; 类型别名也是一种类型，不要与现有类名冲突 相同多处块可以提出来定义类型别名，相改变参数时就能一改全改。但是不同用处的相同类型（入参、返回值）的块还是定义不同的类型别名为好，否则一改全改时会互相影响 39.用handler块降低代码分散程度 需要回调时通常通过代理或块执行某些代码，使用块可以将业务逻辑放在一块，而不需要像代理那种提出来方法写 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/************ 代理方式 ************/@class EOCNetworkFetcher;@protocol EOCNetworkFetcherDelegate &lt;NSObject&gt;- (void)networkFetcher:(EOCNetworkFetcher)networkFetcher didFinishWithData:(NSData*)data;@end@interface EOCNetworkFetcher : NSObject@property (nonatomic, weak) id&lt;EOCNetworkFetcherDelegate&gt; delegate;- (id)initWithURL:(NSURL*)url;- (void)start;@end// 其他类中使用- (void)FetchFooData &#123; NSURL *url = [[NSURL alloc] initWithString:&quot;http://...&quot;]; _fooFetcher = [[EOCNetworkFetcher alloc] initWithURL:url]; _fooFetcher.delegate = self; [_fooFetcher start];&#125;- (void)FetchBarData &#123; NSURL *url = [[NSURL alloc] initWithString:&quot;http://...&quot;]; _barFetcher = [[EOCNetworkFetcher alloc] initWithURL:url]; _barFetcher.delegate = self; [_barFetcher start];&#125;- (void)networkFetcher:(EOCNetworkFetcher)networkFetcher didFinishWithData:(NSData*)data &#123; if (networkFetcher == _fooFetcher) &#123; _fetchedFooData = data; _fooFetcher = nil; &#125; else if (networkFetcher == _barFetcher) &#123; _fetchedBarData = data; _barFetcher = nil; &#125; // etc...&#125;/************ 块方式 ************/typedef void(^EOCNetworkFetcherCompletionHandler)(NSData *data);@interface EOCNetworkFetcher : NSObject- (id)initWithURL:(NSURL*)url;- (void)startWithCompletionHandler:(EOCNetworkFetcherCompletionHandler)handler;@end// 其他类中使用- (void)FetchFooData &#123; NSURL *url = [[NSURL alloc] initWithString:&quot;http://...&quot;]; EOCNetworkFetcher *fetcher = [[EOCNetworkFetcher alloc] initWithURL:url]; [fetcher startWithCompletionHandler:^(NSdata *data) &#123; _fetchedFooData = data; &#125;];&#125;- (void)FetchBarData &#123; NSURL *url = [[NSURL alloc] initWithString:&quot;http://...&quot;]; EOCNetworkFetcher *fetcher = [[EOCNetworkFetcher alloc] initWithURL:url]; [fetcher startWithCompletionHandler:^(NSdata *data) &#123; _fetchedBarData = data; &#125;];&#125; 比如下载数据这种情况，下载成功和失败可以分别用两个块来处理，一个接受NSData参数一个接受NSError参数这样，也可以用一个块里分if来处理。用一个块的好处在于：可以用已经下载的一部分数据做额外处理，还可以在判断下载数据过短这类情况下，在当前方法内与失败共同使用一份处理代码而不用额外提出方法 可以加一个NSOperationQueue参数来让调用者决定把块放在哪个队列执行 40.用块引用其所属对象时不要出现保留环 第37条第三点提到部分 适时打破保留环，比如分析块用过就不用了，就可以在用过一次之后将块（对象）置nil 41.多用派发队列，少用同步锁 GCD（Grand Central Dispatch）技术（将消息收集到中枢再派发到不同线程队列执行的技术），出现之前使用的同步锁技术有下列等，但是仍然可能会产生死锁，以及效率不高 123456789101112// 同步块@synchronized(objectName) &#123; // 要加锁同步执行的代码块&#125;// NSLock对象、NSRecursiveLock“递归锁”对象_lock = [[NSLock alloc] init];- (void)synchronizedMethod &#123; [_lock lock]; // 要加锁同步执行的代码块 [_lock unlock];&#125; 串行与并发 串行：必须一个一个的执行，必须等上一个任务执行完成之后才能开始下一个，而且一定是按照先进先出的顺序执行的 并发：可以同时执行，也是按照先进先出的原则调用的 并发与并行：并发是逻辑概念上同时，两个任务可以用一个CPU交替执行；并行是物理概念上同时，必须两个CPU，两个任务在两个CPU上执行 同步与异步 同步：这个函数（或代码块）执行完成之后才会执行下面的代码。一般在当前线程中执行任务，不会开启新的线程。向队列里面添加任务时，等添加的任务完成之后再返回 异步：不管调用的函数有没有执行完，都会继续执行下面的代码。具备开启新线程的能力。向队列里面添加任务后立即返回 获取队列、任务添加、栅栏块 12345678910111213141516171819202122// 串行队列dispatch_queue_t serialQueue;serialQueue = dispatch_queue_create(&quot;mySerialQueue&quot;, NULL); // 创建（参数2使用NULL或者DISPATCH_QUEUE_SERIAL)dispatch_queue_t mainQueue = dispatch_get_main_queue(); // 获取主（串行）队列，必须小心安排任务顺序// 并发队列dispatch_queue_t concurrencyQueue;concurrencyQueue = dispatch_queue_create(&quot;myConcurrencyQueue&quot;, DISPATCH_QUEUE_CONCURRENT); // 创建concurrencyQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); // 获取全局并行队列（参数1区别高、中、低、后台优先级）// 代码运行在的（当前）队列dispatch_queue_t currentQueue = dispatch_get_current_queue();// 添加同步任务，根据官方文档，在大多数情况下，通过dispatch_sync添加的任务，在哪个线程添加就会在哪个线程执行。void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);// 添加异步任务，异步派发要拷贝块，注意考虑运行效率void dispatch_async(dispatch_queue_t queue, dispatch_block_t block);// queue从上面各种队列取，block为要执行的代码块// 总结起来一般情况是，串行同步在当前线程，串行异步新开线程（一个），并发同步在当前线程，并发异步在新开线程（多个）// 同步栅栏void dispatch_barrier_sync(dispatch_queue_t queue, dispatch_block_t block);// 异步栅栏void dispatch_barrier_async(dispatch_queue_t queue, dispatch_block_t block); 使用串行同步队列可以保证数据同步，更快的方法是并发异步队列执行读取，而写入单独执行。栅栏块必须单独执行，所以可以将写入块设置为栅栏块，具体是同步还是异步，还是说仅使用串行队列而不用并发，需要具体的性能测试来决定 42.多用GCD，少用performSelector系列方法 由于performSelector系列方法不知道传给自己的事什么选择子，所以ARC无法确定是否应该将执行返回的对象进行释放，容易造成内存泄漏问题 performSelector系列方法返回值为id，而选择子实际返回什么并不一定是对象，还可能是整数浮点数之类，需要麻烦的转换，而且performSelector系列方法能传给选择子的参数最多只有两个，也是id类型，局限性太大 使用performSelector系列方法放在另一个线程执行或者延迟一段时间执行，都可以封装成块，用GCD分发相关方法代替 43.掌握GCD及操作队列的使用时机 与第41条类似，操作队列提供了一种基于GCD的更高层次的封装，操作队列中的操作比GCD的块要重量级。NSOperationQueue创建/获取一个队列，NSOperation及其子类创建操作，将操作添加到队列中来执行。主队列在主线程执行，其他队列在子线程执行 使用操作队列可以： 方便取消操作执行。任务块安排到GCD是无法取消的，而操作安排到操作队列在未执行时可以取消 指定操作间的依赖关系 通过KVO（键值观测）检测NSOperation对象的属性，比如进行情况等 指定操作优先级。GCD的优先级是对队列来说的，而这里可以直接指定操作（任务）的优先级 使用哪种方式还是需要测试一下性能来做选择 44.通过Dispatch Group机制，根据系统资源状况来执行任务 相关方法/函数 123456789101112131415// 创建Dispatch Groupdispatch_group_t dispatch_group_create();// 任务编组（异步派发形式，要执行的block编组在group中，派发到queue队列执行）void dispatch_group_async(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block);// 阻塞等待组内所有任务执行完毕（timeout表示最多等待多长时间，成功执行完返回0，超时返回非0）long dispatch_group_wait(dispatch_group_t group, dispatch_time_t timeout);// 组内所有任务执行完毕后发通知（group内执行完后再queue上执行block做后续操作）void dispatch_group_notify(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block); 使用Dispatch Group可以将任务组成一组，利用GCD自动根据系统资源状况调度并发执行这些任务，在全部执行完后可以得到通知 45.使用dispatch_once来执行只需运行一次的线程安全代码 只执行一次且要保证线程安全的话，可以用dispatch_once来实现。如 123456789@implementation EOCClass+ (instancetype)sharedInstance &#123; static EOCClass *sharedInstance = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; sharedInstance = [[self alloc] init]; &#125;); return sharedInstance;&#125; static dispatch_once_t onceToken;静态变量，自动初始化为0，为0时dispatch_once正常执行块内代码；执行中onceToken被置为正数，表示正在进行；执行后onceToken被置为-1，表示执行过，下次执行时读取onceToken标志跳过执行块内代码 每次传入的标记（token）必须相同才能正确完成dispatch_once的流程 46.不要使用dispatch_get_current_queue 因为通常dispatch_get_current_queue获得了当前队列，但是在极端使用情况下仍然有死锁风险，所以一般只作为调试使用，而不使用到正式代码中。（极端情况：队列Q调用方法A，A中调用dispatch_sync想同步派发给队列R，但是实际上指定的R就是Q，会发生死锁。当dispatch_sync嵌套了多层，通过dispatch_get_current_queue获得了当前队列，但是也并不好确定根据获得的队列派发时会不会派发到外层所使用的队列而造成死锁） 47.熟悉系统框架 开发Mac OS X或者iOS的“带图形界面的应用程序”会用到Cocoa（Cocoa Touch）框架，严格来说Cocoa并不应该叫框架，但是里面集成了一些经常用到的框架 Foundation框架里使用NS前缀，提供Objective-C的内容基础 Core Foundation框架使用CF前缀，提供与Foundation框架基本对应的C语言API，两个框架之间的等下哦对象可以通过“无缝桥接”技术互相转换 开发Mac OS X或者iOS的UI界面使用的核心框架为AppKit、UIKit，这两个框架提供了以Core Foundation与Foundation为基础构建的Objective-C类，使用CoreAnimation（QuartzCore框架一部分，用来渲染图形与播放动画）与CoreGraphics框架（定义了2D渲染所需结构与函数，如CGSize、CGRect等数据结构）实现 48.多用块枚举，少用for循环 遍历一个集合（数组、set、字典、自定义集合类型等）方式 for循环 NSEnumerator（第一次调用nextObject返回第一个，遍历完时返回nil） 123456789101112131415161718192021222324252627282930313233// ArrayNSArray *anArray = /*...*/;NSEnumerator *enumerator = [anArray objectEnumerator];id object;while ((object = [enumerator nextObject]) != nil) &#123; // 使用object&#125;// DictionaryNSDictionary *aDictionary = /*...*/;NSEnumerator *enumerator = [aDictionary keyEnumerator];id key;while ((key = [enumerator nextObject]) != nil) &#123; id value = aDictionary[key]; // 使用key、value&#125;// SetNSSet *aSet = /*...*/;NSEnumerator *enumerator = [aSet objectEnumerator];id object;while ((object = [enumerator nextObject]) != nil) &#123; // 使用object&#125;// 反向遍历NSArray *anArray = /*...*/;NSEnumerator *enumerator = [anArray reverseObjectEnumerator];id object;while ((object = [enumerator nextObject]) != nil) &#123; // 使用object&#125; 快速遍历（支持快速遍历的集合类需要声明NSFastEnumeration协议，实现- (NSUInteger)countByEnumeratingWithState:(NSFastEnumerationState *)state objects:(id)buffer count:(NSUInteger)len;方法，缺点是拿不到对象的下标） 123456789101112131415161718192021222324// Array for内object的类名可以换成具体类，比如NSStringNSArray *anArray = /*...*/;for (id object in anArray) &#123; // 使用object&#125; // DictionaryNSDictionary *aDictionary = /*...*/;for (id key in aDictionary) &#123; id value = aDictionary[key]; // 使用key、value&#125; // SetNSSet *aSet = /*...*/;for (id object in aSet) &#123; // 使用object&#125; // 反向遍历NSArray *anArray = /*...*/; for (id object in [anArray reverseObjectEnumerator]) &#123; // 使用object&#125; 基于块的遍历 12345678910111213141516171819202122232425262728293031323334353637// ArrayNSArray *anArray = /*...*/;[anArray enumerateObjectsUsingBlock:^(id object, NSUInteger idx, BOOL *stop)&#123; // 使用object if (/*应当停止循环的条件*/) &#123; *stop = YES; &#125;&#125;]; // DictionaryNSDictionary *aDictionary = /*...*/;[aDictionary enumerateKeysAndObjectsUsingBlock:^(id key, id object, BOOL *stop)&#123; // 使用key、object if (/*应当停止循环的条件*/) &#123; *stop = YES; &#125;&#125;]; // SetNSSet *aSet = /*...*/;[aSet enumerateObjectsUsingBlock:^(id object, NSUInteger idx, BOOL *stop)&#123; // 使用object if (/*应当停止循环的条件*/) &#123; *stop = YES; &#125;&#125;]; // 添加遍历方式，比如并发NSEnumerationConcurrent、反向NSEnumerationReverse等，可以用按位或组合// block可以更改签名为具体存的类型，可以让编译器检测是否写错NSDictionary *aDictionary = /*...*/;[aDictionary enumerateKeysAndObjectsWithOptions:NSEnumerationConcurrent usingBlock:^(NSString *key, NSString *object, BOOL *stop)&#123; // 使用key、object if (/*应当停止循环的条件*/) &#123; *stop = YES; &#125;&#125;]; 49.对自定义其内存管理语义的collection使用无缝桥接 __bridge相关（无缝桥接） __bridge可以实现Objective-C与C语言变量 和 Objective-C与Core Foundation对象之间的互相转换，不会改变对象的持有状况，OC的对象仍然ARC管，引用计数不变，C的数据结构C管，手动释放。但是如果C对象转到OC对象，OC对象使用强引用接收，该对象的OC部分引用计数会+1 __bridge_retained用于将OC变量转换为C语言变量 或 将OC对象转换为Core Foundation对象，OC部分引用计数不变，C部分引用计数多1，ARC仍然管理该对象在OC部分的引用计数，在C部分的“引用计数”手动管 __bridge_transfer用于将C语言变量转换为OC变量 或 将Core Foundation对象转换为OC对象，OC部分引用计数多1，C部分引用计数少1，ARC仍然管理该对象在OC部分的引用计数，在C部分的“引用计数”手动管 使用桥接可以改变某种集合的内存管理语义，比如NSDictionary对于键实行“拷贝”，如果键不支持拷贝则会报错。从CF对应的字典里把键的内存管理语义改成“保留”，再用桥接接回NSDictionary则可以解决这个问题 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#import &lt;Foundation/Foundation.h&gt;#import &lt;CoreFoundation/CoreFoundation.h&gt;// 向字典中传值调CFDictionaryRetainCallBackconst void* EOCRetainCallback(CFAllocatorRef allocator, const void *value) &#123; return CFRetain(value);&#125;// 字典释放调CFDictionaryReleaseCallBackvoid EOCReleaseCallback(CFAllocatorRef allocator, const void *value) &#123; CFRelease(value);&#125;//typedef struct &#123;// CFIndex version;// CFDictionaryRetainCallBack retain;// CFDictionaryReleaseCallBack release;// CFDictionaryCopyDescriptionCallBack copyDescription;// CFDictionaryEqualCallBack equal;// CFDictionaryHashCallBack hash;//&#125; CFDictionaryKeyCallBacks;//callback结尾的都是回调函数指针，version目前固定传0，copyDescription传NULL表示用默认，//equal与hash使用CFEqual与CFHash，这也是NSMutableDictionary默认使用的CFDictionaryKeyCallbacks keyCallbacks = &#123; 0, EOCRetainCallback, EOCReleaseCallback, NULL, CFEqual, CFHash&#125;;//typedef struct &#123;// CFIndex version;// CFDictionaryRetainCallBack retain;// CFDictionaryReleaseCallBack release;// CFDictionaryCopyDescriptionCallBack copyDescription;// CFDictionaryEqualCallBack equal;//&#125; CFDictionaryValueCallBacks;CFDictionaryValueCallbacks valueCallbacks = &#123; 0, EOCRetainCallback, EOCReleaseCallback, NULL, CFEqual,&#125;;//CFMutableDictionaryRef CFDictionaryCreateMutable(CFAllocatorRef allocator, // CFIndex capacity, const CFDictionaryKeyCallBacks *keyCallBacks, // const CFDictionaryValueCallBacks *valueCallBacks);//allocator用NULL表示使用默认，capacity是最初分配多大容量CFMutableDictionaryRef aCFDictionary = CFDictionaryCreateMutable(NUNLL, 0, &amp;keyCallbacks, &amp;valueCallbacks);NSMutableDictionary *anNSDictionary = (__bridge_transfer NSMutableDictionary*)aCFDictionary; 50.构建缓存时选用NSCache而非NSDictionary 管理缓存应当使用NSCache，可以在缓存不足时自动删除部分缓存，虽然NSCache类似于键值对存储，但是NSCache不拷贝而是保留键 可以给NSCache设缓存上限，但是只是指导作用而不是硬限制 1234// 两种缓存设限方式NSCache *cache = [[NSCache alloc] init];cache.countLimit = 100; // cache对象存储个数上限100cache.totalCostLimit = 5 * 1024 * 1024; // cache对象存储空间上限5MB NSPurgeableData（“可清除的数据”）类表示内容在内存中时可以根据需要随便丢弃，在NSCache里的这种对象表示在内存丢弃这个对象时，缓存中会一并移除。使用方法例： 1234567891011121314151617181920212223242526- (void)downloadDataForURL:(NSURL*)url &#123; // 从缓存查找 NSPurgeableData *cachedData = [cache objectForKey:url]; // 缓存命中 if (cachedData) &#123; // 调beginContentAccess增加“使用计数”，避免对象被丢弃掉 [cachedData beginContentAccess]; [self useData:cachedData]; // 调endContentAccess减少“使用计数”，表示用完了，可以随便丢了 [cachedData endContentAccess]; &#125; // 缓存未命中 else &#123;数据 // 获取 EOCNetworkFetcher *fetcher = [[EOCNetworkFetcher alloc] initWithURL:url]; [fetcher startWithCompletionHandler:^(NSData *data) &#123; // 获取到的数据做成个NSPurgeableData对象，创建时该对象的“使用计数”就已经增加了1 NSPurgeableData *purgeableData = [NSPurgeableData dataWithData:data]; // 存到cache里，设定cost [cache setObject:purgeableData forKey:url cost:purgeableData.length]; [self useData:data]; // 这里就减少“使用计数”，可以看到并没有对应的beginContentAccess调用 [purgeableData endContentAccess]; &#125;]; &#125;&#125; 51.精简initialize与load的实现代码 类的+ (void)load方法可以执行初始化操作，但是现在一般不用，基本只在调试程序里比如判断某个分类载入没载入才用 load方法可以在类和分类中都写，也可以在其中一个写，也可以都不写。写的话仅在包含类/分类的程序库载入系统时调用一次，先调类中的，再调分类中的。load方法中自动调用所有超类的load方法，以及使用到的程序库的load方法，必须所有相关类的load都执行完之后程序才继续执行下面内容。而对于同一程序库中的各个类之间，调用load的顺序是随机的（运行期系统处于不完全状态，不安全）。类没有load方法就不会自动调用其超类的。load方法执行时会阻塞程序，比如加锁、等锁、执行任务都不要做。 initialize方法也是系统调用，也只调用一次。不过是惰性调用，没用到的类不会调用这个方法。与程序库中load随机调用顺序导致的不安全不同，initialize调用时可以调用任意类任意方法（运行期系统处于完整状态），也会保证该方法在线程安全环境中被调用，其他使用该类/实例的线程会阻塞等待。如果某个类未实现initialize方法，则调用其超类方法（与普通消息的表现相同），比如类B继承于类A，A实现而B没实现initialize方法，则初始化子类B时，先初始化基类A，调用一遍A的initialize方法，到了子类B也会调用A的initialize方法 + （void)initialize方法实现代码也需要保持精简，一般只是设一些状态数据等，虽然可以，但是也尽量不要调用别的方法（本类或者其他类）。一个是UI线程调用该方法初始化类时会阻塞，导致应用无响应；二是初始化时机可能会在将来运行期系统更新后改变，依赖某特定时间点来初始化可能会出问题；三是两个类之间可能造成循环initialize，而类中数据可能还没有初始化好，调用别的方法也可能会造成这种情况。 如果某全局变量比如NSMutableArray的对象等没法在编译期初始化，则可以放在类的initialize方法中来做 52.别忘了NSTimer会保留其目标对象 + (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)seconds target:(id)target selector:(SEL)selector userInfo:(id)userInfo repeats:(BOOL)repeats;类似这种计时器创建时，在什么对象上调用什么方法分别传到target和selector上，这里计时器就会保留该target对象，直到自己失效时才会释放该target对象。一次性计时器执行完任务即失效，重复性计时器需要对计时器发invalidate消息才失效 因为上述原因，重复性计时器中，如果一个类实例对象调用上述方法生成的NSTimer对象赋给了实例变量，则保留了计时器，计时器又执行self的方法保留了类实例对象，形成保留环造成内存泄漏 目前可通过自己加分类方法解决上述问题。例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// NSTimer分类@interface NSTimer (EOCBlockSupport)+ (NSTimer *)eoc_scheduledTimerWithTimeInterval:(NSTimeInterval)interval block:(void(^)(void))block repeats:(BOOL)repeats;@end@implementation NSTimer (EOCBlockSupport)+ (NSTimer *)eoc_scheduledTimerWithTimeInterval:(NSTimeInterval)interval block:(void(^)(void))block repeats:(BOOL)repeats &#123; return [self scheduledTimerWithTimeInterval:interval target:self selector:@selector(eoc_blockInvoke:) userInfo:[block copy] repeats:repeats];&#125;+ (void)eoc_blockInvoke:(NSTimer *)timer &#123; void (^block)(void) = timer.userInfo; if (block) &#123; block(); &#125;&#125;@end// 使用示例@interface EOCClass : NSObject- (void)startPolling;- (void)stopPolling;@end@implementation EOCClass &#123; NSTimer *_pollTimer;&#125;- (instancetype)init &#123; return [super init];&#125;- (void)dealloc &#123; [_pollTimer invalidate];&#125;- (void)startPolling &#123; __weak EOCClass *weakSelf = self; _pollTimer = [NSTimer eoc_scheduledTimerWithTimeInterval:5.0 block:^&#123; EOCClass *strongSelf = weakSelf; [strongSelf p_doPool]; &#125; repeats:YES];&#125;- (void)stopPolling &#123; [_pollTimer invalidate]; _pollTimer = nil;&#125;- (void)p_doPool &#123; // Pool the resource&#125;@end 新加分类里，计时器自身执行eoc_blockInvoke，eoc_blockInvoke里执行 使用计时器的类 传入的block，该block是通过copy拷贝到堆上保证块不会无效，同时计时器的userInfo引用了该块。似乎计时器强引用了self，还是循环引用，但是实际上NSTimer是个类对象，是个单例，无需回收，不用担心循环引用的问题。在使用中，使用新加的eoc_scheduledTimerWithTimeInterval...方法，传入块，此时可以只用外面weak里面strong方法切断保留环。（类实例变量保留计时器，计时器保留块，而块捕获了弱引用，保留的是弱引用weakSelf而不是强引用self，打破了保留环。块里strong是为了实例在块执行期间存活）如果EOCClass实例的引用计数降为0，dealloc会停止计时器任务。即使dealloc忘了写invalidate，weakSelf也会变成nil而没法相应消息","categories":[{"name":"学习","slug":"学习","permalink":"https://neko-horikawaraiko.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"https://neko-horikawaraiko.github.io/tags/Objective-C/"}]},{"title":"【鼓哥】带你玩东方-外传（二十七）（解谜、策略游戏篇）","slug":"【鼓哥】带你玩东方-外传（二十七）（解谜、策略游戏篇）","date":"2023-02-05T14:36:00.000Z","updated":"2024-11-04T15:42:51.148Z","comments":true,"path":"2023/02/05/【鼓哥】带你玩东方-外传（二十七）（解谜、策略游戏篇）/","link":"","permalink":"https://neko-horikawaraiko.github.io/2023/02/05/%E3%80%90%E9%BC%93%E5%93%A5%E3%80%91%E5%B8%A6%E4%BD%A0%E7%8E%A9%E4%B8%9C%E6%96%B9-%E5%A4%96%E4%BC%A0%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%83%EF%BC%89%EF%BC%88%E8%A7%A3%E8%B0%9C%E3%80%81%E7%AD%96%E7%95%A5%E6%B8%B8%E6%88%8F%E7%AF%87%EF%BC%89/","excerpt":"","text":"大家好啊，这里是猫耳堀川雷鼓~ 这一期给大家再带来几个烧脑类游戏，就是标题中那三种。不过实话说，平时动脑子上班上学挺多了，玩游戏也玩这种的我就感觉，“我玩游戏是要放空脑子的，怎么还给我烧脑？”玩着玩着就不想碰这游戏了。本期的话，No.6有点意思，但是更偏重搞笑吐槽了，No.14伪大作，可惜鸽了，还有No.16这种的，该狠狠地催更的。其他就是随意看看吧~ No.1（外传总No.451）游戏名：さなポカっ！ 游戏类型：策略游戏 Produced by：失零 -lost ZERO- 这个游戏的原型就是“梭哈”玩法，只不过梭哈是用牌，这里改成了四种小怪身上带点数显示。小怪类似俄罗斯方块一样下落。基本牌型比如葫芦、顺子、四条之类这里适用，凑成了之后可以消掉数行小怪，根据做成的牌型而不同，最好做的大概是同花和一对，当然也只能消一行。其他方面大概借鉴了tetris等的攻击模式，消除牌型可以积累灵力发动符卡，攻击对方或者消除自己的几行；也能积累“joker攻击”，给对方从下往上叠灰色块（只能通过做牌多行消除或者符卡消除）。 No.2（外传总No.452）游戏名：Puzzle Collection7th with ぱにぱに / PuzzleCollection with 粟 / PuzzleCollection with UGUME / PuzzleCollection with しょぺ / PuzzleCollection with 糸麦くん / PuzzleCollection with 猫水瀬 / PuzzleCollection with ラムタイズム / PuzzleCollection with ワキサカDK / Puzzle Collection7th with 涼たん / PuzzleCollection with ウンツエ / PuzzleCollection with おだ / PuzzleCollection with もねてぃ / PuzzleCollection with たこらいす / PuzzleCollection with エクセル / PuzzleCollection with 兵隊幻酔 / PuzzleCollection with かるぴ 游戏类型：解谜游戏 Produced by：Puzzle Collection project 类拼图游戏的大合集，拼到你不想再拼。而且你没看错，游戏名列举了16个名字，这个社团做了16个这种游戏，每个里都是这10个小游戏，区别在于，画师不同，也就是with后面写的名字……而且其中有几个是你懂得。 游戏1：传统16格拼图 游戏2：找出与不在右上图画中的格子 游戏3：将出现的图片碎片分到左右两边，左边按鼠标左键，右边按右键 游戏4：忘了学名叫啥了，就是一条路不重复铺满画面（深红格子除外） 游戏5：躲深红格子，不过自身体积很大，大概是和格子一样的正方形判定 游戏6：走迷宫，左上角到右下角 游戏7：把深红格子打回去，不让到底 游戏8：方形四格旋转的拼图 游戏9：一挪挪一行/列的拼图（和8一样我不知道怎么解） 游戏10：类似2048一样一动动到底的块，两个块拼到缺失的两块地方 No.3（外传总No.453）游戏名：騒霊でぃふぇんだ～ず 游戏类型：策略游戏 Produced by：ekus-U 虽然觉得不太愿意，还是根据游戏名（防卫者）放到这个分类来了。大致就是噼里啪啦利巴三姐妹开演唱会有很多捣乱的，就留着莉莉卡在舞台表演+发弹幕，梅露兰发激光，露娜萨发停止雾气，一块守护舞台。过一段时间（大概是分数）就会清场并升级一次，在右上角雾气范围、激光范围、激光攻击力中三选一进行能力升级。最好是俩人去玩，因为梅露兰和露娜萨是要去操作的，莉莉卡不用。不过游戏确实简陋了点。 No.4（外传总No.454）游戏名：紫と霊夢の終わらない夏 游戏类型：策略游戏 Produced by：ひまわり鎮痛剤 这个和之前写过的一个ばいなりぃすわちるの （总No.205）挺像的，就是同时操作镜像的两个角色，然后拿一些什么东西过关。不过这个并不会用墙阻挡哪个角色来对位置，而是只要把画面上所有要捡的道具捡完就过关。用灵梦去捡符札，用紫妹去捡蝴蝶结。主操作在灵梦，紫妹就在镜像位置穿墙。遇到危险可以互换位置，但是有次数限制。 No.5（外传总No.455）游戏名：東方鎖宝録 游戏类型：策略游戏 Produced by：こすぷれ喫茶娘々 带点小剧情的泡泡龙游戏，像是解五个题目这样，每一波都是设定好的，就是出的泡泡会比较随机。过程中没消掉一些泡泡积攒一定的符卡能量槽，攒满可以发动符卡。每打完一波给对面打掉一点血，比谁先把这五波打完，失败者会有不那么大的大破。 No.6（外传总No.456）游戏名：日陰サバイバン 游戏类型：策略游戏 Produced by：みょふ～会 各种意义上都很像逆转裁判的游戏，但是充满了各种槽点，比如灵梦说身为主角肯定不会犯事啊，比如姆q指着头上的月牙装饰说这是律师徽章啊之类。除了语言不通之外，看懂里面说的啥的时候还是能笑出声的。有机会还是值得玩一玩的，不过确实没见到有汉化。 No.7（外传总No.457）游戏名：魔理沙の冒険～The Quest of Marisa～ 游戏类型：策略解谜游戏 Produced by：Blue Mica 比较传统的拿钥匙开门的策略解谜游戏，拿到全部必须的钥匙才能过关。这个游戏中魔理沙可以通过捡道具来发动近程或远程攻击，有机会就尽量拿一下，过关会简单一点。 No.8（外传总No.458）游戏名：すわこちゃんのぱっちぇりす 游戏类型：策略解谜游戏 Produced by：UTG Software UTG的又一个青蛙子主角游戏。这次是早苗掉到地洞里去了，青蛙子找来姆q帮忙，姆q给开了个洞然后扔了一只小青蛙子下去帮忙找。小青蛙子傻头傻脑的，每一关开头有几秒倒计时，倒完了青蛙子就开始走，而且只会无脑左右走，以及跳上一格、跳下不限格，遇到小怪或者悬崖自己是不会躲的，遇到超过一格的跳上高度就会回头。目的就是跟放俄罗斯方块似的给小青蛙子搭桥，拿到钥匙然后进门。中间可以用这些砖块给把小怪压死，不过过一会就会刷新然后从天上掉下来，正好青蛙子走到那的话基本就没救了。 No.9（外传总No.459）游戏名：沓星約守綴 游戏类型：策略游戏 Produced by：遊色高楼 遊色高楼比较出名的应该是做的一些stg，比如东方求霖忍、东方雨仰石、方解梦异闻，而这个是他们社团的（大概唯一）一个塔防策略游戏。和一般的塔防确实也做出了一些不一样的东西，首先是几乎所有怪都在比较深色的路上走，而这条路上你要防守住的角色也走，相当于一直在保护一个移动的防卫点。当然在一波之内这个角色是不会走的，也算是没太提高防守难度。另一个就是除了这个主路上都可以放防御塔（使魔？），一般一座塔是占4格，不过这个格子比较小，放的时候容易歪（强迫症震怒）。然后塔有攻击属性、弱点属性，怪有弱点属性、能力。只能说系统这样做上限挺高，但是画面真的拉下来了。 No.10（外传总No.460）游戏名：東方権々会 游戏类型：策略游戏 Produced by：いつものところ 一个麻将和视觉小说对半开的游戏，大概类似麻将大会那种比赛性质的游戏机制，但是难度感觉不高（？）。规则就是普通日麻规则，会雀魂就也会打这个。 之前还写过一个教小伞打麻将的游戏，ビギナー闘牌伝説コガサ（外传第二十五期No.10，总No.420），也是类似的视觉小说+麻将，不过那个巨大篇幅讲麻将基础，真就是给新手看的。 No.11（外传总No.461）游戏名：古明地五：与觉大人下情侣棋 ~ Satori Five! 游戏类型：策略游戏 Produced by：第零研究院 零教授被封的游戏之一，主要规则是五子棋规则，分易中难三档，困难还加上了大将棋的规则。具体规则可以在附带文件里看。不过来玩这个的目的是不是真去玩五子棋呢？ No.12（外传总No.462）游戏名：東方雀姫譚 游戏类型：策略游戏 Produced by：いつものところ、YOU!YOU!YOU! 与No.8像的一批的游戏，毕竟是同一个社团作品。去找了找发布时间，确实没找到哪个更早，都是在2011左右有的介绍。结构差不多，都是视觉小说+麻将形式，也不多介绍了。 No.13（外传总No.463）游戏名：チルノ⑨冒険 游戏类型：策略游戏 Produced by：つるぺた研究所 也不知道算策略还是动作的游戏，就是跟QQ堂那个推箱子地图一样的游戏，这边就是压死青蛙得分。boss关就是跟诹访子干，得多用箱子砸到几下。 No.14（外传总No.464）游戏名：スペルカードストライクオンライン 游戏类型：策略游戏 Produced by：AQUASTYLE 牌佬狂喜，然而实际上这是个实体卡牌的线上版客户端，aqua的这游戏主要还是发实体版卡牌，线上这个就像是弃子似的，卖了一次线上激活码卡牌包之后就没声了，只有几个根据这个客户端提供的固定牌组啥都动不了。大概也就是召唤，移动，消耗几张牌发技能之类，和游戏王之类区别不大。这个客户端如果一直维护的话做的还是不错的，画面指示做得也比较到位，基本发的实体卡这里能在卡牌库中也能看。不过客户端也好久没更了，官方比赛也停了好几年了，客户端对战网络里一个人都没。 No.15（外传总No.465）游戏名：幻想郷横断るなてぃっくいず 游戏类型：问答游戏 Produced by：Suifu Goudou Kikaku 东方主题的问答游戏，不过问题都特别硬核，原作游戏小说漫画都能出题，甚至还有某个东西怎么读这种题（当然也是问的日文读法）。做起来非常折磨，基本一个都答不对（ No.16（外传总No.466）游戏名：东方异文石P2. Ayaria Hazard 游戏类型：动作解谜游戏 Produced by：萌东方兄弟会 这个游戏，不多介绍了吧，著名的异文石系列第二部——早苗的108种死法。加标签的话就是动作、解谜、恐怖，毕竟全员谜语人，死亡CG一大把，教主还不出第七章。站里也一大堆视频，剧情攻略都有。 No.17（外传总No.467）游戏名：スーパーヒロイン大戦 東方スタート版 / スーパーヒロイン大戦 東方スタート版2 游戏类型：策略游戏 Produced by：La.Scene 也是类似火纹的策略战棋游戏，这个就是幻想乡众与其他人打。因为这个系列出了好几作，每一作是不同的示例，所以其实只能说这游戏带有东方要素。基本是把黄昏绘掐上来，不过意外的是有一定量的大段文字配音，虽然有些人物配的感觉不太符合预期，但是配音在这里确实拉高了游戏体验。另外这游戏文件eve结尾，得用一个叫SRC的软件打开，但是这软件官网已经挂掉了（我记得应该wayback machine还有存档能下到 这个游戏出了很多代，就是不同的动漫角色互相客串然后开打，我所见スーパーヒロイン大戦 VOL.1-9里都有东方角色客串，而東方スタート版这两部就主打东方。 No.18（外传总No.468）游戏名：小傘崩し / 小傘崩しぷらす 游戏类型：策略游戏 Produced by：Ｗ.Ｓ.Ｐ 哎这个打砖块是真的……奇怪。首先是和灵异传似的，球弹到底部是反弹回去的，而不是掉下去；还有就是被球砸到侧面会被打死。另外就是球速会越来越快，后期主要都是在躲球而不是接球了。而且伞的反弹效果是镜面反射，没法物理效果地，根据移动方向往那个方向多摩擦一点角度，所以剩一点砖块的时候也很难打。实际游戏感觉其实还不如批量制作的那~种打砖块。 这个游戏还有续作，小傘崩しぷらす，几乎一样的感觉，就不做介绍了。 No.19（外传总No.469）游戏名：东方奇符剧 游戏类型：卡牌策略游戏 Produced by：凌天翼、Slob、Moligaloo等 用QSanguosha引擎做的另一个东方MOD三国杀，反正都挺熟的就也不介绍啥了，阵营这边是分了风花雪月神五个，人物技能啥的根据东方人物写了写。 No.20（外传总No.470）游戏名：かっぱたんく 游戏类型：策略射击游戏 Produced by：悠遊亭 悠遊亭做的奇奇怪怪游戏之一，这个基本是fc那个坦克大战的翻版，但是真的不好玩。因为视角不是天空而是人物后面，视角遮挡很严重，不知道敌人在哪，很容易就被爆屁股了。除了这个之外就加了点人物技能，但是并没有感觉出有多大作用。 pid=83564675","categories":[{"name":"游戏","slug":"游戏","permalink":"https://neko-horikawaraiko.github.io/categories/%E6%B8%B8%E6%88%8F/"}],"tags":[{"name":"带你玩东方","slug":"带你玩东方","permalink":"https://neko-horikawaraiko.github.io/tags/%E5%B8%A6%E4%BD%A0%E7%8E%A9%E4%B8%9C%E6%96%B9/"}]},{"title":"【鼓哥】带你玩东方-外传（二十六）（动作游戏篇）","slug":"【鼓哥】带你玩东方-外传（二十六）（动作游戏篇）","date":"2023-01-22T19:53:00.000Z","updated":"2024-11-04T16:33:55.037Z","comments":true,"path":"2023/01/23/【鼓哥】带你玩东方-外传（二十六）（动作游戏篇）/","link":"","permalink":"https://neko-horikawaraiko.github.io/2023/01/23/%E3%80%90%E9%BC%93%E5%93%A5%E3%80%91%E5%B8%A6%E4%BD%A0%E7%8E%A9%E4%B8%9C%E6%96%B9-%E5%A4%96%E4%BC%A0%EF%BC%88%E4%BA%8C%E5%8D%81%E5%85%AD%EF%BC%89%EF%BC%88%E5%8A%A8%E4%BD%9C%E6%B8%B8%E6%88%8F%E7%AF%87%EF%BC%89/","excerpt":"","text":"大家兔年新年好啊，这里是猫耳堀川雷鼓~ 没想到吧，第一篇专栏在大年初二就出来了。（但是实际上这里面所有游戏直播展示的时间跨度是好几个月）不过不管怎么说，动作游戏还是可玩性比其他游戏高出一截的，所以在玩的时候还是不那——么痛苦地去体验了一番。本期里No.3、6、11、16是我觉得做的比较好的几个，不过No.3那个还是太可惜了，做的太短没有后续，是和上一篇中莲子恶搞梅莉同一拨人做的。 No.1（外传总No.431）游戏名：WriggleSpell 游戏类型：动作游戏 Produced by：GlowGloat 一个莉格露主角的动作游戏，因为还是体验版，暂时还没什么故事性，就是普通的平台跳跃+收集（萤火虫）要素。攻击手段只有跳起来踢，也可以踢到发白光的那些球上跳得更高。手感不错。好像作者是一个人做这个，看看啥时候能做成成品吧。 No.2（外传总No.432）游戏名：Yosei Survivors 游戏类型：动作游戏 Produced by： 算是一个“自动地牢”？就是打怪然后升级获得新的武器/技能或者对已有的武器技能升级，然后继续打怪。就属于那种越打越无聊的类型。 No.3（外传总No.433）游戏名：今の見たのか！？リグル・ナイトバグ 游戏类型：动作游戏 Produced by：Slowbroski22, Ferdy’s Lab, Sorasu (Slascoplerd), HakanaiBlue 有点索尼克风格的动作游戏，道中就是比较高速的跑酷，遇到小怪就是踹出去来攻击。游戏的手感不错，画风很柔和，快速跑起来也能够注意到自己在哪。唯一的缺点就是太短了，还没玩够就结束了。 No.4（外传总No.434）游戏名：霊夢のハチャメチャ大捜索 游戏类型：动作游戏 Produced by： 悠遊亭的又一个动作游戏，有8大关，每个3小关，最后一小关关底有个boss战，打关获得sp来升级技能（特武）等。和之前游戏相比没啥出彩的地方，中规中矩吧。 No.5（外传总No.435）游戏名：リリーブラックと黒人形 游戏类型：动作游戏 Produced by：ほわいとふれあ（46flare） 莉莉白/黑为主角的动作游戏，通过切换人物（只能在固定地点切换）来打出不同攻击通过关卡，boss关甚至突变为stg。总之横版动作很传统，有点马里奥的味道（踩死敌人），亮点不多。 No.6（外传总No.436）游戏名：東風谷早苗の神風とともに 游戏类型：动作游戏 Produced by：反歩堂 星之卡比风的动作游戏，不过相当难顶。对标应该是梦之泉那一代左右，拥有了吸入敌人获取能力的设定，但是这个游戏相比卡比获取血和命的方式少了很多。可以获得的能力也很少，kk的网站上有过一定的介绍，可以获得伞（小伞）、不能飞的龙卷风（转转）、冰（⑨）、球（橙喵）、投掷（西瓜）、水泡（水泡河童，kk那边没写）等几种能力。画风和音乐都不错，就是容错性稍微有点低。 No.7（外传总No.437）游戏名：幻想郷プロレス～マッスルタッグマッチ～ 游戏类型：动作游戏 Produced by： 就是fc游戏《筋肉人》（《摔角》）的东方翻版，没啥好说的。 No.8（外传总No.438）游戏名：SMASH T.H. 游戏类型：动作射击游戏 Produced by：もりそば置き場 大概就是一种双方向控制的射击游戏，并不飞行。跟弹幕天邪鬼有点像，仅指双道具系统，主道具是各种子弹，辅道具就是各种能力，比如加速啊、一次无敌盾啊之类。吃点增加b槽，满了可以扔一个b出去。打倒所有小怪即可过关，但是小怪数量太多了，基本只能靠拿强力子弹打或者b去炸。 No.9（外传总No.439）游戏名：幻想郷防衛軍 游戏类型：动作游戏 Produced by：11th November 这个3D建模……想不出该用啥来描述。整个也就一个在地图上找怪挥笤帚打怪的游戏，真的觉得用3D没啥意义，还不如做成2D。（虽然是2012年的游戏但是我觉得也不该3D这么拉胯） No.10（外传总No.440）游戏名：文ちゃんDASH 游戏类型：动作游戏 Produced by： 看标题画面像是原作一样的stg，进去之后实际只是个平台跳跃跑酷游戏。画面水平强制移动（卷轴），人物也可以左右动，但是卷轴卷过去的地方就回不去了。普通时候跳跃只能跳的比较矮，吃到木屐道具就可以一段时间跳更高，也有加血啊之类的道具。敌人可以通过射击打死或者踩死，但是还是因为跳跃又矮又近所以很容易直接撞上去掉血。每一大关6小关，第6小关boss战，打过去可以解锁下一大关（场景）。可玩性还是比较足的，就是难度稍微有点点。 No.11（外传总No.441）游戏名：幻想のハルトマン 游戏类型：动作射击游戏 Produced by：Magic Arcade 啊这个游戏……怎么说呢……这个游戏作者和他之前所在团队他们那些xjb事情之前在东游鉴那边是讲过的，很乱，现在也不知道谁对谁错了。仅仅对这个游戏来说，同样也是继承自洛克人EXE系列，不过作者把这游戏分类叫弹幕射击我是没想到的，我觉得算是动作+策略。这个游戏技能感觉类似抽卡卡牌那种形式了，直接从手牌中拿技能然后放技能，而不是组合技那样。 当然，这游戏本来想上steam来着，被一个律师函干下来了。现在也不知道怎么样了。 No.12（外传总No.442）游戏名：おっくまん 游戏类型：动作游戏 Produced by：ビット 又一个洛克人式动作游戏，阿空人，不过主角也可以选幽香。流程是把地灵殿的一伙干趴下，但是最终boss却不是地灵殿的人。版面简单的是真简单，难的是有点难，有的关长度确实长了点（自古四面……）。 No.13（外传总No.443）游戏名：東方文殿生存 Touhou Library Survivors 游戏类型：动作射击游戏 Produced by：Alexander Taylor 近期（但是也并不近了）上steam的一个车万肉鸽地牢游戏，不过这里面没有装备，只有各种技能搭配，说白了就是地牢、无双这些东西，和本期No.2很像，画风精良了点。不过这里也有他自己的特点，一个是升级系统，虽然也是几个选一个，但是这里被安排到了蜂窝格子中，每次出现的有技能和属性，技能就是能打出的那些攻击方式，最多6个，属性就是给人物加属性，或者对相邻技能添加属性，比如减少消耗啊增加技能等级啊之类。另一个特点就是会根据现实周几，他安排了不同的属性增加buff，比如周五玩就是上图的金属性技能伤害加10%。还有打小boss或大boss掉一些特殊道具，在主界面可以提升通用基础属性之类。 不过其实我最想吐槽的还是游戏名，“文殿”一眼看上去啥么高大上东西，一看英文知道了，哦，图书馆啊，感觉是不太懂东亚文化瞎装了。 No.14（外传总No.444）游戏名：東方平文録 游戏类型：动作游戏 Produced by： 还是悠遊亭的动作游戏，不过这个算是其早期对动作游戏的探索吧，各种意义上的做的不咋样，比如手感，比如画面。不过立绘画风倒是与现在比较接近了。 No.15（外传总No.445）游戏名：Yuuto Ichika’s One Time Wonder 游戏类型：动作游戏 Produced by：ChairGTables 原创角色进幻想乡的一个游戏，画风比较拉，手感判定也差了点，但是玩法还不错。最开始yuuto只能拿着石头油桶之类的东西扔出去砸小怪，获得技能书之后就可以按X发技能了，不过也是必须举着东西才能发技能。这边设定就比较有趣了，东西可以扔出去砸人，砸了仍然会留在场上（爆炸桶除外），伤害一般，也可以拿着来发技能，发技能后这个东西消失，技能会根据选择的不同技能来发，比如火焰弹、反弹盾之类，花里胡哨要根据场上情况来选。不过可惜的是并没有一些场合来约束具体用哪几种，我一个升满的火焰弹基本开头用到结尾。 No.16（外传总No.446）游戏名：シャンハイと謎の魔導書 游戏类型：动作游戏 Produced by： 大概是有些策略要素（？）的动作（？）游戏，就是小爱用人偶打怪，然后获得更多人偶循，这样循环。可以通过扔人偶或者“全军出击”去灭怪，但是“全军出击”会等待一会才放弹幕，而直接扔出去砸上去更快一些。灭怪之后可以让规定数量的人偶搬尸体回到家门口，就会生成等量的同种类人偶。或者搬运蛋糕也可以按蛋糕颜色生成人偶。基本人偶上海蓬莱伦敦根据游戏进度开放，特殊人偶大江户通过B获得，ゴリアテ通过收集蓝点获得，每天基本人偶总共可带100个出发。可以收集收集品，以及魔法书页，其他也没什么了。其实我比较想看大批人偶叽叽喳喳群殴一个怪的壮观场景，但是群殴是有，壮观一点也不。 No.17（外传总No.447）游戏名：東方変菓伝 ~ Highly Responsive to Pancakes 游戏类型：动作游戏 Produced by：Python 仿灵异传的游戏，仿的是游戏进行方式那种。普通关也是打砖块翻砖块那种，不过normal就已经有原作lunatic那种死尸弹了。比原作好的是不会被阴阳玉打死，阴阳玉射击扫御币都能打掉小弹幕，中玉大玉这类的就打不动了。boss关就都是新作那些角色了。还有两个模式一个是例关一个是无限，可以选择其他角色，当然扫的不是御币打出去的也不是阴阳玉了，而是有角色特色的奇怪东西。 No.18（外传总No.448）游戏名：RAIN Project - a touhou fangame 游戏类型：动作游戏 Produced by：Kirisame Jump 这可是老游戏了，大概算是第一二批上steam的东方同人游戏之一吧。游戏手感刚刚可以，但是操作确实反人类，上键是跳，攻击是点鼠标来攻击，朝哪点就朝哪攻击，而且是近战，在这游戏boss普遍多动症情况下还是挺吃亏的。因为很多up也做过各种测评了我就不多介绍了。 RAIN Project - a touhou fangamehttps://www.bilibili.com/read/cv1351639 No.19（外传总No.449）游戏名：東方皇桜記 游戏类型：动作游戏 Produced by：MOON GODDESS 又是那个MOON GODDESS出的游戏，这个画风应该算是标志性了。这个就是只有远程攻击手段的动作游戏，这些攻击方式基本就是从他们自己做的射击游戏里抄过来的，只不过削了频率提升了攻击力。当然他们的游戏一贯做的挺恶心的，这个也不例外，虽然远程但是不够远，攻击打出来有给自己的定身效果，boss跟你打stg你跟boss打act难躲难输出。只不过好像比起stg来这个要好打一些，毕竟我都能（续关）打通关。 No.20（外传总No.450）游戏名：東方無明剣 -Unorganized Heroes- 游戏类型：动作游戏 Produced by：INSIDE SYSTEM 一个普通又不太普通的动作游戏，基本流程也是打怪升级过关。不过这游戏有一个设定是一开始没法跳，从家里拿上下面这个环，中间镶上宝石（一开始自动镶一个），打怪给宝石升经验升等级才能习得跳跃。基本玩法也都是从这里延伸出来，升等可以加攻加防加血学技能，不同宝石经验不互通，但是获得的属性是一直保留的，所以拿到的新宝石升级会比较快，加很多属性。还有一个就是左下角有一个红色/绿色的条，是行动条，攻击一次消耗一点，跳跃一次消耗一点，放技能看技能消耗多少点，所以打玩起来是很受限制的，想快点跑图也就只能靠跑和走位，偶尔跳一下躲个怪这样。 莉莉白还是得看ばくP老师的画，pid=94387470 volantis.js(\"https://unpkg.com/pandown\").then(pandown)","categories":[{"name":"游戏","slug":"游戏","permalink":"https://neko-horikawaraiko.github.io/categories/%E6%B8%B8%E6%88%8F/"}],"tags":[{"name":"带你玩东方","slug":"带你玩东方","permalink":"https://neko-horikawaraiko.github.io/tags/%E5%B8%A6%E4%BD%A0%E7%8E%A9%E4%B8%9C%E6%96%B9/"}]},{"title":"【鼓哥】带你玩东方-外传（二十五）（其他游戏篇）","slug":"【鼓哥】带你玩东方-外传（二十五）（其他游戏篇）","date":"2023-01-14T19:22:22.000Z","updated":"2024-11-04T16:22:00.619Z","comments":true,"path":"2023/01/15/【鼓哥】带你玩东方-外传（二十五）（其他游戏篇）/","link":"","permalink":"https://neko-horikawaraiko.github.io/2023/01/15/%E3%80%90%E9%BC%93%E5%93%A5%E3%80%91%E5%B8%A6%E4%BD%A0%E7%8E%A9%E4%B8%9C%E6%96%B9-%E5%A4%96%E4%BC%A0%EF%BC%88%E4%BA%8C%E5%8D%81%E4%BA%94%EF%BC%89%EF%BC%88%E5%85%B6%E4%BB%96%E6%B8%B8%E6%88%8F%E7%AF%87%EF%BC%89/","excerpt":"","text":"大家好，这里是猫耳堀川雷鼓~ 这一篇文章就介绍一些各种各样其他类型的小游戏吧，因为这里面的一些类型的游戏个数比较少，所以这“其他游戏”就是打包介绍少数类的那些游戏。这里面的话No.13莲子恶搞梅莉，No.17种田，这俩游戏我觉得还是比较推荐试试的。 No.1（外传总No.411）游戏名：Sentimental Gensoukyou（センチメンタル幻想郷） 游戏类型：视觉小说 Produced by： 霖之助收到了一封信，写着「タイクツ」（我找了找意思是“无聊”？），然后就从里面读出有生命危险来了，然后就去幻想乡各处逛荡寻找这个发件人。（这忒扯了吧，怎么就有生命危险了） 然后，人没找到，却被各少女（bba）玩弄了。 No.2（外传总No.412）游戏名：東方チルノ戦車 游戏类型：射击游戏 Produced by：ウォルター連合 大概就是⑨开着战车去打小怪的游戏，不过当然不是去模拟坦克那种大游戏啦。抽象一下其实就是带着超大判定的⑨往天上发弹幕打妖精啊boss啊之类。因为判定大所以游戏设定己方弹幕可以抵消大部分地方弹幕，所以朝着敌人方向可劲射就行了。打怪会掉一些蓝点，可以给战车升级，加血加攻之类。 No.3（外传总No.413）游戏名：紅魔館へようこそ 游戏类型：视觉小说 Produced by：のるん♪ 普通的红魔馆的视觉小说，短故事集算是。 No.4（外传总No.414）游戏名：誰彼ダイアログ 游戏类型：视觉小说、解谜游戏 Produced by： 和之前的秘封碎片同一个社团的，也是在对话中选词然后进行游戏。不过不知道是因为还在体验版还是预设就这样了，这边的对话和要进行的解谜关系不大，直接给出几个报文，从里面选几个字组成引句，然后主游戏用。主游戏是一个词语联想类游戏，根据你选择的引句会划掉（变暗）下面标签中的几个，要求是使用规定数量内的引句，将所有绿色词条划去，引句用的越少评价越高，如果超过数量没划完，或者所有红色都划掉判定失败。 No.5（外传总No.415）游戏名：Touhou Mecha: Hell’s Rising 游戏类型：视觉小说 Produced by：Dai-Sukima Dan 大概讲的是地灵殿和Parsia在打仗，阿空为了扭转战局去获得八咫乌力量，但是还有另外的东西等待着她。整个系统偏机甲风，而且中间故事也有小动画，不和其他视觉小说似的一幅图完事，大概算是比较好的一点吧。 No.6（外传总No.416）游戏名：東方遊々蒐III 游戏类型：动作游戏 Produced by：猫扇風機 （手上没完整版就借一下别人的了） 小游戏合集，啥都可能出现。不过我没有完整版，就介绍其中两个吧（一共五个游戏）。 钓鱼小游戏，类似星露谷那种钓鱼感觉。不过钓上来的是角色人偶。有时候还会附带一些东西，可以当做饵料钓其他人偶，也可以在霖之助那合成新的鱼饵。钓上来的人偶摆满背景架子还是挺有意思的。 给uuz“节食”的小游戏，扮演妖梦从uuz嘴里把所有夜雀抢走，送回像左上角那一格的鸟窝里。如果uuz到了像左下角一样的门里游戏失败。uuz的ai智商一般，“幽口夺食”还是挺轻松的，就是这个路线稍微难走一点。 No.7（外传总No.417）游戏名：紅魔館の危機 游戏类型：视觉小说 Produced by：うわのそら （看不太懂就直接贴作者介绍吧） 突然有一天，蕾米倒下了，为了拯救蕾米，咲夜一个人前往幻想乡之外的洞窟。另一边，趁着咲夜和蕾米不在，紫跟随妖梦对红魔馆宣战。守备不足的红魔馆，孤立无援的咲夜，与前往救出咲夜的美铃。咲夜知道了，前方等待着的命运，自己的过去，红魔馆的真正历史，隐藏的过去现在被揭露了。而你看到的到底是真实的还是…… No.8（外传总No.418）游戏名：東方まみぞう 10ヘンゲームス 游戏类型：小游戏集合 Produced by：cvELD 一个猯藏为主角的小游戏集合，根据达到的总分数可以观看不同的ending故事。一共十个小游戏，有看发令提示拔刀斩那种反应力小游戏，图上这种剩一个可活动空间的拼图小游戏，规则有点奇怪自己去看看的塔防小游戏，根据对面行动迅速改变自己行动的石头剪刀布游戏，类似fc上打鸭子那种射击游戏等。 No.9（外传总No.419）游戏名：Typing Of Kyouko 游戏类型：教育游戏 Produced by：Icoreate 限制时间里按照罗马字打完给定词语的日语打字游戏。不过到这边我就走不下去了，一致在慧音这里打地名，不知道是有什么条件没达成。 No.10（外传总No.420）游戏名：ビギナー闘牌伝説コガサ 游戏类型：视觉小说+策略游戏 Produced by：M.A.L. 教人打麻将的视觉小说，讲的可真的细，每一部分之后也有这种实战练习。但是相对的也很长，而且毕竟是日文介绍，读起来还是不好读。 No.11（外传总No.421）游戏名：东方幽幻簿~Memories of the Flower. 游戏类型：视觉小说 Produced by：东方幽幻簿制作委员会 实际上吧……本来就是个小说，是作者 @小狐喜欢绿坝娘 的《风见幽香的幻想乡记事簿》，然后有个制作组就做成了这个游戏来玩。基本上是小说原文，有些地方有改动。不过后面的游戏已经鸽掉了（小说更完了），现在只有这个第一章的体验版。游戏作者现在似乎去新开了一个游戏《秘封异闻录》，但是更新也是三四年前了，网址见下方。 秘封异闻录 官方公式站 - RPSG制作组，提供娱乐解决方案http://shadow.rpsg.team/ No.12（外传总No.422）游戏名：ミスチーズ！ ～ナズと愉快な仲間たち～ 游戏类型：文字冒险游戏 Produced by：Icoreate 幻想乡的“オタカラ”（我认不出来这是个啥）消失了，然后又不知怎么的聚集到寅丸星身边了。纳兹琳为了查明事实真相就出去调查去了。（翻译的作者介绍，我确实还是看不懂日文小说） No.13（外传总No.423）游戏名：蓮子は可愛そうな夢見るマエリベリーの顔に落書きするのが楽しすぎる 游戏类型：动作游戏 Produced by：Slowbroski22, Ferdy’s Lab, Sorasu (Slascoplerd), HakanaiBlue 莲子在半夜给熟睡梅莉脸上画画的搞笑向反应力游戏。在梅莉醒来开灯之前在脸上光速涂鸦，没墨水注意补充，画到左边goal就赢了。途中有可能会有梦里的兔子跳出来砸醒梅莉，提前做一下预判。总之就是玩完了会心一笑那种。 No.14（外传总No.424）游戏名：东方万事屋 游戏类型：文字冒险、动作游戏 Produced by：崩坏一番工作室 国内某社团的早年作品，自从03年发布这一体验版之后再也没有更新过。游戏整体就是一部分的文字冒险+接委托形式的小游戏组成，就如同上面所示的一个接金币一个打地鼠。从画面看社团是想做出一个完成度很高的游戏的，就是不知道为啥鸽了。 No.15（外传总No.425）游戏名：東方紅恋菓 游戏类型：文字冒险、动作、解谜游戏 Produced by：かもぷろげくと 和上面那个形式差不多，也是视觉小说穿插小游戏类型的游戏，不过这个偏视觉小说方向多一点，小游戏都比较简单。 No.16（外传总No.426）游戏名：真説・月天永夜録 游戏类型：视觉小说 Produced by：融解エメノイル 画风不错的视觉小说，讲了蓬莱之药的诞生秘密与咲夜永琳之间的因缘关系，大概就是推测零设的那种故事。 No.17（外传总No.427）游戏名：幻想ガーデン物語 游戏类型：模拟经营游戏 Produced by： 幽香为主角的农场经营游戏，基本游戏方式上和星露谷差不多，都是种菜、养动物、买卖、挖矿、钓鱼、做物品/食物之类。这个游戏比较慢热，一开始没几个地方可以去，开新区域需要在已开区域里找某些角色对话来增加好感，然后到一定程度（而且好感度并不会看得到）就可以发现新区域了。而且比如改造房子也需要和山女对话获得好感，亲密度够了才答应给你盖房子。整体感觉上没有想象中那么好，有点只是套了个东方皮的农场经营游戏的感觉。kk那边也介绍过 No.18（外传总No.428）游戏名：Conveyance of Connection: Gensokyo Space Agency 游戏类型：模拟经营游戏 Produced by：MagpieTeahouse 大概，算是一种模拟经营……？故事背景是参考了儚月抄红魔馆一家造火箭的事，于是游戏成立了一个“斯卡雷特登月有限公司”，接造火箭的活。根据每天到来的订单，从不同的部件中凑出满足要求的，然后开始建造。建造倒是自动，要做的就是在建造的时候防卫火箭不要被别人破坏，破坏之后进度会掉。不过说实话这游戏也是太单薄了，一个是奖励和惩罚机制不明显，建造失败了也没什么问题，另一个就是内容太少，单一个其他啥也不能做的建造过程，其实挺无聊的。 No.19（外传总No.429）游戏名：妖精生活録 游戏类型：视觉小说 Produced by： 比起视觉小说来，我更愿意把它划为桌面宠物派。四个妖精都可以对话（有的地方也可以摸），但是只有一部分动作/对话会有回应。好其实是好在下面，这游戏用SpriteStudio做的live2D还是挺舒服的。 小虎牙可爱⑨ No.20（外传总No.430）游戏名：魔法少女ミラクル☆こちや / 魔法少女ミラクル☆こちや ~ Arcadia ~ 游戏类型：文字冒险游戏 Produced by：月光プロダクツ 这个是讲了早苗在进入幻想乡之前的高中故事，角色都是幻想乡角色的翻版（有的名字变了一点点有的没变），大概算是平行世界发生的故事那样。有好几条线可以攻略，算是一个gal了吧。 后面 ~ Arcadia ~ 版是在前一版基础上多加了几条人物线。 pid=62512175 volantis.js(\"https://unpkg.com/pandown\").then(pandown)","categories":[{"name":"游戏","slug":"游戏","permalink":"https://neko-horikawaraiko.github.io/categories/%E6%B8%B8%E6%88%8F/"}],"tags":[{"name":"带你玩东方","slug":"带你玩东方","permalink":"https://neko-horikawaraiko.github.io/tags/%E5%B8%A6%E4%BD%A0%E7%8E%A9%E4%B8%9C%E6%96%B9/"}]},{"title":"【鼓哥】带你玩东方-外传（二十四）（飞行射击游戏篇）","slug":"【鼓哥】带你玩东方-外传（二十四）（飞行射击游戏篇）","date":"2022-12-08T16:34:34.000Z","updated":"2024-11-04T16:21:53.915Z","comments":true,"path":"2022/12/09/【鼓哥】带你玩东方-外传（二十四）（飞行射击游戏篇）/","link":"","permalink":"https://neko-horikawaraiko.github.io/2022/12/09/%E3%80%90%E9%BC%93%E5%93%A5%E3%80%91%E5%B8%A6%E4%BD%A0%E7%8E%A9%E4%B8%9C%E6%96%B9-%E5%A4%96%E4%BC%A0%EF%BC%88%E4%BA%8C%E5%8D%81%E5%9B%9B%EF%BC%89%EF%BC%88%E9%A3%9E%E8%A1%8C%E5%B0%84%E5%87%BB%E6%B8%B8%E6%88%8F%E7%AF%87%EF%BC%89/","excerpt":"","text":"大家好啊，这里是猫耳堀川雷鼓~ 在憋了俩月之后，我终于又整出来一篇游戏介绍，这次是凑够了数的飞行射击游戏。其中大约有一半跟原作比较像，另一半是作者自制的或者不常见引擎之类做出来的，导致画面排布不一样甚至有些玩法都有变化。不过其中还是有一些比较简单可以轻松玩下去的，推荐尝试一番。而且不得不说，一个整洁优雅的标题画面更想让人有玩下去的冲动，比如下面的No.16。 No.1（外传总No.391）游戏名：東方猫場撃 游戏类型：飞行射击游戏 Produced by：礼門屋 用一个动作游戏引擎做的stg游戏，手感差了一些。有十来个自机可以选，先选一个主操自机，然后选一个放b时的自机。游戏内怪不太多，但是弹幕比较邪门，大概h难度吧，另外判定比较大，所以有些小缝钻不过去。自机在打死一定程度的怪（可能是按照数量和难度判定）之后可以积攒右上角蓝色能量条，每攒满一次自机弹幕升级一次，并增加1b，增加半格血量。在血量耗完之前打完一关就可以，下一关不继承。 No.2（外传总No.392）游戏名：Reimu Learns Time Travel 游戏类型：飞行射击游戏 Produced by：SongSing 挺奇怪的射击游戏，但是挺有意思。灵梦学会了时间倒流，然后和芙兰打弹幕战去了。在中弹时如果底部时间槽长度超过红色部分，就可以消耗时间槽发动时光倒流，回到中弹前位置。消耗多少槽长是根据按X键时间长短决定的。时间槽自然增长。但是时间槽在红色区域内中弹则game over。 No.3（外传总No.393）游戏名：Touhou 4: Lotus Land Story NES Demake 游戏类型：飞行射击游戏 Produced by： 还是那个做原作复刻的社团，具体见十五期No.17（外传总No.227）和十九期No.16（外传总No.306），这次是旧作第四作的复刻。这一作同样做的比较简单，L难也就有正作n往上一点点的程度。不过相比于旧作原作，这里因为改动了不少弹幕，所以简单了，而且也改动了出怪和掉落物。另外还出现了似乎是同屏物体溢出吞道具的现象，正常打有可能会少掉落。而且放b不会无敌，不是全屏清屏（以灵梦为例，魔理沙没试），b在miss后不会补充，boss时放b都不会显示bomb特效。而且有些关键东西没了，比如花妈的魔炮预警线。不过相比原作，还有一点好处就是低速更明显了，手感和原作相近程度吧。只能说是复刻的中游偏上了。 No.4（外传总No.394）游戏名：東方魔出現 〜 Devil’s Emergence 游戏类型：飞行射击游戏 Produced by：PatchMixolydic 一个还算挺有潜力的仿旧作stg。手感接近现代正作但还是有些欠缺，点阵图画风仿旧作（但是立绘并不），音乐算是arrange，并不算完全原创。目前只有一个单面demo，做下去的话应该会有意思。 No.5（外传总No.395）游戏名：矢田寺成美弾幕連 游戏类型：飞行射击游戏 Produced by：夢幻泡影リョウショウカカン ⑨打成美的弹幕游戏，算是挺还原原作但是又有比较新奇弹幕的一个游戏。这个作者另外还做了好几个这样的游戏，还有エタニティラルバ弾幕連、東方弾幕Infinity、フランドールスカーレット弾幕Infinity等，大概都是这样子进游戏直接开打。 No.6（外传总No.396）游戏名：东方拉比岛 游戏类型：飞行射击游戏 Produced by：MUA魔改组 从辉针城魔改而来的stg，借用了Rabi-Ribi角色，当然也继承了放b只有小段无敌且不消弹的特性（ No.7（外传总No.397）游戏名：白色景楽園 游戏类型：飞行射击游戏 Produced by：星空茶屋（RATTA 3/きみどり。） 横版的stg，背景故事基本与妖妖梦相同，操作也是stg传统按键。不过低速没有判定点显示。另外就是难度做的不好，normal的子弹都跑得飞快，初见杀还是有一些的。另一方面大概也是为了补偿难度这一点，掉落的奖残很多。而且如果左下power大于一格状态时可以发动自动雷，然后power会减到一格（龙隐谈也有类似功能），这时就需要自己手动放b了。 No.8（外传总No.398）游戏名：Touhou 5: Mystic Square NES Demake 游戏类型：飞行射击游戏 Produced by： 还是那个社团做出的旧作改版，同样的难度特别简单。其他几部可见前几期stg类游戏介绍的专栏，第四部是本篇No.3。没感觉错的话，这一作加入了boss阶段血条的不同颜色进行分割，就如同图上这样，有几个阶段就非常清楚了，但是感觉上boss血量就大幅下降了。 No.9（外传总No.399）游戏名：Touhou Scarlet Labyrinth 游戏类型：飞行射击游戏 Produced by：buskerdog 一个主攻击方式为飞行射击的闯关游戏，实在不知道怎么算就先算到stg了。说是闯关也就一个红魔馆大地图里到处探索探索完事。整个流程较短，可玩性还是有一点的。 No.10（外传总No.400）游戏名：あおぞらのチルノちゃん 游戏类型：飞行射击游戏 Produced by：星空茶屋（RATTA 3/きみどり。） 一个操作非常别扭的动作型（？）飞行射击游戏，就是操纵⑨、大、莉这几个妖精在空中跟敌人互打弹幕的游戏。自己可以射击，可以防御，长按防御可以蓄力蓄成sc发出去。敌人分波来，普通波也不是太难。不过操作反人类还是要说道说道，不是四方向键也不是wsad，而是空格/鼠标点一下往前方窜出去，方向是鼠标方向，但是还有转弯半径，所以走着走着就成了画圈了，搞得人非常晕。 No.11（外传总No.401）游戏名：东方花蝴蝶 游戏类型：飞行射击游戏 Produced by：生还绮想曲 这个……懂得都懂，不懂的我也不好说什么。顺便贴个全关视频 No.12（外传总No.402）游戏名：泰西Project 游戏类型：飞行射击游戏 Produced by：Akari、Laochailan、mia等 欧美那边仿官作用完全自写引擎做的stg，角色大部分也都是原作里面的角色。不过难度上要难一些，初见杀有一些。 No.13（外传总No.403）游戏名：東方陰陽葬～Spirits in Memetic Paradise 游戏类型：飞行射击游戏 Produced by：3Hu Waiting Room danmoko做的射击游戏（感觉西方人用unity的都用这个做stg），啥背景故事也懒得看了（，整个游戏说是虽然5面但是很长，不过我觉得长在写的对话上了，是真的长。该有的要素基本都有，不过打起来总觉得打到敌人身上没有实感（danmoko通病）。另外就是danmoko通有的，被打中原地复活，续关最多42次，不区分续关和不续关的分数之类（分数尾数不为0）的特点。 No.14（外传总No.404）游戏名：東方氷佺暴 ~ Rampage of the Strongest! 游戏类型：飞行射击游戏 Produced by：Kevin Mink (Kevinmonitor) 仿街机stg风的游戏，打起来确实挺爽也很简单，不过只有一关而且限时99秒，比谁的分高。倒是挺希望作者多做几关搞成正作样的完整游戏。（不过有一个露娜最终防卫线3也是类似的街机风stg，以前在专栏写过，那个游戏的话难度可能就是真有点普通的正统街机stg难度了吧） No.15（外传总No.405）游戏名：半魂武芸帖 游戏类型：飞行射击游戏 Produced by： 故事是妖梦突然和半灵互换（互换灵魂？）了，然后需要操纵本体来进行练习，应对其他人汹涌的攻势。主要鼠标操作，来进行射击、斩击，平时通过练习获得经验，升级射击斩击这些技能的能力参数，或者血量之类的状态，然后去打boss。就这样循环着挑过所有boss。整个游戏有些难，但是比较推荐上手游玩。（作者认为这是个stg，我就放在这边了，虽然我觉得更像是act） No.16（外传总No.406）游戏名：Little Heroine Playset 游戏类型：飞行射击游戏 Produced by：Team Shanghai Hourai 一个单关小品游戏，game jam的参赛作品。两个人偶高速射击模式还比较接近于正常stg的射击模式，上海人偶低速是一种无限远窄扇形的全范围伤害，蓬莱人偶低速则是类似妖梦的蓄力，但是距离非常短，很不好用。画面不错，就是弹幕稍微单调了点。 No.17（外传总No.407）游戏名：동방화귀전（東方火鬼傳） 游戏类型：飞行射击游戏 Produced by： 韩国车万人做的射击游戏。年代比较久远，不过演出效果放在当时看还是有点惊艳的。有几关是横版有几关竖版，对于只熟悉一种方向的玩家来说打起来比较难受。有点缺点比如高低速自机弹幕形式一样的散射，想换成集中弹需要换人（毕竟高低速不同弹幕形式是车万游戏标配，而不是通过换人来换弹幕，yyc除外）。有些音效还是有些违和感的，其他方面一般。前作是外妖傳，在之前的专栏写到过。 No.18（外传总No.408）游戏名：東方風魔録～ The Story of Eastern Wind 游戏类型：飞行射击游戏 Produced by：Helios Create 封魔录的重置版，但是比原版感觉难了一点。原版的三种配置改成了三个角色，但是配置对应一样。关底boss好像除了魅魔都改成了新作（6及以后）的角色贴图，弹幕形式基本没变。不过说起来整个弹幕形式变化都不大，但确实感觉比2un原作难。 No.19（外传总No.409）游戏名：東方撃煉記 游戏类型：飞行射击游戏 Produced by：MOON GODDESS 普普通通的stg，就是自机弹幕和魂斗罗一样要打掉小飞碟吃道具才能换，一挂就恢复单列冲锋枪那种模式。可以无限续关，但是自机是哪种弹幕对通关影响还是比较大的，比如图上这种三way弹幕我就觉得更好打一些。 No.20（外传总No.410）游戏名：東方妖精郷～Trifling Fairy Wars～ 游戏类型：飞行射击游戏 Produced by：香坂全 相当早年的一个stg了，不知道是也为了表现“以妖精的视角看弹幕比一般的要多”还是咋，难度比正作同等相对高一点点。另外一方面也是手感原因，感觉比正作要滑一些，而且判定比较严，以及几乎没有决死时间，这些也导致了游戏变难。 pid=84693142 本来想放麻吕太老师的大大大橙图，但是想了想可能放不出来就还是换了吧 volantis.js(\"https://unpkg.com/pandown\").then(pandown)","categories":[{"name":"游戏","slug":"游戏","permalink":"https://neko-horikawaraiko.github.io/categories/%E6%B8%B8%E6%88%8F/"}],"tags":[{"name":"带你玩东方","slug":"带你玩东方","permalink":"https://neko-horikawaraiko.github.io/tags/%E5%B8%A6%E4%BD%A0%E7%8E%A9%E4%B8%9C%E6%96%B9/"}]},{"title":"【鼓哥】带你玩东方-外传（二十三）（动作游戏篇）","slug":"【鼓哥】带你玩东方-外传（二十三）（动作游戏篇）","date":"2022-10-11T15:45:58.000Z","updated":"2024-11-04T16:21:44.178Z","comments":true,"path":"2022/10/11/【鼓哥】带你玩东方-外传（二十三）（动作游戏篇）/","link":"","permalink":"https://neko-horikawaraiko.github.io/2022/10/11/%E3%80%90%E9%BC%93%E5%93%A5%E3%80%91%E5%B8%A6%E4%BD%A0%E7%8E%A9%E4%B8%9C%E6%96%B9-%E5%A4%96%E4%BC%A0%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%89%EF%BC%89%EF%BC%88%E5%8A%A8%E4%BD%9C%E6%B8%B8%E6%88%8F%E7%AF%87%EF%BC%89/","excerpt":"","text":"大家好啊，这里是猫耳堀川雷鼓~ 时隔不久我又发新专栏了，这次是动作游戏，2d和3d的都有一些。专栏的话我挑的是相对不怎么好玩的游戏写进来（真不好玩的我写都不写），所以有些也就看乐呵就行，自己上手很脑溢血。还是那句话，有看上的游戏可以留言或私信跟我要，我会找时间把能发的都发出来。 （专栏经常集中发的原因就是，要凑够数量我才发一篇，某几类游戏挺容易在相近时间凑满个数，所以偶尔就几天之内连发几篇） No.1（外传总No.371）游戏名：東方ディアブロ トレジャーハンターG 游戏类型：动作游戏 Produced by：紅緑亭 名字起的挺吸引人，但是实际玩起来达不到预期。简单来说就是一个几乎纯鼠标操作的动作游戏，移动靠鼠标位置与当前位置拉出的引导线方向，左键攻击，右键格挡，滚轮翻滚，空格打开菜单更换装备之类，机制非常简单。而且攻击硬直很大。不过看在是2012年的游戏的份上也还算可以了。 No.2（外传总No.372）游戏名：東方戦騎譚 ～ DrunkTankies Battle in the Eastern 游戏类型：动作+弹幕射击游戏 Produced by： 大概可以双人玩的一个动作弹幕游戏，游戏机制还是有点意思的。目标就是尽可能少用人地去消灭地图上所有怪，或者全员到达地图中魔法阵处。如果被打了每个人物只有一次机会，被打了就需要下一个人物来救，而且要救到魔法阵里才可以在下一关中继续使用，否则下一关这个人物就没了。即使救了人，消灭了全部的怪，但是没把人送到传送阵，这个人下一关也是没了。有一些关中会有新角色加入，在地图上等救，和前面的救人方式一样。如果救人的人死了，那被救的直接消失。 但是问题来了，游戏中弹幕有的时候会很密，尤其是boss战，自机弹幕通常的打击范围非常小/近，然后就只能非常近去打怪，就更容易死，直接死循环难过关。自机移动速度只有慢速，虽然不同机体速度有点差别，但是仍然不好躲弹幕。每个人物只有一次放b机会，用掉了就再也不补充了。加起来就打的非常恶心。 No.3（外传总No.373）游戏名：幻想の狼 游戏类型：动作游戏 Produced by： 不管从那个方面都仿照《战场之狼》的游戏——标题上，音乐上，地图布置上，都有原作的影子。当然，难度也有原作的影子，只是路上的敌人看起来要少一点点的样子。除了将像素画风转为3D建模之外也没啥别的优势，打过原作的应该上手也不会太难通关，没打多的话就…… No.4（外传总No.374）游戏名：⑨快跑 ~ BakaRun 游戏类型：动作游戏 Produced by：八霧游戏制作组 类似于神庙逃亡的跑酷游戏，左右控制方向，空格跳跃，看起来是类似地铁跑酷的三分道路，实际上并不是，而是可以水平随意的。激光之力吃p点增长，打出去会持续一段时间，用来破坏弹幕的，不过范围比较窄，每次miss会power减半。前三关比较正常，第四关终点前会自动加干劲然后回跑，不过如果这个时候miss到重开本关会出bug，在拐弯的地方没法拐。（左右键控制水平移动不控制拐弯，拐弯是自动拐的，bug导致没法自动拐） No.5（外传总No.375）游戏名：ぞろぞろぞふぃ 游戏类型：动作游戏 Produced by：（オートリ電子/特殊装甲隊） 这个社团的另一个“ぞろぞろ”作品，感觉比前一个要难一点，前一个见外传四No.2（总No.31）。这个作品是自己一个人（看宣传图好像支持双打）去打，没有另一作的帮手（虽然阿燐的大招是招幽灵帮手但是招的不多），而且行动速度也很慢，和小怪/boss根本拉不开多少差距，而且大部分射击距离非常短攻击力不高，同时被敌人打到的话扣血很多，导致整个游戏过程都在绕圈磨血条，非常难受。 No.6（外传总No.376）游戏名：てゐの奇天烈な探検、てゐの奇妙な冒険 游戏类型：动作游戏 Produced by：ルート 前几期中介绍的那个好几个卡牌游戏作者的前期作品。操作上感觉慢悠悠的，而且难度有点没把握住。游戏整体就是普通的打怪过关，掺杂了一点打怪升级要素，可以提升hpmp，mp就是射击子弹要用的。不同子弹可以在一些关卡里捡到更换，还有一些饰品也可以捡，增加一些特殊属性之类。有一个优点就是至少画面上这种子弹可以与敌弹互相抵消（“至少”是因为我打不到后面关拿不到其他子弹类型），不过缺点就有点多了，一个是前面说的难度，以及手感比较糙，一大关内被打死也不是从小关重开，而是直接回家重新开始。 和上面几乎同样的游戏，不过这一作要比那个简单，子弹也舒服得多。想玩的话这一作倒是可以体验一下。 No.7（外传总No.377）游戏名：剣客綺麗伝 游戏类型：动作游戏 Produced by：正経同人、漫桜椛ゲーム研究所 整体上是一个披着act皮的rpg感觉的一个游戏。主要操作就是操纵椛以及后面会加入的一些人物来打怪，普攻、吃药需要等上边自己头像那边蓝条走到头才能打，防御倒是不必须到头但是会减少蓝条。左下角技能CD满了就可以发动。防御有个难受的地方是要预判，但是大部分情况来不及，一个是从怪闪烁要打你到打出来时间比较短，另一个是看到闪烁再防御会防不出来，而且防御减伤减的也不多，总之鸡肋（。 No.8（外传总No.378）游戏名：東方反逆劇 游戏类型：动作游戏 Produced by： 一个挺有意思的动作游戏，推荐爽玩一会。主要目标就是通过自己的两种武器将关卡全部敌人消灭掉。有些弹幕要素，但是基本不需要躲也不好躲，在同时消灭多个敌人时会有HP补充自动飞向你，另外也要注意体术。每个普通关会出现3只莉莉白，按消灭的个数获得P点，自己的两个武器在消耗不同P点的一群武器中挑选，有近战和远程，消耗的p点数不能超过总共获得的P点数。普通关后期小怪血都特别厚而且经常成群出现，一般也就选大威力群攻武器来通关。boss关单列出来，达到一定P点才可挑战，不过打过了没啥奖励，就是开放下一个boss。 No.9（外传总No.379）游戏名：Desperation of Alcoholic Dream 游戏类型：动作游戏 Produced by：Ocean Dreams 萃香主角的动作游戏，打打打就是了。小怪掉落的P点补血，蓝点补魔，每次耗费一个魔点可以放一次远程的符卡，打小怪自然增长的last spell可以放一个全屏大伤害的符卡。不过判定都挺难受的，而且有些关有解谜要素，不过是不告诉怎么解，而是要自己发现那种。 No.10（外传总No.380）游戏名：That’s How Sumireko’s Roach Stomping Mafia Works! 游戏类型：动作游戏 Produced by：ChairGTables 堇子去帮助莉格露的一个跳跃游戏，但是为啥是要踩着各种虫子才能到达终点（。主要操作就是跳和冲刺，在地上跳起来，在空中根据方向键再跳就是冲刺，但是只能冲刺一次。碰到虫子时虫子可以爆炸然后把堇子弹起来，这时候冲刺也重置了可以再来冲刺。通过这两种操作最后到达终点，并在最后一关打败boss。倒是有种蔚蓝感觉。另外音乐不错。 No.11（外传总No.381）游戏名：東方宝嬌旅 游戏类型：动作游戏 Produced by： 故事背景是咲夜和铃仙看到永琳调出来两种药，一种让那里变大了，便偷走了另外一种，结果另一种让那里变小了。为了恢复原来的高度，永琳让咲夜去找三种药材来制药。不过这个找三种药材的过程比较曲折，整个游戏难度有些高，因为受击判定比较奇怪所以不好打怪，而且最开始只有四格命，被打一下掉一格。不过中间有存档点可以存，但是不自带恢复血量效果。很容易打着打着打不下去了。 No.12（外传总No.382）游戏名：Touhou Madness Wrath 游戏类型：动作游戏 Produced by：Prolophis （似乎以前写过类似的游戏）大概是某个清关格斗类型的引擎吧，做出来的游戏，就那种街机三国志风味。然后贴图换成东方人物这样。就是有些技能不知道怎么按（，没有说明只有按键。 No.13（外传总No.383）游戏名：東方爛漫華 游戏类型：动作游戏 Produced by：白玉しょこらいふ 幽幽子零食被偷了与找犯人的一个游戏，横版act。uuz可以对一些特殊物品实行特殊行动（形式“开花”）获得一点资源，还可以放蝶弹攻击。中规中矩的一个游戏吧，没太有特点，但是操作不咋舒服。 No.14（外传总No.384）游戏名：東方偽異伝 游戏类型：动作游戏 Produced by：（未知） 仿灵异传的红魔乡重置，总之就是挺奇怪的，不过能玩（。 No.15（外传总No.385）游戏名：I wanna make it breaking out 游戏类型：动作游戏 Produced by：水鳥＆carua 就放一个标题界面吧，我个人是打不过，具体内容可以从下面视频看一看。说是以前难度为90的游戏。东方元素主要在boss战。 另外，其他iw只有一点点东方要素的往后就不列出了（我也没去收集），这类iw还是蛮多的。 No.16（外传总No.386）游戏名：東方迷怪洞 紅 游戏类型：动作游戏 Produced by：MOON GODDESS 不得不说，游戏真的觉得做的挺“迷”的。普通的闯关式动作游戏，补给略少差评，检查点数量一般，操作顺滑度一般，画风还比较有特点的。不过有一些地方刺和地面一个隔一个，被打进去的被扎后摇特长，操作不了，然后直接一套扎死，非常恶心。 No.17（外传总No.387）游戏名：お面紛失！？ こころの幻想郷旅 游戏类型：动作游戏 Produced by： 非常有野心的一个游戏，但是做的确实不够好。“野心”是指对标了《Rabi-Ribi》。整个画风、UI设计都是向着那个方向做的，但是手感做的确实不行，UI也搞得看起来有点点廉价，难度做的有点呲。总之……加把劲吧…… 不过插一嘴，仿Rabi比较像的还有个《咸鱼喵喵》，大概有七八成神似。 No.18（外传总No.388）游戏名：爱丽丝的冒险 游戏类型：动作游戏 Produced by：酒之雀 站内老哥自做的爱丽丝主角动作游戏，轻微解谜要素，完成度还不错，文案有些部分挺有意思。具体可看作者本人视频。 No.19（外传总No.389）游戏名：東方エクスプローラー 游戏类型：动作游戏 Produced by：にじいろひつじ 为找寻魔法材料而踏上旅途的魔理沙和爱丽丝的一个ARPG，就是普普通通到处打怪，收集道具升级，增加自己的敏、攻、体、智四维。碰撞判定做的很实在，墙角拐弯打不到就是打不到，被好几个小怪堵死就是光速去世。不过看这游戏可以双打，可以俩人试一下。 No.20（外传总No.390）游戏名：東方天爛舞 游戏类型：动作游戏 Produced by： 3d地面格斗游戏，画面做的花里胡哨，不过感觉打起来很傻（。当然也可以放符卡，右下角所示三个，有人被打就会出P点，吃P点累积符卡的技能槽。 pid=66165271 volantis.js(\"https://unpkg.com/pandown\").then(pandown)","categories":[{"name":"游戏","slug":"游戏","permalink":"https://neko-horikawaraiko.github.io/categories/%E6%B8%B8%E6%88%8F/"}],"tags":[{"name":"带你玩东方","slug":"带你玩东方","permalink":"https://neko-horikawaraiko.github.io/tags/%E5%B8%A6%E4%BD%A0%E7%8E%A9%E4%B8%9C%E6%96%B9/"}]},{"title":"【鼓哥】带你玩东方-外传（二十二）（解谜、策略游戏篇）","slug":"【鼓哥】带你玩东方-外传（二十二）（解谜、策略游戏篇）","date":"2022-10-09T16:12:37.000Z","updated":"2024-11-04T16:21:35.778Z","comments":true,"path":"2022/10/10/【鼓哥】带你玩东方-外传（二十二）（解谜、策略游戏篇）/","link":"","permalink":"https://neko-horikawaraiko.github.io/2022/10/10/%E3%80%90%E9%BC%93%E5%93%A5%E3%80%91%E5%B8%A6%E4%BD%A0%E7%8E%A9%E4%B8%9C%E6%96%B9-%E5%A4%96%E4%BC%A0%EF%BC%88%E4%BA%8C%E5%8D%81%E4%BA%8C%EF%BC%89%EF%BC%88%E8%A7%A3%E8%B0%9C%E3%80%81%E7%AD%96%E7%95%A5%E6%B8%B8%E6%88%8F%E7%AF%87%EF%BC%89/","excerpt":"","text":"大家好啊，这里是猫耳堀川雷鼓~ 经过了老长时间的憋，终于又憋出来一篇专栏。这一期仍然是是策略益智类游戏混搭，又一波脑力大考验，来看看这一期都有些什么游戏吧。 No.1（外传总No.351）游戏名：ゆっくりスイーパー 游戏类型：解谜游戏 Produced by： 披着视觉小说外衣的扫雷游戏。视觉小说部分比较少，相当于剧情吧，不提了。扫雷倒是有点意思，不过意思也就意思在是多层扫雷套起来上了。点击数字会转到相应层上的扫雷棋盘，点到炸弹也是。棋盘上p和s相当于残、雷碎片，攒满一个p顶上加一个油库里，攒满一个b可以放符卡，“点”就只是加分。每将一层雷排掉直接加1p。目标就是油库里被压到左边之前清完所有雷，或者速度快的话直接压到右边也可以。 No.2（外传总No.352）游戏名：宵闇大戦 ミリオンルーミア 游戏类型：策略角色扮演游戏 Produced by： 也是一个火纹类型的srpg，不过特点是主角敌人（暂时）都是露米娅，可以说是究极露米娅厨了，不知道完成版会不会有其他角色。打赢了获得经验，然后升级角色，每一级一个技能点数，可以在skill的多个方向里选择一个加。 No.3（外传总No.353）游戏名：妖精大星航 游戏类型：解谜游戏 Produced by： 大妖精通过各种道具到达星星房间的策略游戏。与普通策略不同的是，这个游戏需要分析房间之间的墙是怎么连接的，因为游戏中有个道具可以让房间移动，反映在右下角map上就是一行或一列整体移动一格。因此需要观察当前房间与其他房间交界处的墙是怎么安排的。房间周围标X号地方就是周围房间的墙，标〇号就是和周围房间可以在这个地方连通。在得到移动房间道具之后这些标注可能就会改变，因为相连的房间发生了变化。除了这个道具之外其他的就是比如加速、高跳、本房间旋转90度等，做的挺有意思。 No.4（外传总No.354）游戏名：TouhouMino 游戏类型：解谜游戏 Produced by：Québec Games 东方版本的俄罗斯方块，加入了给玩家造成干扰的符卡系统，自己也可以放符卡辅助清行，还有收卡加分之类。 No.5（外传总No.355）游戏名：すごろくフェアリーズ 游戏类型：策略游戏 Produced by：ルート 一个地图比较简单的聚会图版游戏，地图上事件也是根据东方有一定的设计。不过掷骰子不是普通地扔，而是要去打一个弹幕出去，打到哪个数字就走几步，而且根据人物不同骰子也有不同的数字范围。 No.6（外传总No.356）游戏名：幻想郷史紀 游戏类型：策略游戏 Produced by： 算是……融合怪？大概就是战国那类题材的战术策略方式加上战棋的策略。大地图上进行比如据点之间的移动啊、探索啊、拉人啊、收集啊、防御啊之类操作，增加己方的资源量，进入战斗小地图之后就是战棋那一套，每个人有一定的移动回数和攻击回数，移动的每一回有一定步数，一次动一格，地图上格子标了移动到这一格消耗的步数（没标就是消耗1）。每回开始选择攻击时的卡片，卡片对攻击时的普攻和符卡伤害有加成，以及减少对方打过来时自身的扣血（精神）量，精神为0则减一个残机。术符需要在大地图上炼符才能获得，然后才能发动符卡。每种攻击也有攻击范围设定，大地图查看角色详情时或者战斗中都可以查看。 No.7（外传总No.357）游戏名：ぐるぐるすいか 游戏类型：策略游戏 Produced by：&lt;br 有点小编程策略味道的策略类游戏，通过给出一串指令来控制萃香移动，获得“绿茶”和“金币”。每次给出的指令最大是一串四个，萃香会按照给出的顺序进行这一轮的动作。一共有charge、move、jump、roll四种，charge可以给另外三种蓄力，move就是往前（右）动一次，大概是一格半左右，普通jump跳起五格左右，roll就是滚动，与跳跃或者前进搭配来破坏一些砖块。指令给出后会有一段时间判定期，判定输入完之后才会执行这些指令，已经给出的指令也可以在判定前退掉。当然一路上可不平坦，有刺球、吹风、传送带、无底坑之类的障碍，有时候还得把握好给出指令的时机，毕竟有可能需要在运动中给出下一轮指令。 No.8（外传总No.358）游戏名：ムラサのブロックパズル 游戏类型：解谜游戏 Produced by：DDBY 村纱船长主角的推箱子，不过还有点区别。地上中间是带数字的石头，可以推动格数就是上边的数字数，冰块样子的东西就是要推的箱子，推到黄色机关上。需要压住的机关数量在类似于左上角挡路的黄块上写着，完成后会自动打开拿到钥匙通过关卡。特殊点在于，要推的是“冰块”，所以一推就会到底，想在中间停住就要靠别的砖块来挡住。 No.9（外传总No.359）游戏名：東方地雷原 游戏类型：解谜游戏 Produced by：ろくしー（LOX++） 故事梗概：幻想乡在某一天会到处产生地雷变成雷区。百年一遇的“雷区日”到来，为了寻找只有这一天才能得到的宝藏，爱丽丝看着像往常一样跑出来的灵梦和魔理沙……（啊哈哈哈哈哈？） 听名字应该就会有点猜想，但是这么猜还是对的，本游戏就是扫雷（。所有操作和扫雷完全一样。另外本游戏居然有多人ip对战模式，多人中角色可以使用能力给对方制造麻烦或者给自己加成。（我运行游戏专门跑去装了个日文版winxp，估计也没多少人会去找这个麻烦） No.10（外传总No.360）游戏名：不夜麻雀 -The Eternally Scarlet Young Moon- 游戏类型：策略游戏 Produced by：しょうが焼定食、いろは 普通日麻的规则，不过打起来好像不用断幺九也不会无役，其他特殊说明可以在说明书里查看。作者网页里（http://maru9.saikyou.biz/butu.html）还有这一作的前代，flash版本黑白色的不夜麻雀，不过当然因为现在只能用特殊方法运行了flash才能玩了。 No.11（外传总No.361）游戏名：すわとく！ 游戏类型：解谜游戏 Produced by：ゆず菌繁殖 这游戏是个推箱子+“吃箱子”类型解谜游戏。估计是诹访子看到路上被冻起来的青蛙了，于是前去解救。不过路面“比较滑”，一走就是走到头或者碰到障碍物才停。所以需要用冻起来的青蛙、路上的柱子之类作为辅助，把关卡中所有青蛙回收。有些谜题还是稍微烧脑，推荐想玩还是找时间比较充足时候玩。 No.12（外传总No.362）游戏名：セイブ・ザ・フォックス 游戏类型：策略游戏 Produced by： 这游戏的大概游戏方式在画面右上角已经写好了，就是挑三张牌比大小的游戏。速度快的先攻，“速”比对方的“狙”大很多就躲开，大10之内就判定擦弹，然后会加比较多的sp，互相造成的伤害就是“攻”的大小。sp到30就可以发动符卡。整体还是有些难度的，一个是有回合数限制，另一个是并不知道对方会用啥卡牌，不好打。 No.13（外传总No.363）游戏名：東方果物録～とうほうふるーつろっく～ 游戏类型：解谜游戏 Produced by：ほわいとふれあ（46flare） 通过三消推进故事的游戏。基本操作就是三消，累计一定连续成功消除后会出现符卡，随便往一个方向交换就可以释放符卡，己方消除一些东西或者给对方造障碍。普通消除过程有时候掉下来萝卜，萝卜不能通过配对消除，只能是周围其他东西消除的时候附带清掉。还有毛玉，毛玉在场时，如果配对没消除任何一个毛玉，就会增加一个毛玉。而且下面能量条空了时候会从下往上变三行萝卜。总之就是对快消、精准度要求比较高，失误一多基本就救不回来了。 No.14（外传总No.364）游戏名：Grimoir of Alice 游戏类型：解谜游戏 Produced by：CopperChihuahua 相应pdf里页面 介绍这个游戏倒不是说多好玩，但是是一种游戏设计思路。这个游戏附带了一个pdf文件，就是爱丽丝的魔法书，里面有一个能力或者说明，在游戏中获得了一些线索或者说需要什么东西，可能就要来书里找。游戏和其他附带文件相互推进确实挺新奇的。其他类似的还有《邪恶铭刻》读取硬盘做卡牌、《文字游戏》输出文档来画图之类。 No.15（外传总No.365）游戏名：とある天女の螺旋穿孔 游戏类型：解谜游戏 Produced by：Black Rock ONE 其实看这个界面有些人就明白了是个什么游戏了。可以算是一种特殊“消消乐”吧。故事大概发生在19追击天子（？，19操控钻头破坏砖块，就这么一直向下钻越远越好（。钻的时候没有支撑的上方砖块就会落下来，如果被压死了就-1残机。落下的砖块会在碰到相同颜色的砖块时附着，粘住之后连起来的砖块数&gt;=4也能消除。随着时间和钻砖块会消耗“电力值”，如画面上的电力胶囊吃掉可恢复一些，电力=0也会掉残。 No.16（外传总No.366）游戏名：IZAYOI RAILWAYS 十六夜電気鉄道 游戏类型：策略游戏 Produced by： 实际上是个大富翁游戏，按照设定的月数来控制游戏时长。地图上红点直接扣钱，蓝点加钱，黄点抽符卡，绿点买卖符卡，房子地点在每一局开始时候随机抽选做目的地。另外在房子地点可以买店铺，类似大富翁的“盖房子”（不过好像没有过路费）。另外外围有机场可以用更少的步数走到地图另一头。尽量就是更快而且用恰好的步数到达目的地，可以获得很多资金，慢的一方会有小恶魔骚扰，大部分都在情况扣钱。整个游戏在大富翁基础上做了点改动，还是比较有意思的。 No.17（外传总No.367）游戏名：UFO! 嫁と! 结婚させてくれ! 游戏类型：解谜游戏 Produced by： 有点像桌上冰壶的一个游戏。每个UFO带有一个词句，打击UFO到对面底线来完成词句收集，如果收集的一个或两个三个词句可以连成有意义的一句话就能对对方造成伤害。UFO从上面绿圈出来，如果不想要可以打到下面紫圈弃掉。小五可以耗费下面粉色圆点那个能量槽3点来使用读心术，一段时间内能看到每个UFO带的词句。在时间到达前谁剩余血量多谁获胜，或者直接把对方打没血获胜。 No.18（外传总No.368）游戏名：東方プロジェクトVSネコバズーカ 游戏类型：策略游戏 Produced by：礼門屋 哎……日语苦手+战棋游戏苦手真的是玩不下去啊 无能为力了，想玩的玩家可以试一试。不过这个战棋有个小特点（大概），每次总行动条结束都会涨经验，所以可能会遇到一边打一边升级的情况。但是血是不会给你回满的） No.19（外传总No.369）游戏名：言霊遊戯 椛筆譚（ことだまゆうぎ もみぴったん） 游戏类型：解谜游戏 Produced by：角煮餅 反正不是那些游戏啊动漫里的言灵那么牛逼的东西，这个言灵只是一个普通的填字游戏。除了左侧字格每个白字只能用一次、红字无限次之外，还有右侧的关卡达成要求。每关会给你先摆好几个假名，然后自己在其他地方填，凑够右面的要求过关。必须每次填入的假名和已经存在的假名在从上到下或者从左到右方向构成一个词才可以填入。不过这个游戏的单词库很丰富，有些关卡瞎填也能过，但是真要到硬核一点的关就只能看个人日语水平了。 No.20（外传总No.370）游戏名：東方ちぇむぶれむ 游戏类型：策略角色扮演游戏 Produced by： 标题借鉴了火焰纹章，所以也就是以橙为主角的普通的类火焰纹章的战棋游戏。风味还算正宗，难度不太好评价（毕竟我苦手）。 头图不放眼镜哥的蕾米是我觉得根本放不出来（ pid=41854224 volantis.js(\"https://unpkg.com/pandown\").then(pandown)","categories":[{"name":"游戏","slug":"游戏","permalink":"https://neko-horikawaraiko.github.io/categories/%E6%B8%B8%E6%88%8F/"}],"tags":[{"name":"带你玩东方","slug":"带你玩东方","permalink":"https://neko-horikawaraiko.github.io/tags/%E5%B8%A6%E4%BD%A0%E7%8E%A9%E4%B8%9C%E6%96%B9/"}]},{"title":"【鼓哥】带你玩东方-外传（二十一）（动作游戏篇）","slug":"【鼓哥】带你玩东方-外传（二十一）（动作游戏篇）","date":"2022-05-13T15:25:42.000Z","updated":"2024-11-04T16:25:02.739Z","comments":true,"path":"2022/05/13/【鼓哥】带你玩东方-外传（二十一）（动作游戏篇）/","link":"","permalink":"https://neko-horikawaraiko.github.io/2022/05/13/%E3%80%90%E9%BC%93%E5%93%A5%E3%80%91%E5%B8%A6%E4%BD%A0%E7%8E%A9%E4%B8%9C%E6%96%B9-%E5%A4%96%E4%BC%A0%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%80%EF%BC%89%EF%BC%88%E5%8A%A8%E4%BD%9C%E6%B8%B8%E6%88%8F%E7%AF%87%EF%BC%89/","excerpt":"","text":"大家好，这里是猫耳堀川雷鼓~ 隔了几周，我又来更新专栏了，这次是动作游戏篇。不过这一篇也是拖了好久，终于憋出来了，期间因为不想玩游戏所以也没打游戏素材这样。这一次的文章里也有一些比较有趣的游戏，比如2、5、6、9、16之类，想玩的可以找来尝试一下。 No.1（外传总No.331）游戏名：フェアリーゲーム 游戏类型：动作游戏 Produced by： 一个三月精主角的动作（？）解谜（？）游戏。三月精被文文忽悠的准备去红魔馆搞大新闻，趁着美铃睡觉潜入进去，然后在红魔馆迷宫（？）到处探索寻找出口这么个游戏。路上有妖精女仆阻拦并打你，要么互刚要么跑路，还有一些地形杀或者障碍物，以及临时技能隐身之类可以用。以当时技术来看建模还不错，不过操作手感还是差了点。 No.2（外传总No.332）游戏名：IBUKI 伊吹 游戏类型：动作游戏 Produced by：Mark Li, Prismriver Orchestra 一个萃香主角的动作小游戏，手感比较不错，画风也有意思，就像上图。打来打去跟灵梦打了一架，然后灵梦就同意萃香自己探索这个世界了，剧情就这样比较扯。流程挺短，也比较简单，毕竟打怪死后爆出来的血道具可以回血。 想看实际打起来怎么样的话，游戏视频的话站内有好几个，我也就不贴了，搜游戏名就搜得到。 No.3（外传总No.333）游戏名：ゆっくり飛行玉 ～Fragile Ball Adventure～ 游戏类型：动作游戏 Produced by：LOG BOX 现在看来，这个游戏副标题起名是真的准（。 游戏就是操纵一个非常fragile（易碎的）的油库里球从起点飘到终点（就是那个旋涡状的地方），不过既然是个游戏就不会给你这么舒服。游戏有重力效应，也就是不动就会自己往下掉，可以按上键来飘起来，左右就是控制左右方向飘，但是这个按键是给的一个加速度，按的时间越长终速度就越快，要保证稳定性还得左右稍稍按一下这样来控制。画面还有各种元素比如墙啊，要按顺序碰的数字（来打开终点前的墙）啊之类，油库里的判定就是中间一个蓝色圆，判定区不能碰到墙之类的，否则就“碎了”，重来。玩这游戏还是比较容易血压升高的（。 No.4（外传总No.334）游戏名：ナズの宝塔探し 游戏类型：动作游戏 Produced by：康友いえんし 其实看到右边那几个刺就知道这是啥类型的游戏了——I wanna。剩下的就不多介绍了。不过这个游戏似乎手感差了点，有点吞按键。 No.5（外传总No.335）游戏名：きのコン！ ～Defend my sweet home!～ 游戏类型：动作游戏 Produced by：～Alice Margatroid Project～ 一个小爱打扫屋子内的蘑菇的小游戏。普攻就是挥扫帚打扫大概半圈的蘑菇，还可以消耗半管魔力放人偶炸弹炸一大片。不同的蘑菇有不同的特性，有到处乱跑的和方放毒雾的，小爱碰到毒雾会咳嗽一阵（不能动），打蘑菇会掉落一些道具，就是六边形那个，红色加魔力，黄色加移速，紫色变大可以直接踩死蘑菇且不怕毒雾。就是在规定时间里多打倒蘑菇就好，蘑菇覆盖率到100%失败。 No.6（外传总No.336）游戏名：Mikobuster 游戏类型：动作游戏 Produced by： 一个阿空为主角的3D类洛克人游戏，有道中和boss两部分。阿空有蓄力和冲刺，还可以在空中冲刺（水平飞行），不过连续飞的太多会飞行器过热强制停下，而且没有滑铲。boss是多段血条，类似原作有非符和符卡阶段，非符比较脆，符卡有的需要一些解谜，有的还是需要一般的反应力。不过社团已经停止开发了。 No.7（外传总No.337）游戏名：幻想郷どかすかウォーズ 游戏类型：动作游戏 Produced by：紅緑亭 3D对战类的动作游戏。四个人俩俩一组跟对方对战，基本技能就是飞行攻击射击，想办法把对面的心数打没就是了，有一个人丢一条命心数就-1。一个人的话就加3个cpu呗，不过似乎被cpu带着飞的可能性比较大（。建模在上个世代，不过音乐不错。 No.8（外传总No.338）游戏名：Castlemaze～お嬢様からの挑戦～ 游戏类型：动作游戏 Produced by： 仿恶魔城的动作游戏，所以仿过来了挺多东西，尤其是难度，我基本玩不下去（。和原作类似，也是碰几下就死。按键灵敏度有点小问题，比如从梯子上跳有时候跳得远而大部分跳的近之类。 No.9（外传总No.339）游戏名：巫女と吸血鬼 游戏类型：动作游戏 Produced by：kt住江 画风类似热血系列，玩法类似双截龙的一个游戏。主线可选角色是博丽巫女（先代？）和蕾咪，然后去打人（。还有ex篇，加了几个自机，难度上升不少。详细玩法可以看下面这个视频。 No.10（外传总No.340）游戏名：カラクリニトリ / カラクリニトリ弐 ~ Extend Mechanic Walts ~ 游戏类型：动作游戏 Produced by：絶望リンカエラー 荷取主角的动作游戏，依靠各种道具消灭路上的敌人，爬到山顶。不过毕竟是荷取，道具种类还是挺多的，有水枪弹簧勾爪等，地形跑路一流。不过攻击稍微难受一些，子弹判定很小，按键也需要调整。 No.11（外传总No.341）游戏名：早苗の信仰王への道 游戏类型：动作游戏 Produced by：みちるーむ 守矢神社布教故事的动作游戏。早苗和两神去别的地方建神社布教，毛玉和妖精还有boss会阻止他们布教，坚持到右侧绿条满了算是成功，两神的血量空就GG。早苗可以普攻，可以用小技能风吹走+打伤怪，还可以在积攒能量条满之后全屏必杀大招（但是对boss是掉一格血）。还有的策略就是用身体来挡怪的弹幕，毕竟早苗挂了可以重生，两神血条没了就过关失败了。完成度还可以，就是3D建模的脸有些奇怪。 No.12（外传总No.342）游戏名：Touhou: Hollow Hearts 游戏类型：动作游戏 Produced by：Yal 姆q和秦心一同寻找古代造物“失落情感的面具”的动作游戏。整个游戏偏阴暗风，毕竟要迎合“失落遗迹”主题。操作上稍微有些硬。操作角色按tab互换，秦心近战，姆q远程（耗费一定量魔法，黄色那个），不过远程也没远到整个屏幕。可以往上往下攻击，不过打出来是斜方向。流程挺长，各处有一些生命碎片和魔法碎片，攒够数量可以合成一个提高血/魔法上限。存档点比较少，但是作者给了一个比较折中的功能——可以就地回满血，回血过程中不能被攻击。难度稍微有一点，不算太高。 No.13（外传总No.343）游戏名：チルノくんの脇役最強伝説 游戏类型：动作游戏 Produced by： 仿热血格斗的一款对战格斗游戏，支持多人。选项界面全是平假名，改键和开始让我找了好一会。最大8人游戏，剩下的用电脑补全。不过电脑的技术不错，想拿第一还是有点难的。 No.14（外传总No.344）游戏名：チルノすてっぷ 游戏类型：动作游戏 Produced by：ZNP ⑨主角的小游戏。说是动作游戏实际上也只有⑨下台阶这么一个动作，避开路上的障碍到达最下方。目的就是在右上角时限之内到达最下，被路上障碍打到的话会晕一小会，根据连续不碰障碍的台阶数和用时计算等级（然而等级也没啥大用）。到最下之后会见到一些角色，几关连起来可以算是一个默片小故事。 No.15（外传总No.345）游戏名：Touhou Shooter (Sakuya Flying Adventure) 游戏类型：动作游戏 Produced by：Prolophis 一个小爽游，相当于心绮楼这样的飞行格斗，但又不怎么格斗，基本上就是上下漂浮+平a小连招。画面上时不时出现点加血的加命的加分的道具，吃就是了。另外就是这些ai还有点赖，一起来好几个有远程有近程，近程耗着你，远程就不停的放波。每关底有个boss，伤害比较高一套连招能十割那种。不过你也可以赖，比如清完小兵然后连招连boss，因为敌人没有霸体和受伤无敌之类的特性，走个位连招就是了。不过自己的二阶平a硬直有点大，容易被小兵赖死。 No.16（外传总No.346）游戏名：ゲンソウフロードフロント 游戏类型：动作、解谜游戏 Produced by：FriendNavy 一个荷取的解谜动作闯关类游戏。荷取只有上下左右和跳（水里为冲刺）、射击这几个动作，通过这些操作来到达火箭处，以及收集齿轮（收集品，可不要）。射出来的泡泡可以踩着跳，可以包住妖精，也可以贴在冰上冻住当做地面用。不过每次只能有一个泡泡在关卡中，冻住的泡泡似乎最多是5个。通过这几种机制，还有让妖精来踩开关等来通关。有boss战，boss战还是挺难的。总的来说挺推荐试试，按键手感也不错。 No.17（外传总No.347）游戏名：紅魔PANG! 游戏类型：动作游戏 Produced by： 一个很像灵异传的游戏，但是并不是，而是PANG系列（一译：泡泡兄弟）的游戏。实际上阴阳玉只是要素，主要目的是小恶魔发射那个白线一样的……算是激光吧，要把阴阳玉打穿（阴阳玉碰到就算打穿），然后打到消失为止。 No.18（外传总No.348）游戏名：寿司VSレミリア・スカーレット 游戏类型：动作游戏 Produced by：ぱらどっと 一个接东西类型的小游戏吧，鼠标控制蕾咪吃掉寿司食材，不让食材漏到左边，红色外轮廓的东西可以漏过去，而且吃掉的话会暂时动不了。上方速度条满了可以按空格加速，当然食材的掉落速度也会加速。 No.19（外传总No.349）游戏名：東方輝羅星 游戏类型：动作游戏 Produced by：the MDY 一个类似于魂斗罗的游戏，照着魂斗罗打就是了。不过也融合了东方的一些特点，比如可以放b，比如武器升级靠p点。判定还是全身判定。可以切换人物，但是共享命数，不共享武器升级。有些地方怪设置的比较恶心，直接放b清掉好了。还有一个比原版魂斗罗多出来的特点是，可以像赤影战士之类的一样挂在一些水平横条上。 No.20（外传总No.350）游戏名：Yuyuko of the Netherworld 游戏类型：动作游戏 Produced by：Evil_Nazgul0616 仿卡比初代的游戏，操作起来比较生硬。uuz只能吃小怪、黄色星星砖之类的东西，然后变成弹幕打出去，左下角深蓝色圆点就表示可以打出去的子弹数量。当然也可以吃回血道具、假名道具之类的就不说了。 pid=56738239 volantis.js(\"https://unpkg.com/pandown\").then(pandown)","categories":[{"name":"游戏","slug":"游戏","permalink":"https://neko-horikawaraiko.github.io/categories/%E6%B8%B8%E6%88%8F/"}],"tags":[{"name":"带你玩东方","slug":"带你玩东方","permalink":"https://neko-horikawaraiko.github.io/tags/%E5%B8%A6%E4%BD%A0%E7%8E%A9%E4%B8%9C%E6%96%B9/"}]},{"title":"【鼓哥】带你玩东方-外传（二十）（解谜、策略游戏篇）","slug":"【鼓哥】带你玩东方-外传（二十）（解谜、策略游戏篇）","date":"2022-04-15T18:54:15.000Z","updated":"2024-11-04T16:21:25.452Z","comments":true,"path":"2022/04/16/【鼓哥】带你玩东方-外传（二十）（解谜、策略游戏篇）/","link":"","permalink":"https://neko-horikawaraiko.github.io/2022/04/16/%E3%80%90%E9%BC%93%E5%93%A5%E3%80%91%E5%B8%A6%E4%BD%A0%E7%8E%A9%E4%B8%9C%E6%96%B9-%E5%A4%96%E4%BC%A0%EF%BC%88%E4%BA%8C%E5%8D%81%EF%BC%89%EF%BC%88%E8%A7%A3%E8%B0%9C%E3%80%81%E7%AD%96%E7%95%A5%E6%B8%B8%E6%88%8F%E7%AF%87%EF%BC%89/","excerpt":"","text":"大家好，这里是猫耳堀川雷鼓~ 这次呢，就不废话啥了，毕竟前几天刚发了一篇专栏。这篇文章主要介绍一些解谜/益智/策略游戏，也就是要费点脑子来玩的游戏。卡牌游戏较多，可能游戏比较好做吧（。有的游戏已经上架steam，也有很多听名字不知道干啥的游戏。来认识认识这些游戏吧~ No.1（外传总No.311）游戏名：うのとれ！ 游戏类型：策略游戏 Produced by：ルート 带卡片能力的uno牌。每个卡片有数字和颜色，有的可以多种颜色，就可以接好几种颜色的牌下去，每张卡也有技能，有的是打出发动，有的是下一个人打出时发动。自机也有技能，可以在轮到自己时发动，比如灵梦技能就是使场上现存的所有效果消除，但是自机技能只能用一次。 No.2（外传总No.312）游戏名：東方神医伝 游戏类型：解谜游戏 Produced by：夏季限定 首先，这个社团确实叫这个名（ 游戏算是一种消消乐，这边是四个及以上的相同色块（“药”）放在一起，然后再按键消除，就算是配药了，会将左边的条消一段。bgm挺有玛丽医生的味的（不过只有一小段）。需要在一定时间内（约3分钟，readme里这样说的）配好药，也就是左边的条到底，而且不让这些色块灌满瓶子，算是过关，否则病人就病倒了（。实际上有点点难，难在时间有点短，配不完药然后暴毙。 No.3（外传总No.313）游戏名：I.⑨ – Intelligent Fool 游戏类型：解谜游戏 Produced by： 感觉和以前做的视频里那个叫東方書斎宮的游戏有点像，都是方方块块的，不过实际上一点也不像。 这游戏是⑨在地上放地雷，操纵地雷爆炸然后把砖块炸碎。绿色砖炸碎之后会在地上生成一个特殊炸弹（一炸九格），也是遥控爆炸。不过黑砖不能炸，炸了之后底下的路会在最远处掉下去一排。每次滚过来几排砖，把白的绿的砖都炸掉，黑砖自己滚下去之后，算是这一小道谜底成功解决，底下的路会在最远处加上一排。如果有白的绿的掉下去那路会掉下两排。⑨掉下路去或者不够谜题所需排数了，就game over。其实难就难在理解游戏目的上，理解了游戏还是挺简单的。 No.4（外传总No.314）游戏名：東方殺 游戏类型：策略游戏 Produced by：Moligaloo（游戏引擎），（东方mod未知） 某个仿三国杀客户端的改造版本，改成了东方角色（其实这个客户端也是玩家自己写的，非官方）。可以自定义卡牌，大概也可以联机对战。不过还是符斗祭更方便一点…… No.5（外传总No.315）游戏名：東方パズルだ全員集合？～弾は落ちても人気は落とすな～ 游戏类型：解谜游戏 Produced by：萃符合同企画 一个噗哟噗哟类的策略游戏，大概是fever玩法。基本玩法就是除了灰色的毛玉，其他颜色的有四个及以上连起来就可以消除，掉下来毛玉还能消除的连锁，通过消除来抵消对方攻击的相杀，大概意思可以参照百度百科的噗哟噗哟玩法。 No.6（外传总No.316）游戏名：東方スピード 游戏类型：解谜游戏 Produced by：天宮照雲 一个简单的问答游戏，从中间框中选出与右下角人物两侧道具中，完全相同的一个，或者颜色和道具种类全都不同的一个。 这么简单的游戏有什么写的必要吗？有，因为这是用PPT做的，画面上左下角我截图截出来了。正常流程结束后其实会提示有一个特殊角色有没有发现，不过毕竟是ppt，找一下就能发现是哪个特殊角色。 （根据要求放上作者主页https://amaterasu-creation.amebaownd.com/） No.7（外传总No.317）游戏名：A witch of memories 游戏类型：解谜游戏 Produced by：カジュアルゲームズ 姆q为主角的恐怖解谜游戏，虽然说恐怖但是相比其他恐怖游戏来还算温和点。说实话玩了一通也不知道目标是什么，暂时可以当做一个逃脱密室来玩。在不同的房间寻找钥匙和特殊物品来触发事件，跟人偶赛跑逃避被杀（姆q一辈子运动量.jpg）。画风是纸人系风格，也算不错。 No.8（外传总No.318）游戏名：ゴーストライターはたてちゃん 游戏类型：解谜游戏 Produced by：mizusoba（いすぃ） 文文被上司拉去陪酒了，说着“不能辜负读者的期待的”，把果果拉来帮忙写报纸了。这游戏将就是这样果果寻找流言素材写新闻的游戏。首先先去人间之里搜寻各种流言到素材库中，流言有分类A、B、C、二军（二军不能做文章素材用，但是可以做组合用），可以将两个不同的素材组合一下看看有什么新素材能发现，新的素材也会进入素材库。然后组合ABC各一条素材，有些有联系的就可以写出文章来，给文文看。文文会给选出来的三条新闻评分，平均分大于三颗星，这些新闻就可以发表成报纸了，文章也不能再使用了。 不过毕竟是日文，有日文基础的话玩起来还可以。目标就是写出一些抓人眼球的离谱报道，才能得到文文青睐（不愧是文文新闻）。 No.9（外传总No.319）游戏名：（未定名） 游戏类型：策略游戏 Produced by：Empty Earth Exit 应该是一个挺传统的卡牌玩法，就是右上角的四个数字，打在右边位置上，如果有一个方向的数字比相应方向对方卡牌大，就能把对方卡牌翻过来成为自己的颜色，最后比较谁的颜色的卡牌多就获胜了。 No.10（外传总No.320）游戏名：story of a lost sky 游戏类型：策略游戏 Produced by：Feathered Melody 紫妹、uuz一起消失，妖梦、蓝妈、橙喵组队找大人，正巧碰上了妖怪发狂的故事。普通的战棋套路，不过加了一点点特殊机制——灵魂充能（spirit charge，SC）。SC基础值300，技能命中时会增加这个SC槽，未命中降低SC，槽值700以上增加伤害和暴击率，200以下时降低。实际打起来命中率还是不错的。每个人有几个符卡，与通常一样有技能使用次数，战斗结束后恢复。不过我确实不太会战棋，也就没啥其他评价了。 No.11（外传总No.321）游戏名：东方虹龙牌 游戏类型：策略游戏 Produced by：我是游戏迷hh 站内老哥根据虹龙洞卡片的想法自做的游戏，规则类似日麻，不过是凑成三个顺子或刻子就结束，相应的牌山也很小。另外牌山中会有两种特殊卡片，使用了会有特殊效果。 No.12（外传总No.322）游戏名：東方タクティクス 游戏类型：策略游戏 Produced by：しそそふと 系统比较简单的战棋类游戏。不过和其他不同的是，每个人有最多两格行动距离，和一次攻击机会，移动时敌我双方同时移动，所以有时候技能距离不足就会打不到。画面做的不错，还可以联机对战。 No.13（外传总No.323）游戏名：波乱盤外！？香霖堂！～第弐章～ 游戏类型：策略游戏 Produced by：ルート 之前香霖堂卡牌游戏的续集版本，详情可以看之前的专栏外传十四No.19（总No.209）的介绍。 No.14（外传总No.324）游戏名：東方碰雀牌 游戏类型：策略游戏 Produced by： 以麻将为原型的棋牌类游戏，起手8张牌，做出三个刻子获胜。不过有些特殊牌型会增加获胜点数，比如下图所示的几种形式。其他的倒是没啥说的，也没有啥超能力） No.15（外传总No.325）游戏名：たすけて！おつかれさとり様 游戏类型：解谜游戏 Produced by：mizusoba（いすぃ） 小五因为过度劳累读心能力不太行了，然后阿空又忘事了来找小五读心，结果当然是读不出来啦。没办法，只能按照问答来想起来是什么东西了。根据每一关的大方向和问出的问题得到的答案来猜测是什么东西。猜出来了就可以右下角回答了，当然需要用日语写出来。每隔一段时间小五可以使用一次读心，可以把之前问过的问题再确认一遍（如果觉得哪个有问题的话），阿空可能会改答案，改过的就确实是对的了。 补：2022.3.8游戏上架steam，有中文翻译，回答问题的时候也有标准答案列表了，避免了多种答案都可以的时候被判定回答错。 No.16（外传总No.326）游戏名：Shrine of the Miko Dancer 游戏类型：解谜游戏 Produced by：Enalye, Automn’, Mrnuage, JonathKane 这游戏是一个Touhou Game Jam 2的参赛作品。跨过关卡中各种阻碍，目标是前往图中的隙间格。但是游戏机制有个要求，可以看到右上角会有一个按键图，有一个变成灰色。机制就是每个按键只能连续按1次，wsad射击、上下左右走路方向、空格放炸弹，灰色就是之前按下的那个键，通过合理安排操作慢慢前进就是了），但是初接触不能连续朝一个方向移动会很难受。 No.17（外传总No.327）游戏名：暇を持て余したレミリアの遊び 游戏类型：策略游戏 Produced by：ルート ルート的又一个卡牌游戏，按照level顺序双方一人一张。排上有些特殊效果倒是可以打破这个规则。谁先把手牌出完就算赢，每次谁没接上就需要在牌山中摸一张。 No.18（外传总No.328）游戏名：幻想創縁結界 游戏类型：策略游戏 Produced by：ちびっこ娘々 一个比较麻烦又比较简单的塔防+即时战略游戏。麻烦是指这个游戏需要双线操作，左边是自己的大本营，要建造防卫塔防住敌人。敌人出现的位置不确定，而且伤害很高，所以尽量升级塔快速打死。右边是敌方大本营，需要类似即时战略一样选择己方士兵设法打掉敌人老巢。防卫塔打倒敌人或者己方士兵打倒对方防卫塔，会获得左下角的“巫”点，巫用来买塔、升塔、买兵。右边阴阳玉是随时间恢复的能量，可以发动对入侵敌人的全体攻击，或者来侦查敌方布阵，不过老巢是侦查不到的，需要士兵打到了才显现。简单是指实际上防御和进攻两个部分都做的比较轻松，有很长时间空闲期，可以交替操作。 No.19（外传总No.329）游戏名：依姫めくり 游戏类型：策略游戏 Produced by：ルート 反正是一个比较奇怪规则的卡牌游戏吧。就是从牌堆里抽卡，然后谁先抽到依姬并且不死谁获胜。每个人各自有一个牌堆，牌堆里可以抽出来道具卡、人物卡、事件卡，人物卡对己方BP值造成上面显示的红字点数的伤害，卡面上也会有一些能力会在抽卡时或前后发动，卡面的相应exp值下面再说。道具卡可以在获得后使用，或者有些在手中时会自动发动。事件卡即时生效。 每一回合抽卡次数不限，但是每次抽到人物卡都会即时造成BP值伤害，不到0时可以通过“ストップ”结束，此时回收所有翻开的道具卡，计算所有人物卡的exp值加到自己上，每10点升级Lv；但是BP到了0及以下的话所有翻开的卡全部作废。 达到一定Lv会开放“スペル”符卡的使用，可以作为辅助，每一回合各可以使用一次。达到Lv7之后有一定几率翻到依姬卡，如果此时BP值足够依姬的攻击——100，则获胜。 No.20（外传总No.330）游戏名：霧雨農園 游戏类型：策略游戏 Produced by： 一个种田与塔防相结合的游戏，但是塔防占比要大一点。因为魔理沙把红魔馆炸了，所以蕾咪让魔理沙攒100w来修房子。游戏主体和一般塔防一样，但是只能在每块地的中间建塔——稻草人，周围是土地来种东西，保护的就是周围这些作物。通过种菜然后卖给香霖堂或者交付村民和永远亭的委托可以拿钱，攒钱到100w。右上角时间里每天魔理沙可以进行两次行动，可以去森林平原之类的地方探索，可以带回作物（种子）来，也可以去交付委托，或者去香霖堂卖菜，去博丽神社和灵梦闹一闹。香霖堂里不仅可以卖东西，也可以买一些奇怪东西，在行动中也可以选择这些东西进行研究，造出新防御塔；或者升级防御塔能力。尽量快攒够钱吧，时间拖得越长越难打。不过失败判定挺有意思的，就是作物里有食用蘑菇，如果魔理沙行动完了回家的时候种的地里没有蘑菇，则宣告失败。 pid=3004325 volantis.js(\"https://unpkg.com/pandown\").then(pandown)","categories":[{"name":"游戏","slug":"游戏","permalink":"https://neko-horikawaraiko.github.io/categories/%E6%B8%B8%E6%88%8F/"}],"tags":[{"name":"带你玩东方","slug":"带你玩东方","permalink":"https://neko-horikawaraiko.github.io/tags/%E5%B8%A6%E4%BD%A0%E7%8E%A9%E4%B8%9C%E6%96%B9/"}]},{"title":"【鼓哥】带你玩东方-外传（十九）（飞行射击游戏篇）","slug":"【鼓哥】带你玩东方-外传（十九）（飞行射击游戏篇）","date":"2022-04-12T16:26:30.000Z","updated":"2024-11-04T16:25:06.083Z","comments":true,"path":"2022/04/13/【鼓哥】带你玩东方-外传（十九）（飞行射击游戏篇）/","link":"","permalink":"https://neko-horikawaraiko.github.io/2022/04/13/%E3%80%90%E9%BC%93%E5%93%A5%E3%80%91%E5%B8%A6%E4%BD%A0%E7%8E%A9%E4%B8%9C%E6%96%B9-%E5%A4%96%E4%BC%A0%EF%BC%88%E5%8D%81%E4%B9%9D%EF%BC%89%EF%BC%88%E9%A3%9E%E8%A1%8C%E5%B0%84%E5%87%BB%E6%B8%B8%E6%88%8F%E7%AF%87%EF%BC%89/","excerpt":"","text":"大家好啊，这里是猫耳堀川雷鼓~ 好久（在专栏里）不见。最近确实因为个人事情没有探索什么新游戏，而且游戏玩起来真的觉得好累啊，于是摆了。在隔了好几个月之后终于够了一篇新的游戏介绍，来看看有哪些熟悉不熟悉的作品吧~ No.1（外传总No.291）游戏名：チルノの東方紅防記 游戏类型：飞行射击游戏 Produced by：MOON GODDESS 一个挺难的小游戏，⑨和蕾咪达成了XX交易，需要保卫红魔馆不被妖精侵袭。普通子弹是扔小冰块，可以上下前三方向扔，来打掉妖精；打爆飞碟或者有时候飘来一些特殊子弹，吃了可以切换到那种子弹上发射特殊弹幕（当然特殊的都是有限的）。有时候后面会出来大妖精帮你打一点，但是⑨碰到大妖精的子弹也会被打中（。红魔馆耐久最多30，也就是放30个小妖精进去，但是过关的话耐久不恢复，掉到0就game over了。 No.2（外传总No.292）游戏名：HOWLING COMMUNICATION 游戏类型：飞行射击游戏 Produced by：tboddy 这是一个tougou game jam 3比赛作品，一个非常小型的stg，两个模式2min和4min，限时看最高分。2min就两次道中两次boss，4min大约相当于2min的加强版，道中基本是加强，boss却有一些新的弹幕。 No.3（外传总No.293）游戏名：伝説のホワイトカラス 游戏类型：飞行射击游戏 Produced by：弾幕魔術師リモネン 超难的一个弹幕游戏。自机有好几个角色可以选，主线与赫卡打，附加线与作者自创角色打。不过不管是哪条线都很难，敌机血量20w超高，normal都能赶得上正作lunatic。为了降低难度作者做了一套道具系统，在设置中可以启用，启用后会对结束评分有影响。道具有几十种，可以在作者给的文档里查看详细说明。可以看下面的视频了解难度（ No.4（外传总No.294）游戏名：東方妖精譚 游戏类型：飞行射击游戏 Produced by：アピー 一个三月精为主角的射击游戏，可选人物就是三月精之一。为了“解决异变”去跟各种妖怪啊灵梦啊打了一场，实际上还是去玩的。画风上真的不咋地，而且有些出怪方式比较恶心，打不到就被对面弹幕糊脸了。唯一有特点的是有一个三人模式，不是三个人玩，而是选一个妖精作为主控，另外两个也上场的模式，就像上面最后一个图。另外两只会根据控制模式有不同表现，“自由奔放”就是乱打，但是也是主要找有敌人的位置去打；“绝对信赖”就是和主控妖精贴在一块，相当于加攻了，打啥都快；“玉碎觉悟”就是纯追着敌人打，也会引掉自机狙，让主控较为安全。三人模式下，非主控两只妖精也不是完全高级智能，也会撞弹，不过呆一会就会在原地复活。 No.5（外传总No.295）游戏名：カリスマを取り戻せ 游戏类型：飞行射击游戏 Produced by：Hello World! 首先吐槽一下社团名） 这是个威严扫地机找回威严的stg，打着打着就可以变回本来样子了。作为stg的话，道中小妖精的弹幕速度比较快，密度倒不大，boss稍微正常点。移动速度高速很快，低速偏快，也没有打击感，算是中规中矩但是和原作有点差的stg。 No.6（外传总No.296）游戏名：Thunder Faith 游戏类型：飞行射击游戏 Produced by：幽々燦々（ゆゆさんさん） 一款仿Thunder Force V代的横版stg，主角早苗。可以切换射击方式来攻关，左下角显示当前射击配置，从左到右是双发（实际就是普通直线）、后射、波浪（广范围）、自由（夹角激光+5方向）、追踪，按住另一个按键（默认X）可以发动这几个射击方式的over weapon模式，变成激光、后3way激光、旋转广范围、追踪方向直线激光、快速高威力追踪（实际也不如其他的火力高）。一般射击游戏的道中关底模式，不过贴图挺像格斗作的点阵搞下来的（。射击方式不好把控（标准按键只能按顺序切换，高级按键则每种射击方式（不包括over weapon）对应一个按键按不过来）。而且也不是东方stg那种一个按键切换高低速只有两个速度那种，这里是速度调整键，按一下会调整画面上方的移动速度speed，有四档速度，切换起来比较麻烦。前几关弹幕还可以，但是后面特别恶心，追踪激光特别多，而且速度很快拐弯也很急，非常容易暴毙，初见杀也非常多。不过另一个特点是子机可以消掉一部分子弹，子机在不射击或者消弹时会增加回复量，使用over weapon会消耗这个量，子机颜色降到红色时射击的power也会变低，补回绿色或者蓝色才可以恢复射击power。 No.7（外传总No.297）游戏名：幻想武勇传 ～ 儚月抄 游戏类型：飞行射击游戏 Produced by：幻想乡弹幕旅行社 老游戏了，可能当年挺多人会熟悉这个游戏，六神做的。 故事背景与儚月抄有关，是地上人登上月球后第二次月面战争的故事，表月线自机是Reisen，和主角群打；里月线自机是妖精女仆，和依姬打。不过估计又是巨硬的什么显卡设置bug，我没法稳帧，下面视频是没掉帧的完整流程。 No.8（外传总No.298）游戏名：幻想追憶夢 ～ Lost Memory Regeneration 游戏类型：飞行射击游戏 Produced by： 灵梦忽然失忆，但是还记得自己工作是消灭妖怪，于是看到一个妖怪从空中经过就追了上去要揍一顿（路过妖怪：我好苦啊）。移动速度比正作稍微慢了一点，另外没有决死，没有续关。蓝点奖残，不过其他资源给的比较抠。难度上完全没做好，至少我看了看e和n差距不大。音乐挺有特点，不是东方风。 No.9（外传总No.299）游戏名：束方 嘘時空 ～ Fools_rush_in 游戏类型：飞行射击游戏 Produced by： JynX仿旧作放出来的唯一作品（虽然确实和那几个仿旧作的视频也有所区别就是了）。仍然是对战stg，不过与梦时空或者花映塚机制稍微有区别。获胜条件不是把对方压死了，而是跑中间的进度条，打道中这些小怪时会增加进度条，而被子弹打到会后退，遇到boss或者对方送过来的boss就会暂停，进度条满遇到本关终boss也就是对方，打过一个非符一个符卡结束。所以策略基本就是别撞弹，多给对面送boss（C4）拖对面进度条，各个boss快打。 No.10（外传总No.300）游戏名：東方七色郷+ 游戏类型：飞行射击游戏 Produced by：人形機械論 一个仿怪绮谈ex萝莉丝攻击方式（作者称）的stg，不过看这贴图是新作爱丽丝啊（。自机魔理沙有三种攻击方式，直线、扩散/狙、贯通激光，ZXC键切换，高速低速有的攻击方式会变化。下面现在绿色红色的块块是生命值，绿色当前，红色已经失去，还有蓝色是相当于“残机”。攻击恢复下面的一个能量槽，根据攻击方式不同可以发动不同的能量攻击（相当于bomb），不过是按A键。难度还算正常，就是有几个小地方会初见杀。 （作者说東方七色郷（不带加号）这游戏之前免费供开过，但是我怎么也找不着……） No.11（外传总No.301）游戏名：魔法少女ルーミアNANOKA 游戏类型：飞行射击游戏 Produced by： 之前直播的时候玩过这个社团的一个迷宫rpg，那个游戏性是在有点差所以就没写，叫《魔法少女 東方大飢饉》。和这个游戏一样，立绘画师画的不错，挺可爱一画风，但是游戏拉胯。这游戏横版stg，这些小人绘比立绘要低一个档次。操作手感大致还可以，不过道中比较瞎，敌人子弹和有一些不太好辨认。自机高速是直线连发，低速如上图是小角度散弹加上扔“小碗炸弹”，火力槽右上角，火力低的时候炸弹和散弹就没了。 No.12（外传总No.302）游戏名：SUiCA32 游戏类型：飞行射击游戏 Produced by： 一个看起来挺正常实际上不咋好玩的射击游戏。就是操纵自机灵梦打这些无数的萃香分身，无尽的那种游戏。打死一个加点分；被打死会放b，这时候清掉的敌人分数会多一点，命数减少到1的时候或者增加的时候自机弹幕形式都会有变化，不过其他弹幕形式大部分都打起来不舒服。 No.13（外传总No.303）游戏名：Cirno Gets Clever 游戏类型：飞行射击游戏 Produced by：yoship1639 一个像素风的横版飞行射击游戏，⑨主角，故事是收集别人的IQ（草，什么奇怪的故事背景）。游戏和正作操作一样，没有难度区分，难度大概是h到l左右，没有机体选择。用IQ来提升属性，IQ是每一个阶段打完会总结一下并获得一些IQ，就相当于钱，本关重开和续关都要耗费IQ，关前增加能力点也要耗费越来越多IQ，也可以买残和b。弹幕的话挺多仿原作的。 No.14（外传总No.304）游戏名：みすちーの交通事故 游戏类型：飞行射击游戏 Produced by： 一个小型的射击（算是stg吗？）游戏。操控夜雀打败早苗。早苗有几段弹幕，还会召唤一些毛玉来打你。夜雀只能蓄力然后把身边的小夜雀发射出去打怪。小夜雀那一团黑的范围可以挡弹幕挡激光，用这个机制来通过一些不可能的弹幕，然后尽快把早苗干掉就是了。 No.15（外传总No.305）游戏名：東方八華閃 游戏类型：飞行射击游戏 Produced by：LIMIT CYCLE 俯视角的3D飞行射击游戏。可以八方向移动，也可以八方向射击。不过移动速度固定，而且挺快，判定点全身，很容易撞弹。一关内no miss no bomb会奖励一个b，不过关卡挺短，打得稳健一点可以拿得到。每几关会有一次boss战，随机一个boss来打你，弹幕是官作stg的改编，很熟悉但是并不好躲。 No.16（外传总No.306）游戏名：Touhou 3: The Phantasmagoria of Dimensional Dreams NES Demake 游戏类型：飞行射击游戏 Produced by： 之前介绍过的一个做原作复刻的社团，具体见十五期No.17（外传总No.227），这次是旧作第三作的复刻。不过这一作复刻的非常……制杖，你只要送boss过去，ai极大概率会直接一个b混过去，然后b没了直接会撞boss上自杀，所以打起来非常轻松。 No.17（外传总No.307）游戏名：동방외요전（東方外妖傳） 游戏类型：飞行射击游戏 Produced by： 来自韩国的stg，不过总是觉得有点奇怪。总体而言完成度有那么一点，但是不知道是不是因为demo的原因，道中只有各种蝴蝶，而且弹幕很单调没意思。另外boss放符卡前会“嗷呜”一声，听起来很怪。还有弹幕难度不合理，简单的比e都简单，难的能上h到l。不过比较有意思的是3boss这打到一半会变成横向stg。 No.18（外传总No.308）游戏名：ディガップ 游戏类型：飞行射击游戏 Produced by： 一个stg小游戏，向上下左右射击来“采掘”，打爆的石头有的会爆出“龙珠”，也就是分数，按照分数进行排名。每个被打爆的石头都会放死尸弹，非常影响走位。一局里只有一个bomb，会叫来百百世扔几个炸弹炸石头，虽然范围很大可能会得到很高分，但是死尸弹也非常多，bomb时不清屏不无敌。 No.19（外传总No.309）游戏名：ルナチャイルドの最終防衛ライン3 游戏类型：飞行射击游戏 Produced by：ENAMEL SWORD！ 一个算是bullet “hell”级别的stg，同时也算是爽游。和平时stg操作区别不大，收集“L”道具增长增长右侧lunar值，lunar值一方面增加level，也就是火力；另一方面在达到999时自动释放“狂乱月食”（ルナティックイクリプス），实话说这一部分有点像妖妖梦的森罗结界，可以自动收道具，同时可以抵消一次被弹。不过只要在999以上这个罩子就一直存在。另外游戏的分数膨胀极其厉害，比如上面截图上的分数，然而这时候离通关还很远（共5关，但是一关很长）。 No.20（外传总No.310）游戏名：東方謎域関 ~ Puzzles from the Mystic Dimension 游戏类型：飞行射击游戏 Produced by：红石-RedstoneGate 一个没有射击要素的stg小品作品，作为红石佬群活动奖励关卡发布的，共三非三符。稍微有一点点难，需要有些底力才能过。不过红石佬也放出了打法详解，就在下面这个视频。 pid=97165166 volantis.js(\"https://unpkg.com/pandown\").then(pandown)","categories":[{"name":"游戏","slug":"游戏","permalink":"https://neko-horikawaraiko.github.io/categories/%E6%B8%B8%E6%88%8F/"}],"tags":[{"name":"带你玩东方","slug":"带你玩东方","permalink":"https://neko-horikawaraiko.github.io/tags/%E5%B8%A6%E4%BD%A0%E7%8E%A9%E4%B8%9C%E6%96%B9/"}]},{"title":"《C++ Primer》学习笔记","slug":"《C++ Primer》学习笔记","date":"2021-11-24T12:50:40.000Z","updated":"2024-10-21T16:28:22.126Z","comments":true,"path":"2021/11/24/《C++ Primer》学习笔记/","link":"","permalink":"https://neko-horikawaraiko.github.io/2021/11/24/%E3%80%8AC++%20Primer%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"本文称为笔记，但是基本上是直接在代码中标注各种用法与注意事项。 一、C++函数与标准库、容器部分1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000100110021003100410051006100710081009101010111012101310141015101610171018101910201021102210231024102510261027102810291030103110321033103410351036103710381039104010411042104310441045104610471048104910501051105210531054105510561057105810591060106110621063106410651066106710681069107010711072107310741075107610771078107910801081108210831084108510861087108810891090109110921093109410951096109710981099110011011102110311041105110611071108110911101111111211131114111511161117111811191120112111221123112411251126112711281129113011311132113311341135113611371138113911401141114211431144114511461147114811491150115111521153115411551156115711581159116011611162116311641165116611671168116911701171117211731174117511761177117811791180118111821183118411851186118711881189119011911192119311941195119611971198119912001201120212031204120512061207120812091210121112121213121412151216121712181219122012211222122312241225122612271228122912301231123212331234123512361237123812391240124112421243124412451246124712481249125012511252125312541255125612571258125912601261126212631264126512661267126812691270127112721273127412751276127712781279128012811282128312841285128612871288128912901291129212931294129512961297129812991300130113021303130413051306130713081309131013111312131313141315131613171318131913201321132213231324132513261327132813291330133113321333133413351336133713381339134013411342134313441345134613471348134913501351135213531354135513561357135813591360136113621363136413651366136713681369137013711372137313741375137613771378137913801381138213831384138513861387138813891390139113921393139413951396139713981399140014011402140314041405140614071408140914101411141214131414141514161417141814191420142114221423142414251426142714281429143014311432143314341435143614371438143914401441144214431444144514461447144814491450145114521453145414551456145714581459146014611462146314641465146614671468146914701471147214731474147514761477147814791480148114821483148414851486148714881489149014911492149314941495149614971498149915001501150215031504150515061507150815091510151115121513151415151516151715181519152015211522152315241525152615271528152915301531153215331534153515361537153815391540154115421543154415451546154715481549155015511552155315541555155615571558155915601561156215631564156515661567156815691570157115721573157415751576157715781579158015811582158315841585158615871588158915901591159215931594159515961597159815991600160116021603160416051606160716081609161016111612161316141615161616171618161916201621162216231624162516261627162816291630163116321633163416351636163716381639164016411642164316441645164616471648164916501651165216531654165516561657165816591660166116621663166416651666166716681669167016711672167316741675167616771678167916801681168216831684168516861687168816891690169116921693169416951696169716981699170017011702170317041705170617071708170917101711171217131714171517161717171817191720172117221723172417251726172717281729173017311732173317341735173617371738173917401741174217431744174517461747174817491750175117521753175417551756175717581759176017611762176317641765176617671768176917701771177217731774177517761777177817791780178117821783178417851786178717881789179017911792179317941795179617971798179918001801180218031804180518061807180818091810181118121813181418151816181718181819182018211822182318241825182618271828182918301831183218331834183518361837183818391840184118421843184418451846184718481849185018511852185318541855185618571858185918601861186218631864186518661867186818691870187118721873187418751876187718781879188018811882188318841885188618871888188918901891189218931894189518961897189818991900190119021903190419051906190719081909////////////////////////////////////////////////////////////////// 学习《C++ Primer》笔记，函数与标准库、容器部分// edit by 猫耳堀川雷鼓/neko-horikawaraiko////////////////////////////////////////////////////////////////#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cctype&gt;#include &lt;vector&gt;#include &lt;cassert&gt;#include &lt;fstream&gt;#include &lt;sstream&gt;#include &lt;vector&gt;#include &lt;array&gt;#include &lt;list&gt;#include &lt;forward_list&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;functional&gt;#include &lt;map&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;#include &lt;type_traits&gt;#include &lt;tuple&gt;#include &lt;bitset&gt;#include &lt;regex&gt;#include &lt;random&gt;#include &lt;iomanip&gt;#pragma warning(disable:4996)//指针、引用void fun1()&#123; int* p1, p2; //p1指针，p2int int* p3 = &amp;p2, * p4; //p1、p2都是指针 int** p5 = &amp;p3; //p3指针的指针 int*&amp; r = p3; //r指针的引用&#125;//const、常量表达式extern const int bufSize = 512; //多文件共享const对象void fun2()&#123; int i = 42; const int&amp; r1 = i; //不可用r1改变i值，底层const const int&amp; r2 = r1 * 2; //顶层const，本身是const；底层const，指向的对象是const const int&amp; ri = 42; //const引用可直接绑定字面值，底层const double pi = 3.14; const double cd = 9.8; //顶层const，cd是常量表达式 const double* cptr = &amp;pi; //不可用cptr改变pi值，底层const double* const ptrc = &amp;pi; //不可改变ptrc，顶层const const double* const p = cptr;&#125;//别名、auto、decltypevoid fun3()&#123; typedef double wages; //等同 using wages = double; auto i = 0, * p = &amp;i; //√ //auto sz = 0, pi = 3.14; //× const int ci = i, &amp; cr = ci; auto b = ci; //int b auto c = cr; //int c auto d = &amp;i; //int *d auto e = &amp;ci; //const int *e const auto f = ci; //cosnt int f decltype(ci) x = 0; //const int x int i1 = 42, * p1 = &amp;i1, &amp; r1 = i1; decltype(r1 + 0) b1; //int b1 decltype(*p1) c1 = i; //int &amp;c1 decltype((i1)) d1 = i; //int &amp;d1 decltype(r1) e1 = i; //int &amp;e1&#125;//string、cctype、范围for、C风格字符串void fun4()&#123; using std::string; char cp[] = &#123; &#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27; &#125;;//不是以空字符结束的数组 const char* cp2 = &quot;Hidden&quot;; //C风格以空字符结束的数组/字符串(此处简称C-string)，等同const char cp2[] = &quot;Hidden&quot; string s1; string s2(s1); //等同 string s2 = s1; string s3(&quot;value&quot;); //等同 string s3 = &quot;value&quot;; string s4(4, &#x27;c&#x27;); string s5(cp, 2); //从cp数组拷贝前2个元素生成string string s6(s3, 2); //从string s3下标2处到末尾拷贝生成string string s7(s3, 2, 3); //从string s3下标2处到末尾拷贝3字符生成string，最多拷贝到s3末尾 string s8(cp2); //√// string s8(cp); //× s1.empty(); s1.size(); s1.substr(/*pos, n*/); //返回从pos开始n个字符的string拷贝 //添加删除：args参数 pos位置下标 iter位置迭代器 len长度 b、e头尾迭代器 //args s.append(args) s.assign(args) s.insert(pos, args) s.insert(iter, args) s.replace(pos, len, args) s.replace(b, e, args) //str（字符串且不等于s） √ √ √ × √ √ //str, pos, len（str从pos开始最多len个字符）√ √ √ × √ × //cp, len（cp指向数组的前最多len个字符） √ √ √ × √ √ //cp（以空字符结束的字符数组） √ √ × × √ √ //n, c（n个c） √ √ √ √ √ √ //b, e（迭代器（不指向s）范围内字符） √ √ × √ × √ //il（字符列表） √ √ × √ × √ s1.append(&quot;a&quot;); //末尾插入 s3.replace(1, 2, &quot;jkl&quot;); //下标1处删除2字符并插入&quot;jkl&quot;，等同 s3.erase(1, 2);s3.insert(1, &quot;jkl&quot;); //查找。实参必须为以下之一： c, pos(=0) 从pos开始找char c // s2, pos(=0) 从pos开始找string s2 // cp, pos(=0) 从pos开始查找以空字符结束的C-string cp // cp, pos, n 从pos开始查找cp指向数组的前n个字符 s3.find(&quot;ab&quot;); //在s3中查找&quot;ab&quot;第一次出现位置 s3.rfind(&quot;ab&quot;); //在s3中查找&quot;ab&quot;最后一次出现位置 s3.find_first_of(&quot;ab&quot;); //在s3中查找&quot;ab&quot;任一字符第一次出现位置 s3.find_last_of(&quot;ab&quot;); //在s3中查找&quot;ab&quot;任一字符最后一次出现位置 s3.find_first_not_of(&quot;ab&quot;); //在s3中查找第一个不在&quot;ab&quot;中的字符 s3.find_last_not_of(&quot;ab&quot;); //在s3中查找最后一个不在&quot;ab&quot;中的字符 s1 + s2; s1 == s2; s1 &lt; s2; getline(std::cin, s1); string::size_type len; s1.compare(s2); std::to_string(1); //任意数→字符串 //size_t sz; std::stoi(s1/*, &amp;sz, 10*/); //s1转换为int，sz返回是s1中第一个非数值字符下标，转换为10进制// std::stol(s1);// std::stoul(s1);// std::stoll(s1);// std::stoull(s1);// std::stof(s1);// std::stod(s1);// std::stold(s1); //&lt;cctype&gt; char c = &#x27;a&#x27;; c = isalnum(c); //字母数字 c = isalpha(c); //字母 c = iscntrl(c); //控制字符 c = isdigit(c); //数字 c = isgraph(c); //非空格且可打印 c = islower(c); //小写 c = isprint(c); //可打印 c = ispunct(c); //标点 c = isspace(c); //空白字符（空格、制表符、回车、换行、进纸符） c = isupper(c); //大写 c = isxdigit(c); //十六进制数 c = tolower(c); c = toupper(c); for (auto c : s1) std::cout &lt;&lt; c &lt;&lt; std::endl; for (auto&amp; c : s1) c = toupper(c); const char* ca1 = &quot;A string&quot;; const char ca2[] = &quot;A diff string&quot;; char ct = &#x27;-&#x27;; strlen(ca1); //长度 strcmp(ca1, ca2); //比较 strcat(&amp;ct, ca2); //ca2加到ct后，返回ct strcpy(&amp;ct, ca2); //ca2拷贝到ct，返回ct&#125;//数组（固定大小，不可拷贝，不可赋值）void fun6()&#123; int arr[10] = &#123; 1 &#125;; int* prts[10] = &#123; &amp;arr[0], &amp;arr[1] &#125;; //成一个数组的10个指针 int(*Parray)[10] = &amp;arr; //Parray是指向arr数组的指针，等同arr int(&amp;arrRef)[10] = arr; //arrRef是arr别名，与arr同样用 int* (&amp;arry)[10] = prts; //prts的别名 auto p = std::begin(arr); //首尾指针 std::end(arr); *p++; //先取值，后p++，返回*p，等同(*p)++ *++p; //先++p，后取值，返回*(++p)，等同*(++p) ++* p; //先取值，后值++，返回后来值，等同++(*p) (*p)++; //先取值，后值++，返回先前值 int ia[3][4]; auto pia = ia; // = int(*pia)[4]，指向第一行数组 pia++; //移到下一行 using int_array = int[4]; //等同 typedef int int_array[4];&#125;//强制转换void fun7()&#123; int i = 42; const int ci = 42; static_cast&lt;double&gt;(i); static_cast&lt;double&gt;(ci); void* p = &amp;i; int* pi = static_cast&lt;int*&gt;(p); //const_cast：去掉或加上const性质 const char* pc = &quot;&quot;; auto pp = const_cast&lt;char*&gt;(pc); //char *p //auto p = static_cast&lt;char*&gt;(pc); //× auto ps = static_cast&lt;std::string&gt;(pc); //const_cast&lt;std::string&gt;(pc); //× std::string s = &quot;a&quot;; std::string&amp; s2 = s; const_cast&lt;const std::string&amp;&gt;(s2); //reinterpret_cast：较低层次重新解释（尽量不使用） int* ip = &amp;i; char* cp = reinterpret_cast&lt;char*&gt;(ip); //dynamic_cast见后面&#125;//返回数组指针或引用using arrT = int[10];arrT* arrFun(int i); //等同 int(*arrFun(int i))[10]; auto arrFun2(int i) -&gt; int(*)[10];//内联函数：调用处直接展开；constexpr函数：返回值形参都是字面值类型，有且只有一条return语句 （这两种函数通常放在头文件）；常量表达式、constexpr//字面值类型：算数类型，引用、指针（由于编译时必须可确定值，所以一般为nullptr或0或内存中固定位置）；IO库、string类等不是字面值类型inline const std::string&amp; shorterStr(const std::string&amp; s1, const std::string&amp; s2) &#123; return s1.size() &lt;= s2.size() ? s1 : s2; &#125;constexpr int mf = 20; //constexpr变量mf是一个常量，必须用常量表达式初始化，20是常量表达式constexpr size_t new_sz(size_t sz) &#123; return 2 * sz; &#125; //所以可以声明 int a[new_sz(2)];//assert &lt;cassert&gt;，预处理宏void fun8()&#123; std::string s = &quot;asd&quot;; assert(s.size() &gt; 1); //不满足时报错 if (s.size() &lt; 10) &#123; std::cerr &lt;&lt; &quot;Error: &quot; &lt;&lt; __FILE__ &lt;&lt; &quot; : in funcion &quot; &lt;&lt; __func__ //__FUNCTION__ &lt;&lt; &quot; at line &quot; &lt;&lt; __LINE__ &lt;&lt; std::endl &lt;&lt; &quot;\\tCompiled on &quot; &lt;&lt; __DATE__ &lt;&lt; &quot; at &quot; &lt;&lt; __TIME__ &lt;&lt; std::endl; &#125;&#125;//函数指针typedef bool aFunBool(int, int); //等同 typedef decltype(funBool) Func; using Func = bool(int, int); typedef bool (*Func)(int, int); typedef decltype(funBool) *Func;using bFunBool = bool(int, int);using bpFunBool = bool(*)(int, int);bool funBool(int a, int b);void useFunBool(bool(int, int)); //函数指针形参，等同 void useFunBool(bool (*)(int, int)); void useFunBool(aFunBool); ，实际上将函数类型转换为函数指针bpFunBool retFunBool1(int); //√，可以返回函数指针//bFunBool retFunBool2(int); //×，不能返回函数bFunBool* retFunBool3(int); //√bool (*retFunBool4(int))(int, int); //√auto retFunBool5(int) -&gt; bool(*)(int, int); //√decltype(funBool)* retFunBool6(int); //√void fun9()&#123; bool (*pFunbool)(int a, int b); //pFunBool是函数指针 pFunbool = funBool; //等同 pFunBool = &amp;funBool; bool b1 = pFunbool(2, 3); //等同 bool b1 = (*pFunbool)(2, 3);&#125;//class示例，friend，const，静态成员，可变成员，显式转换class Sales_data&#123; friend class friendSales_data; //friendSales_data可以访问Sales_data的所有成员 friend void friendSales_data::fun(); //friendSales_data::fun()可以访问Sales_data的所有成员 friend Sales_data add(const Sales_data&amp;, const Sales_data&amp;); friend std::istream&amp; read(std::istream&amp;, Sales_data&amp;); friend std::ostream&amp; print(std::ostream&amp;, const Sales_data&amp;);public: Sales_data() = default; //合成默认构造函数，未定义其他构造函数时编译器会默认生成一个 Sales_data(const std::string&amp; s, unsigned n, double p) : bookNo(s), units_sold(n), revenue(p * n) &#123;&#125;//初始值顺序与成员声明顺序一致 Sales_data(const std::string&amp; s) :Sales_data(s, 0, 0) &#123;&#125;//委托构造函数 explicit Sales_data(std::istream&amp; is); //要求显式转换，explicit只对一个实参的构造函数有效 std::string isbn() &#123; return bookNo; &#125; //隐式内联，可供非常量对象使用 const std::string isbn() const &#123; return bookNo; &#125; //const重载，const表示不改变对象本身，可供常量/非常量对象使用 Sales_data&amp; combine(const Sales_data&amp;) &#123;&#125; void some_mem() const; static double staticFun(); //静态成员函数，不能声明为const的，不能再函数体内用this指针 void useStaticData() &#123; double d = staticdata; /*...*/ &#125; //成员函数可以不通过作用域运算符直接使用静态成员 void useStaticChar(char = c) &#123;&#125; //可以使用静态成员作为默认实参private: double avg_price() const &#123; return units_sold ? revenue / units_sold : 0; &#125; std::string bookNo; unsigned units_sold = 0; //类内初始值 double revenue = 0.0; //类内初始值 mutable size_t ctr = 0; //可变成员 Sales_data* nextbook; //可以定义指向自身类型的不完全类型的指针 static Sales_data sd; //可以定义不完全类型的静态成员 static double staticdata; //静态成员 static constexpr int anoStatic = 30; //通常情况下不能类内初始化静态成员，但可以提供const int类内初始值，且为constexpr的 static const char c;&#125;;Sales_data::Sales_data(std::istream&amp; is) &#123; /*...*/ &#125; //此处不应再使用explicit关键字，explicit只在类内标明std::istream&amp; read(std::istream&amp;, Sales_data&amp;) &#123; /*...*/ &#125;inline void Sales_data::some_mem() const &#123; ++ctr; &#125; //显式声明inline，const函数可改变可变成员double Sales_data::staticdata = 0.0; //类外部定义静态成员double Sales_data::staticFun() &#123; return staticdata; &#125; //类外部定义时不能重复static关键字void fun10()&#123; double r = Sales_data::staticFun(); Sales_data salesdata; //等同 Sales_data* salesdata; r = salesdata.staticFun(); // r = salesdata-&gt;staticFun();&#125;class friendSales_data&#123; void fun() &#123; Sales_data s; s.units_sold = 1;/*...*/ &#125;&#125;;//聚合类：所有成员public，未定义任何构造函数，无类内初始值，无基类，无虚函数struct AggregateClass&#123; int ival; std::string s;&#125;;AggregateClass val1 = &#123; 0,&quot;Anna&quot; &#125;; //√//AggregateClass val2 = &#123; &quot;Anna&quot;,0 &#125;; //×，必须按顺序初始化//字面值常量类struct ConstClass //数据成员都是字面值类型的聚合类&#123; int ival;&#125;;class ConstClass2 //非聚合类但：①数据成员为字面值类型；②至少一个constexpr构造函数；&#123; //③数据成员有内类初始值则初始值为常量表达式，成员为某类类型则使用成员自己的constexpr构造函数；④必须使用默认析构函数销毁类对象public: constexpr ConstClass2(bool h) :hw(h) &#123;&#125; //constexpr构造函数体为空 void set_hw(bool b) &#123; hw = b; &#125;private: bool hw;&#125;;//IO类、输入输出格式化、未格式化IO、流随机访问、文件IO、string IOvoid fun11()&#123; //以流cin和IO类istream为例 using std::cin; using std::istream; //条件状态位 istream::iostate; //整个io状态 istream::badbit; //流崩溃位 istream::failbit; //io操作失败位 istream::eofbit; //文件结束位 istream::goodbit; //流未处于错误状态位，固定为0 cin.eof(); //eofbit置位则返回true cin.fail(); //failbit或badbit置位则返回true cin.bad(); //badbit置位则返回true cin.good(); //流有效则返回true cin.setstate(cin.badbit); //将某（些）位置位 cin.clear(cin.badbit); //将某（些）位复位 cin.clear(); //条件状态位复位且将流置为有效 cin.rdstate(); //返回流状态iostate //cin.clear(cin.rdstate() &amp; ~cin.failbit &amp; ~cin.badbit); //failbit和badbit复位，eofbit不变 //输入输出格式化 using std::cout; char c; //带Δ的组表示只改变一次流状态，不带表示永久改变 // boolalpha/noboolalpha 将bool值打印为true和false/将bool值打印还原为1和0 // oct/hex/dec 将整型值显示为8/16/还原10进制 // showbase/noshowbase 打印整型值时显示/还原不显示进制（前导0x表示16进制，0表示8进制，无前导则10进制） // uppercase/nouppercase 打印16进制数时使用大写/还原小写其中的所有字母（包含0X)，打印科学计数法时打印E/e // showpoint/noshowpoint 浮点值不含小数时显示/还原不显示小数点 // showpos/noshowpos 对非负数显示/还原不显示&quot;+&quot;号 // unitbuf/nounitbuf 每次输出后缓冲区立即刷新/还原原刷新方式 // fixed/scientific/hexfloat/defaultfloat 使用定点十进制/科学记数法/定点十六进制与科学记数法/还原智能选择十进制浮点或科学记数法打印浮点值（注：使用这些操纵符后，精度值改为控制小数点后的位数而非小数点前后总位数） // left/right/internal 输出时左对齐/还原右对齐/符号左对齐而数字右对齐，中间用空格填充 //Δsetw &lt;iomanip&gt;打印下一个数字或字符串值时的最小空间 // setprecision &lt;iomanip&gt;设定精度 // setbase &lt;iomanip&gt;设定输出进制 // setfill &lt;iomanip&gt;设定填充空白使用的字符 // skipws/noskipws 输入运算符还原跳过/不跳过空白符（空格、制表、换行、换页、回车） //Δflush/ends/endl 直接刷新缓冲区/添加空字符，刷新缓冲区/添加换行，刷新缓冲区 cout &lt;&lt; std::boolalpha &lt;&lt; true &lt;&lt; &quot; &quot; &lt;&lt; false &lt;&lt; std::noboolalpha &lt;&lt; std::endl; cout &lt;&lt; 20 &lt;&lt; &quot; &quot; &lt;&lt; std::oct &lt;&lt; 20 &lt;&lt; &quot; &quot; &lt;&lt; std::hex &lt;&lt; 20 &lt;&lt; &quot; &quot; &lt;&lt; std::dec &lt;&lt; 20 &lt;&lt; std::endl; cout &lt;&lt; std::showbase &lt;&lt; 20 &lt;&lt; &quot; &quot; &lt;&lt; std::oct &lt;&lt; 20 &lt;&lt; &quot; &quot; &lt;&lt; std::hex &lt;&lt; 20 &lt;&lt; &quot; &quot; &lt;&lt; std::dec &lt;&lt; 20 &lt;&lt; std::noshowbase &lt;&lt; std::endl; cout &lt;&lt; std::uppercase &lt;&lt; std::showbase &lt;&lt; std::hex &lt;&lt; 30 &lt;&lt; std::nouppercase &lt;&lt; std::noshowbase &lt;&lt; std::dec &lt;&lt; std::endl; std::streamsize s = cout.precision(); //无参数时返回当前精度（默认浮点值6位精度，即最多打印6个数字，超过则用科学记数法） cout.precision(12); //含参数时设定精度（此处设为12位数字，含整数部分与小数部分），返回旧精度 cout &lt;&lt; std::setprecision(12); //等同cout.precision(12); cout &lt;&lt; sqrt(2.0) &lt;&lt; std::setprecision(s) &lt;&lt; std::endl; cout &lt;&lt; std::showpoint &lt;&lt; 30.0 &lt;&lt; std::noshowpoint &lt;&lt; std::endl; cout &lt;&lt; std::showpos &lt;&lt; 30 &lt;&lt; std::noshowpos &lt;&lt; std::endl; cout &lt;&lt; std::unitbuf &lt;&lt; std::nounitbuf; cout &lt;&lt; std::fixed &lt;&lt; 100 * sqrt(2.0) &lt;&lt; std::scientific &lt;&lt; 100 * sqrt(2.0) &lt;&lt; std::hexfloat &lt;&lt; 100 * sqrt(2.0) &lt;&lt; std::defaultfloat &lt;&lt; std::endl; cout &lt;&lt; std::left &lt;&lt; -1.2 &lt;&lt; std::internal &lt;&lt; -1.2 &lt;&lt; std::right &lt;&lt; std::endl; cout &lt;&lt; std::setw(12) &lt;&lt; std::internal &lt;&lt; std::setfill(&#x27;#&#x27;) &lt;&lt; -1.2 &lt;&lt; std::setfill(&#x27; &#x27;) &lt;&lt; std::right &lt;&lt; std::endl; cin &gt;&gt; std::noskipws; while (cin &gt;&gt; c) cout &lt;&lt; c; cin &gt;&gt; std::skipws; int ch; char buf[128]; //单字节底层IO操作（未格式化IO操作） cin.get(c); //读取下一个字节放入字符c中，返回istream对象 cin.get(); //读取下一个字节作为int返回（便于处理文件尾标记EOF） cin.putback(c); //输入流后移一位，将最后读取的某类型对象（此处为一个char，读取的类型必须与参数类型匹配）返回输入流中，返回istream对象（相当于unget特别版本） cin.unget(); //输入流后移一位，将最后读取的值返回输入流中，返回istream对象 cin.peek(); //读取下一个字节作为int返回，但不从流中删除它（相当于复制了一份再转为int） cout.put(c); //原样输出c中的字节 (ch = cin.get()) != EOF; //常用此检测文件尾 //多字节底层IO操作（未格式化IO操作） cin.get(buf, 60, &#x27;#&#x27;); //从cin读取最多60字节保存在字符数组buf中，读取过程遇到字符&#x27;#&#x27;或文件尾或已经读取59字节后（自动加&#x27;\\0&#x27;）停止，返回cin。遇到&#x27;#&#x27;时不从输入流取出而留在输入流 cin.get(buf, 60); //从cin读取最多60字节保存在字符数组buf中，读取过程遇到默认字符&#x27;\\n&#x27;或文件尾或已经读取59字节后停止，返回cin。遇到&#x27;\\n&#x27;时不从输入流取出而留在输入流 cin.getline(buf, 60, &#x27;#&#x27;); //从cin读取最多60字节保存在字符数组buf中，读取过程遇到字符&#x27;#&#x27;或文件尾或已经读取59字节后停止，返回cin。遇到&#x27;#&#x27;时从流中取出并丢弃 cin.read(buf, 60); //从cin读取最多60字节保存在字符数组buf中，返回cin cin.gcount(); //返回上一个未格式化读取操作从cin读取的字节数（特：若之前调用过peek、unget、putback则会返回0） cin.ignore(/*1, EOF*/); //读取并忽略字符/*最多1个，包括EOF*/ cout.write(buf, 30); //将buf中30字节写入cout，并返回cout //流随机访问，只适用fstream和sstream，IO类此时维护一个标记记录下一个读写操作的位置（读写共享一个标记，所以输入输出切换时需要用seek重定位标记），空白符同样占据一个位置 std::istringstream iss; std::ostringstream oss; iss.tellg(); //返回输入流中标记的当前位置 std::ostringstream::pos_type mark = oss.tellp();//返回输出流中标记的当前位置 iss.seekg(2); //在输入流中将标记重定位到给定位置，常使用前一个tellg或tellp返回值 oss.seekp(3); //在输出流中将标记重定位到给定位置，常使用前一个tellg或tellp返回值 iss.seekg(4, std::stringstream::beg); //将标记重定位到开头往后4的位置 iss.seekg(-4, std::stringstream::end); //将标记重定位到尾部往前4的位置 oss.seekp(4, std::stringstream::cur); //将标记重定位到当前往后4的位置 //关联输入输出流，输入操作会先刷新输出流 std::ostream* old_tie = cin.tie(nullptr); //断开cin与输出流（默认cout）关联 cin.tie(&amp;std::cerr); //cin与cerr关联，cin读取会先刷新cerr cin.tie(old_tie); //cin与cout关联 //&lt;fstream&gt; using std::ifstream; using std::ofstream; std::string ifile = &quot;&quot;; ifstream inf(ifile/*, ifstream::in*/); //输入流inf关联到ifile ofstream outf; //输出流outf未关联文件 outf.open(ifile/*, ofstream::out*/); //outf关联到ifile，返回void outf.is_open(); //是否成功打开且尚未关闭，返回bool outf.close(); //关闭绑定的文件 //fstream销毁时自动调用close() //文件模式in读/out写/app写到文件尾/trunc截断/ate打开定位到文件尾/binary二进制 //out = out | trunc;截断 app = out | app;追加到末尾 in | out;不截断，同时输入输出 ate和binary可与其他任意组合 inf默认in outf默认out fstream默认in | out //&lt;sstream&gt; using std::stringstream; std::string s; stringstream strm; stringstream strm2(s); //strm2保存s的拷贝 strm2.str(); //返回strm2保存的string的拷贝 strm.str(&quot;s&quot;); //字符串拷贝到strm中，返回void&#125;//顺序容器、容器适配器void fun12()&#123; // | &lt;vector&gt; | &lt;deque&gt; | &lt;list&gt; | &lt;forward_list&gt; | &lt;array&gt; | &lt;string&gt; // | vector | deque | list | forward_list | array | string(相当于字符vector) //大小 | 可变 | 可变 | 可变 | 可变 | 固定 | 可变 //访问 | 随机 | 随机 | 顺序 | 顺序 | 随机 | 随机 //访问方向 | | | 双向 | 单向 | | //快速添删元素位置 | 尾部 | 头尾 | 任何 | 任何 | 不能填删 | 尾部 // //选择原则：(1)默认vector；(2)元素小且空间额外开销重要，则不用list、forward_list；(3)随机访问则vector或deque；(4)中间插入删除则list或forward_list； //(5)头尾插入删除则deque；(6)输入时中间插入，随后随机访问：是否可用vector添加然后sort排序；否则可用list插入，再拷贝到vector //以vector和list为例 using std::vector; vector&lt;int&gt;::iterator p; //迭代器 vector&lt;int&gt;::const_iterator; //常量迭代器 vector&lt;int&gt;::size_type; //大小 vector&lt;int&gt;::difference_type; //迭代器距离 vector&lt;int&gt;::value_type; //元素类型 vector&lt;int&gt;::reference; //元素左值 vector&lt;int&gt;::const_reference; //元素常量左值 vector&lt;int&gt; vi1; //空容器 vector&lt;int&gt; vi2(vi1); //拷贝，等同 vector&lt;int&gt; vi2 = vi1; ，新旧容器类型、元素类型必须相同 vector&lt;int&gt; vi3(vi1.begin(), vi1.end()); //拷贝迭代器范围（不支持array），但是新旧容器类型可不同，元素类型可不同（但需要可类型转换） vector&lt;int&gt; vi4&#123; 1,2,3 &#125;; //列表初始化，等同 vector&lt;int&gt; vi4 = &#123; 1,2,3 &#125;; vector&lt;int&gt; vi5(3/*, 5*/); //3个元素的容器，默认int初始值（0）/*，全部初始化为5*/ vector&lt;int&gt; v6(10); //10个0 vector&lt;int&gt; v7&#123; 10 &#125;; //1个10 vector&lt;std::string&gt; v8&#123; 10,&quot;hi&quot; &#125;; //10个hi，等同 vector&lt;std::string&gt; v8(10, &quot;hi&quot;); std::list&lt;int&gt; li; vi1.cbegin(); //vi1.rbegin(); vi1.crbegin(); //赋值 vi1 = vi2; //vi1替换为vi2的拷贝 vi1 = &#123; 1,2,3 &#125;; //vi1列表赋值（不适用array） vi1.assign(vi4.begin(), vi4.end()); //替换为另一序列两迭代器之间元素 vi1.assign(&#123; 1,2 &#125;); //替换为列表 vi1.assign(3, 2); //替换为3个2 vi1.swap(vi2); //等同 swap(vi1, vi2); //大小，resize缩小时，指向被删掉的元素的迭代器/引用/指针失效，resize若导致重分配存储空间则所有迭代器/引用/指针失效 vi1.size(); //保存的元素数（不支持forward_list) vi1.max_size(); //可保存的最大元素数 vi1.resize(10/*, 3*/); //改变大小为10/*并所有赋值3*/ vi1.empty(); //容器是否为空 //添加删除（全部不适用array，forward_list见下面） vi1.insert(p, 2); //p之前拷贝添加元素，返回指向添加的第一个元素的迭代器// vi1.insert(p, 2, 3); //拷贝添加2个3// vi1.insert(p, vi4.begin(), vi4.end()); //拷贝添加迭代器之间元素// vi1.insert(p, &#123; 1,2 &#125;); //拷贝添加一个列表 vi1.emplace(p, 3); //构造添加一个3 li.push_back(1); //在尾部拷贝添加元素（不适用forward_list） li.push_front(2); //在头部拷贝添加元素（不适用vector、string） li.emplace_back(3); //在尾部构造添加元素（不适用forward_list） li.emplace_front(4); //在头部构造添加元素（不适用vector、string） vi1.erase(p); //删除p指定元素，返回被删元素的后一元素的迭代器// vi1.erase(vi1.begin(), vi1.end()); //删除迭代器之间元素，返回最后一个被删元素的后一元素的迭代器 li.pop_front(); //删除首元素，返回void（不适用vector、string） li.pop_back(); //删除尾元素，返回void（不适用forward_list） vi1.clear(); //删除所有元素，返回void //vector、string添加若导致重分配存储空间：使所有指向容器迭代器/引用/指针失效，未重分配：插入位置后的迭代器/引用/指针失效，插入位置前的迭代器/引用/指针有效 //vector、string删除使指向容器删除点后迭代器/引用/指针失效，deque删除首尾外任何元素使所有指向容器迭代器/引用/指针失效 //deque添加到首尾外任何位置：所有指向容器迭代器/引用/指针失效，添加到首尾：迭代器失效，指向已存在元素的引用/指针有效 //deque删除首尾外任何位置：所有指向容器迭代器/引用/指针失效，删除尾：尾后迭代器失效，其他迭代器/引用/指针有效，删除首：删除尾：所有迭代器/引用/指针有效 //访问 vi1.front(); //返回头元素引用 vi1.back(); //返回尾元素引用（不适用forward_list） vi1[3]; //返回下标为3元素引用，不检查下标越界（不适用list、forward_list） vi1.at(3); //返回下标为3元素引用，可检查下标越界（不适用list、forward_list） //容量（vector、string） vi1.shrink_to_fit(); //将capacity()减小为size()大小，但不保证一定可退回内存空间，也可对deque使用 vi1.capacity(); //当前可保存多少元素 vi1.reserve(10); //分配至少容纳10元素的空间，若小于当前使用空间则什么也不做 //比较 vi1 == vi2; //同容器类型同元素类型 vi1 &lt; vi2; //迭代器使用 auto b = v8.begin(), e = v8.end(); *b; //返回元素的引用 b-&gt;c_str(); //等同 (*b).c_str() ++b; b + 2; //向前移动2位置 b += 2; auto a1 = b - e; //iterator::difference_type b == e; b &lt; e; //&lt;array&gt; std::array&lt;int, 3&gt; ai1; //默认初始化 std::array&lt;int, 4&gt; ai2 = &#123; 1,2,3 &#125;; //列表初始化 //&lt;forward_list&gt; std::forward_list&lt;int&gt; fli; std::forward_list&lt;int&gt;::iterator pfli; fli.before_begin(); //fli.cbefore_begin(); 首前迭代器，不可解引用 fli.insert_after(pfli, 2); //返回添加的最后一个元素的迭代器// fli.insert_after(pfli, 2, 3);// fli.insert_after(pfli, vi4.begin(), vi4.end());// fli.insert_after(pfli, &#123; 1,2 &#125;); fli.emplace_after(pfli, 3); //返回添加的元素的迭代器 fli.erase_after(pfli); //返回被删元素的后一元素的迭代器// fli.erase_after(fli.begin(), fli.end()); //list/forward_list std::list&lt;int&gt; li2; li.merge(li2/*, comp*/); // /*使用给定的comp比较操作*/将li2合并入li，li和li2必须已经有序 li.remove(1); //删除所有的1 li.remove_if([](int i) &#123; return i == 1; &#125;); //删除所有的使谓词为真（此处为等于1）的元素 li.reverse(); //反转顺序 li.sort(/*comp*/); //使用&lt;/*或使用给定的comp比较操作*/将li排序 li.unique(/*pred*/); //使用==/*或给定的二元谓词pred*/删除同一个值的连续拷贝 li.splice(li.end(), li2); //将li2元素移到li中，且删除li2中元素// fli.splice_after(fli.before_begin(), fli2); //将fli2元素移到li中，且删除fli2中元素，此处必须用fli的首前位置// li.splice(li.begin(), li2, li2.begin()); //移动指向的一个元素// fli.splice_after(fli.before_begin(), li2, li2.begin()); //移动指向之后的一个元素// li.splice(li.begin(), li2, fli2.begin(), fli2.end()); //移动范围元素// fli.splice_after(fli.before_begin(), li2, li2.begin(), li2.end()); //移动范围元素 //容器适配器 都是基于某容器实现 //&lt;stack&gt; stack默认基于deque，也可在list或vector实现 &lt;queue&gt; queue默认基于deque，也可在list或vector实现；priority_queue默认基于vector，也可在deque实现 //&lt;stack&gt; std::stack&lt;int&gt; si, si2; //等同 stack&lt;int, deque&lt;int&gt;&gt; si; std::stack&lt;int, vector&lt;int&gt;&gt; si3(vi1); //重载默认容器类型，拷贝vi1（需在同一种容器上实现） si.empty(); si.size(); si.swap(si2); //等同 std::swap(si, si2); ，注意不能与si3交换 si.push(1); //拷贝压入栈顶 si.emplace(2); //构造压入栈顶 si.pop(); //删除栈顶元素但不返回值 si.top(); //返回栈顶元素 //&lt;queue&gt; std::queue&lt;int&gt; qi, qi2; qi.empty(); qi.size(); qi.swap(qi2); qi.push(1); qi.emplace(2); qi.front(); //返回queue首元素（只适用queue） qi.back(); //返回queue尾元素（只适用queue） qi.pop(); //删除queue首元素或priority_queue最高优先级元素，但不返回值 std::priority_queue&lt;int&gt; pqi; pqi.top(); //返回priority_queue最高优先级元素（只适用priority_queue）&#125;//泛型算法、谓词（一元谓词：接受一个参数，二元谓词：接受两个参数）、bind函数bool isShorter(const std::string&amp; s1, const std::string&amp; s2) &#123; return s1.size() &lt; s2.size(); &#125;bool checkSize(const std::string&amp; s, std::string::size_type sz) &#123; return s.size() &gt;= sz; &#125;std::ostream&amp; refPrint(std::ostream&amp; os, const std::string&amp; s, char c) &#123; return os &lt;&lt; s &lt;&lt; c; &#125;void fun13()&#123; std::vector&lt;int&gt; vi(10), vi2(11), vi3; std::vector&lt;std::string&gt; vs(5); std::vector&lt;int&gt;::iterator vibe = vi.begin(), vien = vi.end(); std::vector&lt;std::string&gt;::iterator vsbe = vs.begin(), vsen = vs.end(); //placeholders：&lt;functional&gt; using namespace std::placeholders; //&lt;numeric&gt; int sz = 10; int isum = accumulate(vibe, vien, 0); //需要定义operator+、序列元素类型可以匹配第三个参数类型 std::string ssum = accumulate(vsbe, vsen, std::string(&quot;&quot;)); //&lt;algorithm&gt; equal(vibe, vien, vi2.begin()); //需要vi与vi2元素可用==比较，且vi2.size() &gt;= vi.size() fill(vibe, vien, 1); //区间所有元素重置为1 fill_n(vibe, vi.size(), 2); //vibe开始，size()个元素重置为2 fill_n(back_inserter(vi3), 10, 3); //&lt;iterator&gt;，后插入迭代器，此时可以给空容器加元素 copy(vibe, vien, vi2.begin()); //前两个参数的范围的值，拷贝给第三个参数开始的目的序列，要求vi2.size() &gt;= vi.size()，返回拷贝目的范围后一位置迭代器 replace(vibe, vien, 1, 43); //范围内的1全改为43 replace_copy(vibe, vien, back_inserter(vi3), 1, 43); //范围拷贝到目标位置且把其中的1全改为43 sort(vsbe, vsen); //默认从小到大排序 sort(vsbe, vsen, isShorter); //按照谓词（string长度从小到大）排序，等同sort(vsbe, vsen, [](const strin&amp; a, const string&amp; b) &#123; return a.size() &lt; b.size(); &#125;); sort(vsbe, vsen, bind(isShorter, _2, _1)); //bind函数将sort作用改为string长度从大到小排序 unique(vsbe, vsen); //重排范围，使每个相同元素只出现一次且排在范围前部，返回不重复区域的后一元素位置的迭代器 find(vibe, vien, 1); //返回第三参数第一次出现位置 find_if(vsbe, vsen, [sz](const std::string&amp; s) //返回第一个满足谓词的元素的迭代器 &#123; return s.size() &gt; sz; &#125;); //等同 ↓ find_if(vsbe, vsen, bind(checkSize, _1, sz)); //bind函数，传入的参数依次拷贝传入_1,_2,...位置 for_each(vibe, vien, [](int i) &#123; std::cout &lt;&lt; i &lt;&lt; &quot; &quot;; &#125;); //对范围内每个元素调用谓词 for_each(vsbe, vsen, bind(refPrint, std::ref(std::cout), _1, &#x27; &#x27;)); //ref/cref：&lt;functional&gt;，ref返回一个包含给定引用的对象，此对象可以提供bind的拷贝需要&#125;//lambda表达式： [捕获列表](参数列表) —&gt; 返回类型 &#123; 函数体 &#125;void fun14()&#123; int sz = 10; std::ostream&amp; os = std::cout; char c = &#x27; &#x27;; auto lambda1 = [] &#123; return 42; &#125;; //参数列表和返回类型可省略 auto lambda2 = [sz](const std::string&amp; s) &#123; return s.size() &gt; sz; &#125;;//值捕获，捕获了局部变量才可在函数体中使用 auto lambda3 = [&amp;sz] &#123; return sz; &#125;; //引用捕获 auto lambda4 = [=] &#123; return sz; &#125;; //隐式值捕获 auto lambda5 = [&amp;] &#123; return sz; &#125;; //隐式引用捕获 auto lambda6 = [&amp;, c](const std::string&amp; s) &#123; os &lt;&lt; s &lt;&lt; c; &#125;; //隐式引用捕获其他，显式值捕获c auto lambda7 = [=, &amp;os](const std::string&amp; s) &#123; os &lt;&lt; s &lt;&lt; c; &#125;; //隐式值捕获其他，显式引用捕获os auto lambda8 = [sz]() mutable &#123; return ++sz; &#125;; //mutable可改变被值捕获变量的值，等同auto lambda8 = [&amp;sz] &#123; return ++sz; &#125;; auto lambda9 = [](int i) -&gt; int &#123; if (i &lt; 0) return i; else return -i; &#125;; //lambda函数包含任何return外语句时推断返回void，需指定尾置返回类型&#125;//&lt;iterator&gt; 其他类型迭代器void fun15()&#123; //插入迭代器，接受容器参数 std::list&lt;int&gt; listi; back_inserter(listi); //创建使用push_back的迭代器，始终插入到容器新的最后一个元素之后 front_inserter(listi); //创建使用push_front的迭代器，始终插入到容器新的第一个元素之前 inserter(listi, listi.begin()); //创建使用insert的迭代器，插入到给定迭代器所表示元素之前 //流迭代器 using std::istream_iterator; istream_iterator&lt;int&gt; int_eof; //指向尾后的输入流迭代器 istream_iterator&lt;int&gt; int_it(std::cin); //从cin读取的输入流迭代器，输入迭代器使用&gt;&gt;读取流，所以被读取类型需定义&gt;&gt; int_it != int_eof; //遇到文件尾或不是int的数据为止 std::vector&lt;int&gt; vi(int_it, int_eof); //示例，从cin读取并构造vector accumulate(int_it, int_eof, 0); //示例，读取求和 int sum = 0; sum += *int_it++; //示例，读取求和（先读取cin并解引用得到数据值，加到sum上，移到下一位置（等待cin）） using std::ostream_iterator; ostream_iterator&lt;int&gt; out_it(std::cout); //写到cout的输出流迭代器 ostream_iterator&lt;int&gt; out_it2(std::cout, &quot; &quot;); //写到cout的输出流迭代器，且每个值后面都输出&quot; &quot;空字符结尾的字符数组 for (auto e : vi) //示例，将每个元素输出至cout *out_it2++ = e; //等同 out_it2 = e; copy(vi.begin(), vi.end(), out_it2); //示例，将每个元素输出至cout，等同 ↑ //反向迭代器 std::reverse_iterator&lt;int&gt; i_iter = vi.crbegin(); ++i_iter; //实际上往前移动，所以不支持forward_list和流迭代器上创建反向迭代器 i_iter.base(); //转换为普通迭代器，实际上指向原来序列的正向下一个元素（此处在上一句代码基础上，得到的普通迭代器就是指向最后一元素） //移动迭代器&#125;//关联容器size_t hasher(const Sales_data&amp; sd) &#123; return std::hash&lt;std::string&gt;()(sd.isbn()); &#125;bool eqOp(const Sales_data&amp; lhs, const Sales_data&amp; rhs) &#123; return lhs.isbn() == rhs.isbn(); &#125;bool cmprShorterStr(const std::string&amp; s1, const std::string&amp; s2) &#123; return s1.size() &lt; s2.size(); &#125;void fun16()&#123; //map/multimap &lt;map&gt;，set/multiset &lt;set&gt; 关键字有序且不可重复/可重复的map/set //基础用法：构造、赋值、大小、添加删除、比较、迭代器 std::map&lt;std::string, size_t&gt; map1; std::map&lt;std::string, size_t&gt; map2(map1); std::map&lt;std::string, size_t&gt; map3(map1.begin(),map1.end()); std::map&lt;std::string, size_t&gt; map4&#123; &#123; &quot;A&quot;,3 &#125;, &#123; &quot;B&quot;,2 &#125; &#125;; std::map&lt;std::string, size_t, decltype(cmprShorterStr)*&gt; map5(cmprShorterStr); //使用尖括号内第三参数来对关键字比较，必须是函数指针或 重载调用运算符（需要const后缀）进行比较的类的类名（仿函数），变量的实参可用圆括号或花括号提供实际比较的函数（仿函数不需要） map1 = map2; map1 = &#123; &#123; &quot;C&quot;,1 &#125; &#125;; map1.swap(map2); //等同 swap(map1, map2); map1.size(); map1.max_size(); map1.empty(); map1.insert(&#123; &quot;D&quot;,1 &#125;); //等同 map1.insert(make_pair(&quot;D&quot;, 1)); map1.insert(pair&lt;string, size_t&gt;(&quot;D&quot;, 1)); map1.insert(map&lt;string, size_t&gt;::value_type(&quot;D&quot;, 1)); map1.emplace(&quot;E&quot;, 2); //与上一句，map/set返回&lt;指定关键字的元素的迭代器, 是否插入成功的bool值&gt;的pair，multimap/multiset返回新元素的迭代器 map1.insert(map2.begin(), map2.end()); //返回void，map/set插入非重复关键字元素，multimap/multiset插入所有元素 map1.insert(&#123; &#123; &quot;D&quot;,1 &#125;,&#123; &quot;E&quot;,2 &#125; &#125;); //返回void，map/set插入非重复关键字元素，multimap/multiset插入所有元素 map1.insert(map1.begin(), &#123; &quot;D&quot;,2 &#125;); //提示从迭代器处开始搜索新元素的存储位置，返回具有给定关键字的元素的迭代器 map1.emplace(map1.begin(), &quot;D&quot;, 2); //提示从迭代器处开始搜索新元素的存储位置，返回具有给定关键字的元素的迭代器 map1.erase(&quot;A&quot;); //删除所有指定关键字的元素，返回size_t表明删除了几个 map1.erase(map1.begin()); //删除迭代器指定的元素，故迭代器不能为end()且必须指向一个存在的元素，返回指向下一个元素的迭代器 map1.erase(map1.begin(), map1.end()); //删除范围元素 map1.clear(); map1 == map2; map1 &lt; map2; map1.begin(); //值类型 std::map&lt;std::string, size_t&gt;::value_type; //map的键值对类型，此处为pair&lt;string, size_t&gt; std::map&lt;std::string, size_t&gt;::key_type; //map的关键字类型，此处为string std::map&lt;std::string, size_t&gt;::mapped_type; //map的关键字对应值类型，此处为size_t// std::set&lt;int&gt;::value_type; // = std::set&lt;int&gt;::key_type auto map_it = map1.begin(); map_it-&gt;first; //map/set的关键字是const的 map_it-&gt;second; //map关键字的值是非const的 //（非const的）map/unordered_map下标 map1[&quot;A&quot;]; //返回关键字为&quot;A&quot;的元素的值，若不存在则创建该关键字的元素，并值初始化 map1.at(&quot;A&quot;); //返回关键字为&quot;A&quot;的元素的值，若不存在则异常 //访问元素 map1.find(&quot;A&quot;); //返回第一个关键字为&quot;A&quot;的元素的迭代器，找不到则返回end() map1.count(&quot;A&quot;); //返回关键字为&quot;A&quot;的元素数量 map1.lower_bound(&quot;A&quot;); //返回第一个关键字不小于&quot;A&quot;的元素（不适用无序容器） map1.upper_bound(&quot;D&quot;); //返回第一个关键字大于&quot;D&quot;的元素（不适用无序容器） map1.equal_range(&quot;D&quot;); //返回关键字为&quot;D&quot;的元素的范围(pair)，不存在则返回(end(), end()) //unordered_map/unordered_multimap &lt;unordered_map&gt;，unordered_set/unordered_multiset &lt;unordered_set&gt; 关键字无序且不可重复/可重复的map/set //无序容器使用 桶 保存元素，计算哈希函数值相同的元素保存在同一个桶中 std::unordered_map&lt;std::string, size_t&gt; unmap; using sd_multiset = std::unordered_set&lt;Sales_data, decltype(hasher)*, decltype(eqOp)*&gt;; sd_multiset sdset(10, hasher, eqOp); //自定义类型需自定义哈希函数和相等运算符// unordered_set&lt;Foo, decltype(FooHash)*&gt; fooset(10, FooHash); //类中已经定义==运算符时，可只重载哈希函数 //桶接口 unmap.bucket(&quot;A&quot;); //关键字为&quot;A&quot;的元素在哪个桶 unmap.bucket_count(); //正在使用的桶的数目 unmap.bucket_size(2); //第2个桶有多少元素 unmap.max_bucket_count(); //容器容纳的最多的桶的数量 //桶迭代 std::unordered_map&lt;std::string, size_t&gt;::local_iterator; //访问桶中元素的迭代器类型 std::unordered_map&lt;std::string, size_t&gt;::const_local_iterator;//const版本 unmap.begin(1); //桶1的迭代器// unmap.begin(); //unordered_map的迭代器 //哈希策略 unmap.load_factor(); //(float)平均每个桶的元素数量 unmap.max_load_factor(); //(float)平均桶的大小，容器在需要时添加桶来保证load_factor() &lt;= max_load_factor() unmap.rehash(5); //重组存储，使得bucket_count() &gt;= 5（参数值），且bucket_count() &gt; size()/max_load_factor() unmap.reserve(10); //重组存储，使得容器保存10（参数值）个元素且不必rehash&#125;//pair &lt;utility&gt;void fun17()&#123; std::pair&lt;std::string, int&gt; pair1; std::pair&lt;std::string, int&gt; pair2(&quot;Ac&quot;, 2); //等同 std::pair&lt;std::string, int&gt; pair2/* = */&#123; &quot;Ac&quot;, 2 &#125;; std::make_pair(&quot;Ba&quot;, 3); //返回一个pair，自动推断类型 pair2.first; //返回pair的第一个数据成员 pair2.second; //返回pair的第二个数据成员 pair1 == pair2; pair1 &lt; pair2;&#125;//new delete 管理动态内存void fun18()&#123; //有自己构造函数的类类型 加不加括号都会默认构造函数来初始化，内置类型不加括号时值未定义，加括号则值初始化 int* pi = new int; //默认初始化，值未定义，空间耗尽时返回bad_alloc异常// int* pi = new int(); //值初始化为0// std::string* ps = new std::string; //默认初始化，空string std::string* ps = new std::string(10, &#x27;9&#x27;); //值初始化为&quot;9999999999&quot; const int* pci = new const int(1024); //必须初始化，有默认构造函数的可隐式初始化，其他的需要显式初始化 int* pia = new int[42]; //默认初始化，值未定义，返回的是指向第一个元素类型的指针，不能begin()和end() typedef int arrT2[42]; int* pia2 = new arrT2; std::string* pia3 = new std::string[10]&#123; &quot;A&quot;,&quot;ab&quot; &#125;;//值初始化 char* pc = new char[0]; //可创建大小为0的动态分配数组（静态数组大小不能为0），但是pc不可解引用 //nothrow &lt;new&gt;// int* pi2 = new (nothrow) int; //空间耗尽时返回空指针 delete pi; //销毁对象，释放内存。给delete的指针只能指向new分配的动态内存，或者nullptr。忘记会造成内存泄漏 delete ps; delete pci; delete[] pia; delete[] pia2; delete[] pia3; delete[] pc; pi = nullptr; //清楚指出不再指向任何对象 ps = nullptr; pci = nullptr;&#125;//智能指针，管理动态内存 &lt;memory&gt;//①不使用内置指针初始化/reset多个智能指针；②不delete get()返回的指针；③不使用get()初始化或reset()另一智能指针；//④最后一个相应智能指针销毁后，之前get()的指针变为无效；⑤智能指针管理的资源不是new分配的内存，需要传递一个删除器dvoid fun19()&#123; //shared_ptr 销毁最后一个时，同时释放所关联内存 using std::shared_ptr; std::string* q; //尽量不要混合使用智能指针与普通指针 shared_ptr&lt;std::string&gt; sp1; //空指针，可以指向一个对象 shared_ptr&lt;std::string&gt; sp2(sp1); //sp2拷贝sp1，并递增sp1计数器，sp1中指针必须可转换为sp2模板类的指针，即shared_ptr&lt;T&gt; sp2(sp1);的sp1中指针可转换为T*// shared_ptr&lt;std::string&gt; sp2(sp1, d); //sp2拷贝sp1，使用可调用对象（可使用调用运算符的对象，如函数、某些类对象等）d代替delete// shared_ptr&lt;T&gt; ip1(u); //从unique_ptr u接管对象所有权，并将u置空// shared_ptr&lt;T&gt; ip1(q, d); //从内置指针p接管对象所有权，q指针可转换为T*，使用可调用对象d代替delete shared_ptr&lt;int&gt; ip2(new int(1024)); //√// shared_ptr&lt;int&gt; ip1 = new int(1024); //× 需要显式初始化 sp1; //判断sp1是否指向一个对象 *sp1; //解引用，获得对象 sp1-&gt;c_str(); //获取成员 sp1.get(); //返回其中保存的普通指针，不要使用返回的指针初始化另一个智能指针 swap(sp1, sp2); //等同 sp1.swap(sp2); std::make_shared&lt;std::string&gt;(&quot;s&quot;); //使用相应类的可选参数形式，初始化返回shared_ptr并指向动态分配的对象 sp2 = sp1; //必须同为shared_ptr，所保存的指针也能相互转换，增加sp1计数，减小sp2计数（减为0会释放内存） sp1.use_count(); //计数器数值 sp1.unique(); //计数器数值是否为1 sp1.reset(); //若sp1是unique的，则释放所指向的对象，且sp1置空 sp1.reset(q); //sp1指向内置指针q// sp1.reset(q, d); //sp1指向内置指针q并用d释放q //unique_ptr using std::unique_ptr; unique_ptr&lt;int&gt; up1; unique_ptr&lt;std::string&gt; up2(new std::string(&quot;SS&quot;));// unique_ptr&lt;int&gt; up3(up1); //× 不支持拷贝 unique_ptr&lt;std::string&gt; up4;// up4 = up2; //× 不支持赋值// unique_ptr&lt;T, D&gt; up5; //空指针，用D类型对象释放指针// unique_ptr&lt;T, D&gt; up5(d); //空指针，用D类型对象d代替delete释放指针// unique_ptr&lt;T, D&gt; up5(new T, d); //指向一个T对象的指针，用D类型（指针类型如函数指针）对象d代替delete释放指针 up1; //判断sp1是否指向一个对象 *up1; //解引用，获得对象 up2-&gt;c_str(); //获取成员 up1.get(); //返回其中保存的普通指针，不要使用返回的指针初始化另一个智能指针 swap(up2, up4); //等同 up2.swap(up4); up1 = nullptr; //释放指向的对象，将up1置空 up1.release(); //放弃控制权，up1置空，返回普通动态内存指针（所以需要普通指针来释放内存） up1.reset(); //释放指向的对象，并置空，等同 up1.reset(nullptr); up4.reset(q); //释放指向的对象，并指向q //weak_ptr std::weak_ptr&lt;int&gt; wi1; std::weak_ptr&lt;std::string&gt; wi2(sp1); //与shared_ptr指向相同对象的指针，T（此处为string）必须能转换为sp1指向的类型 wi1 = wi2; wi1 = sp1; //weak_ptr可与weak_ptr或shared_ptr共享对象 wi1.reset(); //置空 wi1.use_count(); //相应unique_ptr的数量 wi1.expired(); //use_count()是否为0 wi1.lock(); //若无相应unique_ptr则返回一个空unique_ptr，否则返回一个wi1指向对象的unique_ptr //指向动态数组的unique_ptr，不支持成员访问的点和箭头运算符，其他操作不变 unique_ptr&lt;int[]&gt; upa; //空指针，可以指向一个对象 unique_ptr&lt;int[]&gt; upa2(new int[10]);// unique_ptr&lt;T[]&gt; upa3(p); //指向内置指针p指向的动态数组，p必须能转换为T* upa2[1]; //指针必须指向一个数组，返回下标处对象 upa.release(); //销毁它管理的指针时自动使用delete[] //指向动态数组的shared_ptr，不直接支持管理动态数组，需要自己提供删除器， shared_ptr&lt;int[]&gt; spa(new int[10], [](int* p) &#123; delete[] p; &#125;); spa.get() + 1; //shared_ptr未定义下标运算符，且不支持指针算术运算，需要此方式访问数组元素 spa.reset(); //使用自定义删除器释放数组&#125;//使用动态内存：①不知道要用多少对象（如容器类）；②不知道所需对象准确类型；③需要在多个对象间共享数据//allocator &lt;memory&gt;，分配原始的未构造的内存void fun20()&#123; using std::allocator; allocator&lt;std::string&gt; alloc; auto const p = alloc.allocate(2); //为4个string分配内存，未初始化，返回指向分配的第一个元素的指针 auto q = p; alloc.construct(q, 10, &#x27;c&#x27;); //在q处构造一个对象（&quot;cccccccccc&quot;） alloc.destroy(q); //对指向的构造的对象调用析构函数来销毁，必须对每个构造的对象都销毁 alloc.deallocate(p, 2); //释放分配的内存，大小与分配时必须相同 std::vector&lt;std::string&gt; vs&#123; &quot;A&quot;,&quot;b&quot; &#125;; auto const p2 = alloc.allocate(8); //&lt;memory&gt; auto q2 = uninitialized_copy(vs.begin(), vs.end(), p); //拷贝范围到未构造的原始内存中，必须足够大，返回下一元素指针 auto q3 = uninitialized_copy_n(vs.begin(), vs.size(), q2); //拷贝n和元素到q2开始的未构造的原始内存中，返回下一元素指针 uninitialized_fill(q3, q3 + 2, &quot;c&quot;); //在未构造的原始内存中指定范围内创建对象，值均为&quot;c&quot;的拷贝，返回void uninitialized_fill_n(q3 + 2, vs.size(), &quot;c&quot;); //从开始位置在未构造的原始内存中创建n个对象，值均为&quot;c&quot;的拷贝，返回下一元素指针&#125;//拷贝初始化、直接初始化void fun21()&#123; std::string dots(10, &#x27;.&#x27;); //直接初始化，构造函数 std::string s(dots); //直接初始化，拷贝构造函数 std::string s2 = dots; //拷贝初始化，拷贝构造函数 std::string null_book = &quot;9-99&quot;; //拷贝初始化 std::string s3 = std::string(100, &#x27;9&#x27;); //拷贝初始化&#125;//右值引用：必须绑定到右值（要求转换/计算的表达式、字面常量、返回右值的表达式）的引用（特：但是可以将左值引用传递到右值模板形参T&amp;&amp;），movevoid fun22()&#123; int i = 42; int&amp; r = i; //√，左值引用可绑定到左值// int&amp;&amp; rr = i; //×，右值引用不可绑定到左值// int&amp; r2 = i * 2; //×，左值引用不可绑定到要求转换的表达式 const int&amp; r3 = i * 2; //√，左值const引用可绑定到要求转换的表达式 int&amp;&amp; rr2 = i * 2; //√，右值引用不可绑定到要求转换的表达式// int&amp;&amp; rr3 = rr2; //×，变量是左值 //&lt;utility&gt; move，使用时最好不使用using std::move;声明，否则若自己定义了单参数版本，会与标准库move相冲突（标准库move使用右值引用模板形参，可匹配任意类型） int&amp;&amp; rr4 = std::move(rr2); //√，move返回给定对象的右值引用，此时rr1中的值不定（使用会产生未知后果），只可以对rr1进行销毁或重赋值处理&#125;//运算符重载//不可重载 ::(作用域) .*(指向成员选择的指针) .(成员选择) ?:(三元条件)//通常不重载 ,(逗号) &amp;(取地址) &amp;&amp;(逻辑与) ||(逻辑或)//除了函数调用运算符operator()外，其他重载运算符不能有默认实参//有operator==，则一般也有operator!=；若类要一个单序比较操作，则有operator&lt;，则一般也有其他关系操作；//逻辑运算符和关系运算符返回bool，算术运算符返回类类型的值，赋值运算符和复合赋值运算符应返回左侧运算对象的引用//赋值(=)、下标([])、调用(())、成员访问箭头(-&gt;)必须为成员//复合赋值运算符一般为成员，但并非必须//递增(++)递减(--)解引用(*)通常为成员//有对称性的运算符如算数、相等性、关系、位运算符通常为非成员//输入(&gt;&gt;)输出(&lt;&lt;)必须为非成员class OverloadOperator&#123; friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const OverloadOperator&amp; oo); //第一个参数通常为流引用，第二个参数通常为常量引用 friend std::istream&amp; operator&gt;&gt;(std::istream&amp; is, OverloadOperator&amp; oo); //第一个参数通常为流引用，第二个参数通常为非常量引用 friend bool operator==(const OverloadOperator&amp; lhs, const OverloadOperator&amp; rhs); friend bool operator&lt;(const OverloadOperator&amp; lhs, const OverloadOperator&amp; rhs);public: OverloadOperator&amp; operator=(const OverloadOperator&amp;); //赋值运算符 OverloadOperator&amp; operator+=(const OverloadOperator&amp;);private: int m_i; std::string m_s;&#125;;std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const OverloadOperator&amp; oo)&#123; os &lt;&lt; oo.m_i &lt;&lt; &quot;: &quot; &lt;&lt; oo.m_s; //输出运算符一般不附加打印换行符 return os;&#125;std::istream&amp; operator&gt;&gt;(std::istream&amp; is, OverloadOperator&amp; oo)&#123; is &gt;&gt; oo.m_i &gt;&gt; oo.m_s; if (is) //输入运算符一般需要检查输入是否成功 &#123; /**/ &#125; else oo = OverloadOperator(); //输入发生错误时需要将对象置为合法状态（如默认状态） return is;&#125;bool operator==(const OverloadOperator&amp; lhs, const OverloadOperator&amp; rhs)&#123; return lhs.m_i == rhs.m_i &amp;&amp; lhs.m_s == rhs.m_s;&#125;bool operator!=(const OverloadOperator&amp; lhs, const OverloadOperator&amp; rhs) //通常用==或!=中一个来定义另一个&#123; return !(lhs == rhs);&#125;bool operator&lt;(const OverloadOperator&amp; lhs, const OverloadOperator&amp; rhs) //类中含有==时，如果两个对象时!=的，则一个对象应该可靠地&lt;另外一个&#123; if (lhs.m_i &lt; rhs.m_i) return true; else if (lhs.m_i == rhs.m_i) &#123; if (lhs.m_s &lt; lhs.m_s) return true; else return false; &#125; else return false;&#125;OverloadOperator operator+(const OverloadOperator&amp; lhs, const OverloadOperator&amp; rhs)//形参通常为常量引用，在有相关复合赋值运算符情况下常用复合赋值来实现算术运算符&#123; OverloadOperator sum = lhs; sum += rhs; return sum;&#125;OverloadOperator&amp; OverloadOperator::operator+=(const OverloadOperator&amp; rhs)&#123; m_i += rhs.m_i; m_s += rhs.m_s; return *this;&#125;class OverloadOperator2&#123;public: OverloadOperator2&amp; operator=(std::initializer_list&lt;std::string&gt; il); //initializer_list的赋值运算符 std::string operator[](size_t n) &#123; return (*strData)[n]; &#125; const std::string operator[](size_t n) const &#123; return (*strData)[n]; &#125;private: std::shared_ptr&lt;std::vector&lt;std::string&gt;&gt; strData;&#125;;OverloadOperator2&amp; OverloadOperator2::operator=(std::initializer_list&lt;std::string&gt; il)&#123; for (auto p = il.begin(); p != il.end(); ++p) strData-&gt;push_back(*p); return *this;&#125;//递增递减元素使得类能在元素序列前后移动class OO_ptr&#123;public: std::string&amp; deref() const; OO_ptr&amp; operator++(); //前置运算符，返回递增后对象的引用 OO_ptr&amp; operator--(); OO_ptr operator++(int); //后置运算符，与前置进行区别，参数增加一个不被使用的形参，返回的是递增前的值 OO_ptr operator--(int); std::string&amp; operator*() const //解引用运算符，返回元素的引用（尽管可以被定义为如固定返回42等各种操作） &#123; auto p = check(curr, &quot;out of range&quot;); return(*p)[curr]; &#125; std::string* operator-&gt;() const //箭头运算符，通过解引用运算符返回元素然后取地址，从而可以从元素对象中获取成员 &#123; return &amp;this-&gt;operator*(); &#125;private: std::shared_ptr&lt;std::vector&lt;std::string&gt;&gt; check(size_t, const std::string) const; std::weak_ptr&lt;std::vector&lt;std::string&gt;&gt; wptr; size_t curr = 0;&#125;;std::shared_ptr&lt;std::vector&lt;std::string&gt;&gt; OO_ptr::check(size_t i, const std::string msg) const&#123; auto ret = wptr.lock(); if (!ret) throw std::runtime_error(&quot;unbound OOBlob&quot;); if (i &gt;= ret-&gt;size()) throw std::out_of_range(msg); return ret;&#125;OO_ptr&amp; OO_ptr::operator++()&#123; check(curr, &quot;increament out of range&quot;); //若已经指向尾后，则不能再递增，报错 ++curr; return *this;&#125;OO_ptr OO_ptr::operator++(int) //形参无需命名。显式调用：p.operator++(0);&#123; OO_ptr ret = *this; //此处无需检查有效性 ++* this; //这里再用前置++来检查有效性 return ret;&#125;class PrintStr&#123;public: PrintStr(std::ostream&amp; o = std::cout, char c = &#x27; &#x27;) :os(o), sep(c) &#123;&#125; void operator()(const std::string&amp; s) const &#123; os &lt;&lt; s &lt;&lt; sep; &#125;private: std::ostream&amp; os; char sep;&#125;;void fun23()&#123; PrintStr errors(std::cerr, &#x27;\\n&#x27;); errors(&quot;wrong&quot;); //在cerr流写入&quot;wrong&quot;并输出一个换行符&#125;//标准库表示运算符的函数void fun24()&#123; std::plus&lt;int&gt; intAdd; //执行int加法的函数对象 int sum = intAdd(10, 30); //等同 int sum = 10 + 30;// minus&lt;T&gt; multiplies&lt;T&gt; divides&lt;T&gt; modulus&lt;T&gt; negate&lt;T&gt;取反// equal_to&lt;T&gt; not_equal_to&lt;T&gt; greater&lt;T&gt; greater_equal&lt;T&gt; less&lt;T&gt; less_equal&lt;T&gt;// logical_and&lt;T&gt; logical_or&lt;T&gt; logical_not&lt;T&gt;&#125;//function模板类 &lt;functional&gt;int addfun(int i, int j) &#123; return i + j; &#125;class dividefun&#123;public: int operator()(int i, int j) &#123; return i / j; &#125;&#125;;auto modfun = [](int i, int j) &#123;return i % j; &#125;;void fun25()&#123; std::map&lt;std::string, std::function&lt;int(int, int)&gt;&gt; binops = &#123; &#123;&quot;+&quot;, addfun&#125;, //函数指针（若出现重载函数名会造成二义性） &#123;&quot;-&quot;,std::minus&lt;int&gt;()&#125;, //标准库函数对象 &#123;&quot;/&quot;,dividefun()&#125;, //自定义函数对象 &#123;&quot;*&quot;,[](int i, int j) &#123;return i * j; &#125;&#125;, //未命名lambda对象 &#123;&quot;%&quot;, modfun&#125; //已命名lambda对象 &#125;; binops[&quot;/&quot;](10, 5);&#125;//类类型转换class SmallInt&#123; SmallInt(int i = 0) :val(i) &#123; if (i &lt; 0 || i &gt; 255) throw std::out_of_range(&quot;out of range&quot;); &#125; operator int() const &#123; return val; &#125; //类型转换为intprivate: std::size_t val;&#125;;//模板函数、显式实例化、显式模板实参、引用折叠、forward、模板特例化//原则：形参尽量用const引用，函数体中条件判断仅使用&lt;比较运算（或者less&lt;T&gt;()）//函数模板和类模板成员函数经常定义在头文件template &lt;typename T&gt; //模板参数列表，其中关键字typename可换成class；不能&lt;typename T, U&gt;，只能&lt;typename T, typename U&gt;int compare_a(const T&amp; v1, const T&amp; v2)&#123; if (v1 &lt; v2) return -1; if (v1 &gt; v2) return 1; return 0;&#125;template &lt;unsigned M, unsigned N&gt; //非类型模板参数，表示了一个值，可为整型、指针、左值引用，实例化时被用户提供的或编译器推断的值代替，绑定到整型的为常量表达式，绑定到指针或引用的需要有静态生存期（static或者nullptr等）int compare_a(const char(&amp;p1)[M], const char(&amp;p2)[N])&#123; return strcmp(p1, p2);&#125;template &lt;&gt; //模板特例化，用于处理内部实现不同的情况，尖括号内为空int compare_a(const char* const&amp; p1, const char* const&amp; p2)//特例化版本的T = const char*（指向常量的指针），对T的常量引用（const T&amp;）表明是指向常量的const指针（常量）的引用&#123; return strcmp(p1, p2);&#125;template &lt;typename T, class F = std::less&lt;T&gt;&gt; //默认模板实参，也是从右往左开始有默认实参int compare_b(const T&amp; v1, const T&amp; v2, F f = F()) //默认函数实参f，绑定到一个可调用对象&#123; if (f(v1 &lt; v2)) return -1; if (f(v1 &gt; v2)) return 1; return 0;&#125;template &lt;typename T&gt;typename T::value_type top_a(const T&amp; c) //默认使用作用域运算符访问的名字不是一个类型，所以需要再加一个typename指出该名字（此处value_type）是一个类型&#123; if (!c.empty()) return c.back(); else return typename T::value_type();&#125;template &lt;typename T&gt; void f1(T&amp;);template &lt;typename T&gt; void f2(T&amp;&amp;); //可以给T&amp;&amp;传递任何类型参数，但是会造成T推断出左值引用（如int&amp;），在函数体内编写代码进行T类型变量赋值时可能出问题（赋值还是绑定到引用上）//template &lt;typename T&gt; void f2(const T&amp;); //为了避免问题，通常用const T&amp;重载，使得这个定义绑定到左值和const右值，上一定义绑定到非const右值//extern template class TpltCls1&lt;std::string&gt;; //extern template，模板显式实例化声明语句，extern说明外部文件中已经有一个定义template int compare_a(const int&amp; v1, const int&amp; v2); //template，模板显式实例化定义语句（无需再写函数体）//无法推断T1类型（T2T3可以通过传入的实参推断），所以调用时需要显式指定。调用时传入的第一个模板实参会匹配第一个模板形参，以此类推template &lt;typename T1, typename T2, typename T3&gt;T1 sum_a(T2, T3);template &lt;typename T1, typename T2, typename T3&gt;T3 sum_b(T1, T2); //bad function，需要用户指定所有模板参数才能使用template &lt;typename It&gt;auto fcn_a(It beg, It end) -&gt; decltype(*beg) //尾置返回类型只能decltype参数列表中出现的形参，不能使用只在函数体中出现的变量。*beg返回的是元素引用&#123; /*...*/ return *beg;&#125;template &lt;typename It&gt;auto fcn_b(It beg, It end) -&gt; typename std::remove_reference&lt;decltype(*beg)&gt;::type //&lt;type_traits&gt; remove_reference移除引用返回元素本身，type是类内类型成员，需要加typename说明&#123; /*...*/ return *beg;&#125;int (*pf1)(const int&amp;, const int&amp;) = compare_a; //pf1函数指针，指向int版本实例void func_a(int(*)(const std::string&amp;, const std::string&amp;));//重载函数void func_a(int(*)(const int&amp;, const int&amp;)); //重载函数template &lt;typename F, typename T1, typename T2&gt;void flip_a(F f, T1&amp;&amp; v1, T2&amp;&amp; v2)&#123; f(std::forward&lt;T2&gt;(v2), std::forward&lt;T1&gt;(v1)); //使用时最好不使用using std::forward;声明而直接在使用时完整使用；forward&lt;T&gt;返回T&amp;&amp;，这里会保持实参v1v2所有细节（const、&amp;、&amp;&amp;等）传递给函数f&#125;template &lt;typename T&gt; std::string debug_rep(const T&amp;); //模板函数与非模板函数的重载（函数(1)），打印任何类型template &lt;typename T&gt; std::string debug_rep(T*); //模板函数与非模板函数的重载（函数(2)），打印指针类型std::string debug_rep(const std::string&amp;); //模板函数与非模板函数的重载（函数(3)），打印string类型void fun26()&#123; sum_a&lt;long&gt;(1, 2); //调用时显式指定，等同 sum_a&lt;long, int, int&gt;(1, 2); sum_b&lt;int, int, long&gt;(1, 2); //必须显式指定所有模板实参 compare_a&lt;long&gt;(12, 1024); //显式指定模板实参// func_a(compare_a); //× func_a(compare_a&lt;int&gt;); //√，需要显式提供模板实参消除func_a调用歧义 const char* p1 = &quot;hi&quot;, * p2 = &quot;hello&quot;; compare_a(&quot;hi&quot;, &quot;hello&quot;); //匹配compare_a(const char(&amp;p1)[M], const char(&amp;p2)[N])（比compare_a(const T&amp; v1, const T&amp; v2)更精确） compare_a(p1, p2); //匹配compare_a(const char* const&amp; p1, const char* const&amp; p2)（模板特例化） int i; const int ci = 5; f1(i); //推断T为int f1(ci); //推断T为const int// f1(5); //×，不能给左值引用传右值 //右值引用模板与左值引用模板推断T类型不太相同，函数参数为模板参数类型的右值引用（T&amp;&amp;）时，推断出的T类型的const和引用（&amp;、&amp;&amp;）属性得到保持。 //引用折叠只能用于简介创建的引用的引用，如类型别名或模板参数。X&amp; &amp;、X&amp; &amp;&amp;、X&amp;&amp; &amp;折叠为X&amp;，X&amp;&amp; &amp;&amp;折叠为X&amp;&amp; f2(5); //推断T为int f2(i); //引用折叠，i（变量）为左值，调用时推断T为int&amp;，引用折叠为int&amp; f2(ci); //引用折叠，ci（变量）为左值，调用时推断T为const int&amp;，引用折叠为const int&amp; std::string s(&quot;hi&quot;); const std::string* sp = &amp;s; debug_rep(&quot;hi&quot;); //函数(1)（T推断char[3]）(2)（T推断const char）(3)（需要const char*到string转换）匹配，调用T*这个特例版本（数组到指针被认为是精确匹配，相比于(3)的转换更加精确） debug_rep(s); //函数(1)（T推断string）(3)匹配，调用非模板函数 debug_rep(&amp;s); //函数(1)（T推断string*）(2)（T推断string）匹配，调用T*这个精确匹配版本 debug_rep(sp); //函数(1)（T推断string*）(2)（T推断const string）匹配，调用T*这个更特例的版本（相对于const T&amp;版本）&#125;//&lt;type_traits&gt;中的标准类型转换// 对Mod&lt;T&gt;，其中Mod为 若T为 则Mod&lt;T&gt;::type为 若T不为前面类型则Mod&lt;T&gt;::type为//remove_reference X&amp; 或 X&amp;&amp; X T//add_const X&amp; 或 const X 或 函数 T const T//add_lvalue_reference X&amp; 或 X&amp;&amp; X&amp; T&amp;//add_rvalue_reference X&amp; 或 X&amp;&amp; T T&amp;&amp;//remove_pointer X* X T//add_pointer X&amp; 或 X&amp;&amp; X* T*//make_signed unsigned X X T//make_unsigned 带符号类型 unsigned X T//remove_extent X[n] X T//remove_all_extents X[n1][n2]... X T//可变参数模板template &lt;typename T, typename ... Args&gt; //模板参数包Argsvoid foo_a(const T&amp; t, const Args&amp; ... rest) //函数参数包rest（若参数类型为模板参数包，参数则为函数参数包）&#123; std::cout &lt;&lt; sizeof...(Args) &lt;&lt; &quot; &quot; &lt;&lt; sizeof...(rest) &lt;&lt; std::endl;//sizeof...返回参数的数目&#125;template &lt;typename T&gt;std::ostream&amp; print_a(std::ostream&amp; os, const T&amp; t) &#123; return os &lt;&lt; t; &#125;template &lt;typename T, typename ... Args&gt;std::ostream&amp; print_a(std::ostream&amp; os, const T&amp; t, const Args&amp; ... rest) //...称为包扩展，此处扩展Args&#123; os &lt;&lt; t &lt;&lt; &quot;, &quot;; return print_a(os, rest...); //递归调用，...称为包扩展，此处扩展rest&#125;template &lt;typename ... Args&gt;std::ostream&amp; errorMsg(std::ostream&amp; os, const Args&amp; ... rest)&#123; return print_a(os, debug_rep(rest)...); //相当于对rest包内每个元素调用debug_rep&#125;//&lt;tuple&gt; tuplevoid fun27()&#123; using std::tuple; tuple&lt;size_t, size_t, size_t&gt; threeD; //成员的类型可相同。没设定初始值，则值初始化（有良好定义的值） tuple&lt;std::string, std::vector&lt;double&gt;, int, std::list&lt;int&gt;&gt; someVal(&quot;constants&quot;, &#123; 3.14, 2.718 &#125;, 42, &#123; 0,1,2,3,4,5 &#125;); //对应初始化 tuple&lt;size_t, size_t, size_t&gt; threeD2/* = */&#123; 1,2,3 &#125;; //初始化 threeD = &#123; 4,5,6 &#125;; //赋值，不能省略等号 auto smpl_item = std::make_tuple(&quot;as&quot;, 3, 20.00); //生成tuple，根据初始值推断tuple类型 std::get&lt;1&gt;(smpl_item); //返回第1项的引用（排列为类似数列，第0、1、2...项），smpl_item为左值，返回的是左值引用 std::get&lt;1&gt;(std::make_tuple(&quot;as&quot;, 2)); //make_tuple(&quot;as&quot;, 2)为右值，返回右值引用 threeD == threeD2; //关系运算必须有相同数量成员，对应项类型可以相互转换 threeD != threeD2; threeD &lt; threeD2; std::tuple_size&lt;decltype(threeD)&gt;::value; //返回给定tuple 类型 中成员的数量 std::tuple_element&lt;1, decltype(threeD)&gt;::type; //返回指定项（排列为类似数列，第0、1、2...项）成员的类型&#125;//&lt;bitset&gt; bitset，每个元素只能为0或1，每个元素占1 bitvoid fun28()&#123; using std::bitset; bitset&lt;32&gt; bitvec; //尖括号内为大小，必须常量表达式，说明有多少二进制位；默认值初始化每一位均为0 bitset&lt;20&gt; bitset2(1U); //使用值1U的低20位拷贝初始化bitset2（初始化低位为1，其他位为0），若尖括号给出的位数太多，则多的位置0，太少则高位被丢弃 bitset&lt;32&gt; bitvec3(&quot;1100&quot;); //string或字符数组指针初始化，字符串中下标小的字符在高位，所以为00...001100（前28位为0） std::string str0(&quot;1111111000000011001101&quot;); bitset&lt;32&gt; bitvec4(str0, 5, 4); //从str0[5]开始拷贝4个二进制位初始化（最低的4位） bitset&lt;32&gt; bitvec5(str0, str0.size() - 4); //使用最后四个字符初始化 bitset&lt;10&gt; bitvec6(std::string(&quot;aababba&quot;), 2, 4, &#x27;b&#x27;, &#x27;a&#x27;);//使用string第2下标开始拷贝4字符初始化bitvec6，其中b被初始化为0，a被初始化为1 bitvec |= 1UL &lt;&lt; 27; //第27位置位1 bitvec.any(); //是否有置位（为1）的位 bitvec.all(); //是否所有位都置位 bitvec.none(); //是否不存在置位的位（是否都为0） bitvec.count(); //置位的位数 bitvec.size(); //bitvec的位数（也就是尖括号内设定的位数） bitvec.test(2); //（从低位往高位的）第2位是否置位，检查下标越界。置位返回true，否则false bitvec.set(3/*, true*/); //把第3位设置为某bool值，默认bool值为true bitvec.set(); //把所有位置为true bitvec.reset(3); //把第3位复位为false bitvec.reset(); //把所有位复位为false bitvec.flip(3); //反转第3位的值 bitvec.flip(); //反转所有位的值 bitvec[3]; //const版本在第3位置位时返回true，否则false。不检查下标越界。非const版本可以设置指定位的值为特定bool值（或转化为bool的值） bitvec.to_ulong(); //转换为unsigned long，不能放入时抛出overflow_error bitvec.to_ullong(); //转换为unsigned long long，不能放入时抛出overflow_error bitvec.to_string&lt;char&gt;(&#x27;a&#x27;, &#x27;b&#x27;); //转换为string，其中0用字符&#x27;a&#x27;表示，1用字符&#x27;b&#x27;表示 std::cout &lt;&lt; bitvec; //二进制位打印为0或1输出到cout std::cin &gt;&gt; bitvec; //读取字符存入bitvec。字符非0非1，或者读取位数已经到达设定位数时停止&#125;//&lt;regex&gt; 正则表达式(regular expression)，默认使用ECMAScript语言（JavaScript的一个标准），正则在运行时“编译”，故避免创建不必要regex//正则由元字符和普通字符组成。普通字符就代表它原本的含义；元字符的意义不同于该字符本来的含义，而是有特殊的意义和功能//正则表达式可以是一个string，迭代器范围、指向空字符结尾的字符数组的指针、一个字符指针和一个计数器、花括号包围的字符列表// 元字符 含义// \\ 改变字符原本的含义，如\\&#123;表示一个&#123;符号，而\\d表示一个数字// ^ ^某字符 要求 字符串 以某字符开头，不占位。\\^表示一个真正的^符号。// $ 某字符$ 要求 字符串 以某字符结尾，不占位。\\$表示一个真正的$符号。// () 分组，改变默认的优先级。\\(表示一个真正的(符号。在模式中可以使用\\1来表示第1组已然捕获到的东西。// \\1,\\2,\\3 第n个组，第一组索引为1// \\b 指示字符串的边界（也就是指单词和空格间的位置），某字符\\b 要求边界的左边是某字符，\\b某字符 要求边界的右边是某字符。如&quot;er\\b&quot;匹配&quot;never&quot;的&quot;er&quot;而不匹配&quot;verb&quot;的&quot;er&quot;// \\B 指示字符串的非边界。如&quot;er\\B&quot;匹配&quot;verb&quot;的&quot;er&quot;而不匹配&quot;never&quot;的&quot;er&quot;// \\d 表示一个字符，该字符是0、1、2……9中的某一个// \\D 表示一个字符，该字符不是0、1、2……9中的任何一个// \\s 表示一个字符，该字符是空白符（空格、制表符、换页符、回车符、换行符）// \\S 表示一个字符，该字符不是空白符（空格、制表符、换页符、回车符、换行符）中任意一个// \\w 表示一个字符，该字符是数字、字母、下划线中的某一个。等价于[(0-9)(a-z)(A-Z)(_)]// \\W 表示一个字符，该字符不是数字、字母、下划线中的任何一个。等价于[]// \\n,\\t,\\f,\\r,\\v 一个换行符，制表符，换页符，回车符，垂直制表符// \\xhh,\\uhhh 一个十六进制字符或Unicode字符// . 表示一个除了\\n以外的任意一个字符。\\.表示一个真正的.符号。// | 字符串1 | 字符串2 表示一个字符串，该字符串是字符串1、字符串2中的一个// [] [字符1字符2字符3...]表示一个字符，该字符是字符1、字符2、字符3……中的某一个。中括号中出现的所有字符都是代表本身意思的字符（没有特殊含义），如[.]只能匹配.符号，而不能匹配任意符号。// [^字符1字符2字符3...]表示一个字符，该字符不是字符1、字符2、字符3……中的任何一个// [a-z]表示一个字符，该字符是a、b、c...z中的某一个（必须从小到大），[^A-Z]表示一个字符，该字符不是A、B、C...Z中的任何一个，[0-9]表示一个字符，该字符是0、1、2...9中的某一个// * 某字符* 要求某字符出现0到多次// + 某字符+ 要求某字符出现1到多次// ? 某字符? 要求某字符出现0次或1次// &#123;n&#125; 某字符&#123;n&#125; 要求某字符出现n次// &#123;n,&#125; 某字符&#123;n,&#125; 要求某字符出现n到多次// &#123;n,m&#125; 某字符&#123;n,m&#125; 要求某字符出现n到m次// [[:alnum:]] 一个字母或者数字// [[:alpha:]] 一个字母// [[:blank:]] 一个space或者tab// [[:cntrl:]] 一个控制字符// [[:digit:]] 一个数字，等于\\d// [[:d:]] 一个数字，等于\\d// [[:graph:]] 可打印非空白字符，相当于 [[:alnum:][:punct:]]// [[:lower:]] 一个小写字母// [[:print:]] 一个可打印字符，包括空白字符// [[:punct:]] 一个标点符号字符，但非space, digit, letter// [[:space:]] 一个空白字符，等于\\s// [[:upper:]] 一个大写字母// [[:xdigit:]] 一个十六进制数字//必须使用与输入类型匹配的正则库，即// 输入序列类型 使用正则表达式类//string regex smatch ssub_match sregex_iterator//const char* regex cmatch csub_match cregex_iterator//wstring regex wsmatch wssub_match wsregex_iterator//cosnt wchar_t* regex wcmatch wcsub_match wcregex_iterator//匹配标志 含义 格式标志 含义//match_default 等价与format_default format_default 用ECMAScript规则替换字符串//match_not_bol 不将首字符作为行首处理 format_sed 用POSIX sed规则替换字符串//match_not_eol 不将尾字符作为行尾处理 format_no_copy 不输出输入序列中未匹配的部分//match_not_bow 不将首字符作为单词首处理 format_first_only 只替换子表达式的第一次出现//match_not_eow 不将尾字符作为单词尾处理//match_any 多于一个匹配时返回任一匹配//match_not_null 不匹配空序列//match_continuous 匹配必须从输入的首字母开始//match_prev_avail 输入序列包含第一个匹配之前的内容void fun29()&#123; using std::regex; std::string pattern(&quot;[^c]ei&quot;); //匹配模式为开头不是c，但是后面接ei的三个字符的字符串 pattern = &quot;[[:alpha:]]*&quot; + pattern + &quot;[[:alpha:]]*&quot;; //零个或多个字母+匹配模式为开头不是c，但是后面接ei的三个字符+零个或多个字母的模式 std::string test_str = &quot;receipt freind thief receive&quot;; std::string number = &quot;(908) 555-1800&quot;; //格式字符串一些格式：$2 表示第2个子表达式；$` 表示匹配之前的字符；$&amp; 表示整个匹配；$&#x27; 表示后随匹配的字符 std::string fmt = &quot;$2.$5.$7&quot;; //格式，$2表示第2个子表达式（故此处为257三个表达式通过点连接起来形成string） std::string dest, temp; //定义regex时的标志，使用|隔开，默认添加ECMAScript（namespace regex） //icase忽略大小写 nosubs不保存匹配的子表达式 optimize执行速度优先于构造速度 ECMAScript使用ECMA-262语法 （剩余标志为POSIX语法不列举） regex r1(pattern, regex::icase); //正则表达式初始化对象r，regex::icase为对象r如何处理的标志，此处为匹配忽略大小写 regex r2(&quot;([[:alnum:]]+)\\\\.(cpp|cxx|cc)\\\\b&quot;, regex::icase); // \\\\. 前两个\\\\在c++解释为一个反斜杠\\，生成的\\.在正则里解释为一个点.。一个或多个字母+.+cpp cxx cc其中之一为结尾的模式 //两个圆括号，就有两个子表达式，分别为点之前的文件名部分，点之后的文件扩展名部分（本例表示搜索符合要求的C++文件名） regex r3(&quot;^(13)[4-9]\\\\d&#123;8&#125;$&quot;); //字符串以13开头，后面跟4-9中的一个，然后跟任意8位数字并结束 regex r4(&quot;(\\\\()?(\\\\d&#123;3&#125;)(\\\\))?([-. ])?(\\\\d&#123;3&#125;)([-. ])?(\\\\d&#123;4&#125;)&quot;);//7个子表达式：有0或1个(，有三个数字，有0或1个)，有0或1个-. （横杠、点、空格）之一，有三个数字，有0或1个-. 之一，有四个数字 r2 = r3; r2.assign(r3); r1.mark_count(); //r1中子表达式数目 r1.flags(); //返回r1的标志集 std::smatch results; //查找结果对象，包含1（整个匹配的string）+n（子表达式也就是分组数）个ssub_match类型的元素，可通过[]下标访问 //regex_match与regex_search的smatch对象和匹配格式标志可选，标志见前面 regex_match(test_str,/* results,*/ r1); //返回bool，整个序列test_str（string/迭代器范围/空字符结尾的字符数组指针）是否与正则表达式r匹配/*并将结果存在smatch类型的results里（results类型需要与seq兼容）*/ regex_search(test_str, results, r1/*, regex_constants::match_default*/); //寻找第一个匹配子序列，并将结果存在results里/*，匹配标志指明匹配规则（此处为默认ECMAScript规则）*/，返回bool是否匹配上 //regex_replace与format的匹配和格式标志可选，标志见前面 regex_replace(dest.begin(), temp.begin(), temp.end(), r4, fmt/*, std::regex_constants::match_default*/);// /*根据默认匹配模式*/从temp迭代器范围内搜索所有与r4匹配的子串，并将结果按格式fmt写入迭代器位置dest regex_replace(number, r4, fmt); //（根据默认匹配模式）从string number（或者空字符结尾的字符数组指针）搜索所有与r4匹配的子串，并将结果按格式fmt返回 results.format(&quot;$1 - find&quot;/*, std::regex_constants::format_default*/); //（根据默认格式）从string number（或者空字符结尾的字符数组指针）搜索与r4匹配的子串，并将结果按格式fmt返回 results.ready(); //是否已经调用regex_match和regex_search设置过smatch对象（results），设置过则返回true。对返回false的results进行操作是未定义的 results.size(); //返回最近一次匹配的正则表达式中子表达式（包含整个匹配即第0子表达式）的数目，匹配失败则返回0 results.empty(); //若results.size()为0则返回true results.prefix(); //一个ssub_match对象，表示当前匹配之前的序列 results.suffix(); //一个ssub_match对象，表示当前匹配之后的序列 //以下length position str省略实参时默认实参为0，实参为n就是要求第n个子表达式，实参为0表示要求整个匹配 results.length(/*0*/); //第0个匹配的子表达式（即整个匹配）的大小 results.length(1); //第1个匹配的子表达式的大小（此处指string长度） results.position(1); //第1个子表达式距离被查找序列开始的位置 results.str(1); //第1个子表达式匹配的string部分 results[1]; //对应第1个子表达式的ssub_match对象 results.begin(); //results中sub_match元素范围的迭代器（没有逆向迭代器） //ssub_match对象results[1] results[1].matched; //如果子表达式是匹配上的（也就是匹配结果string中含有此表达式，特殊情况如?在字符出现0次时也匹配，但是子表达式为空，是未匹配伤的），则返回true，否则false results[1].first; results[1].second; //指向子表达式首元素和尾后位置的迭代器，若未匹配则这两个迭代器相等 results[1].length(); //返回匹配串的长度，未匹配则返回0 results[1].str(); //返回匹配串string，未匹配则返回空string std::string s; s = results[1]; //ssub_match对象转化为string s，等价于 s = results[1].str(); std::sregex_iterator it(test_str.begin(), test_str.end(), r1); //定位到 迭代器范围内符合正则r1要求的字串位置 的迭代器（即调用regex_search） std::sregex_iterator end; //默认初始化为尾后迭代器 *it; //返回最近一次搜索（regex_search）结果的smatch对象 it-&gt;str(); //指针调用 it++; //查找下一匹配，返回递增后迭代器 ++it; //查找下一匹配，返回旧值 it == end; //都是尾后时相等，非尾后时构造序列和regex对象相等则相等&#125;//&lt;random&gt;随机数//随机数引擎类生成随机unsigned整数序列，随机数分布类生使用引擎返回服从特定概率分布的随机数//每次运行随机数发生器（引擎对象+分布对象的组合）时，都会生成相同随机数序列。可以通过设置 函数内引擎对象分布对象为static的 或者循环外声明对象 来保持发生器状态（为从之前的基础上运行），以便生成不同序列随机数void fun30()&#123; std::default_random_engine e; //生成随机无符号数 std::default_random_engine e2(2); //使用整型值2作为种子生成随机无符号数，种子相同会生成相同的随机数序列 e(); //生成下一个随机数 std::default_random_engine::result_type; //引擎生成的unsigned整型类型 e.seed(time(0)); //使用种子time(0)重置引擎状态（time(0)表示特定时刻到当前经过的时间（秒）） e.min(); //引擎可生成的最小值 e.max(); //引擎可生成的最大值 e.discard(2); //引擎推进2步 std::uniform_int_distribution&lt;unsigned&gt; u(0, 9); //生成[0,9]之间的均匀分布的unsigned随机数（尖括号内表示希望生成的值类型，uniform_int_distribution默认int） std::uniform_real_distribution&lt;/*double*/&gt; u2(0, 1);//生成[0,1]之间的均匀分布的double随机数（uniform_real_distribution默认double） std::normal_distribution&lt;&gt; n(4, 1.5); //正态分布，均值4，标准差1.5（normal_distribution默认double） std::bernoulli_distribution b(/*0.5*/); //伯努利分布，返回bool值/*，有50%概率返回true*/ u(e); //使用引擎e生成随机数并映射到指定分布 u.max(); //返回u能生成的最大值 u.min(); //返回u能生成的最小值 u.reset(); //重建u的状态，使得随后对u的使用不依赖u已经生成的值&#125;//异常处理//通过throw一个表达式引发异常，抛出异常后当前块内throw后面代码不再被执行，程序寻找catch块并一层一层往外找到main，这其中局部对象被自动销毁，找不到对应异常处理的代码时程序退出//throw表达式对异常对象拷贝初始化，（表达式为类类型，则类须含有可访问的析构函数和拷贝或移动构造函数；表达式为数组或函数类型，则被转换为指针）如果抛出指针，则在任何对应处理代码存在的地方，指针所指对象都必须存在//catch中的异常声明类型必须是完全类型（所有成员都已经在前面定义），可以使左值引用但不能是右值引用。//异常按照catch出现顺序逐一匹配，越专门的catch越应靠前出现。异常要与catch声明类型精确匹配，除了①非const向const类型转换②派生类向基类转换③数组/函数向指向数组/函数的指针转换外，其他所有转换规则都不在匹配过程中使用//当catch无法完整处理异常时，在catch内或catch语句调用的函数内使用throw; （空throw语句）重新抛出异常，让上一层函数处理异常。若catch引用类型，catch内对原来异常对象进行改变的改变对象被传播出去，否则还是原来异常对象被传播出去class UseExceptCls&#123;public: UseExceptCls(std::initializer_list&lt;int&gt;); virtual void f1() noexcept; //虚函数不抛出异常 virtual void f2(); //虚函数可能抛出异常private: std::shared_ptr&lt;std::vector&lt;int&gt;&gt; data;&#125;;UseExceptCls::UseExceptCls(std::initializer_list&lt;int&gt; il) try : //函数try语句块，try位置初始值列表冒号前，形参列表右括号后， data(std::make_shared&lt;std::vector&lt;int&gt;&gt;(il))&#123;&#125;catch (const std::bad_alloc&amp; e) //函数try语句块，使得catch可以处理初始值列表和函数内两部分的异常&#123;/*...*/&#125;//合成拷贝控制成员时，若对所有成员和基类所有操作都noexcept，则合成的成员noexcept，否则为noexcept(false)的；自己定义的析构函数无异常说明时，编译器合成异常说明，生成一个与 若编译器为类合成析构函数将得到的异常说明 一致的异常说明class DeriExCls :public UseExceptCls&#123;public: void f1() noexcept; //派生类相应虚函数必须不抛出异常 void f2() noexcept; //派生类相应虚函数可以抛出异常也可以不抛出异常&#125;;void exceptfun() noexcept; //noexcept不抛出异常。声明和定义必须都出现或都不出现。非成员函数在后置返回类型之前。成员函数const/引用说明符后，final/override/纯虚函数=0之前void exceptfun2() noexcept(true); //等同void exceptfun2() noexcept;，不会抛出异常void exceptfun3() noexcept(false); //等同void exceptfun3();，可能抛出异常void exceptfun4() noexcept&#123; throw std::exception(); //noexcept函数中抛出异常会使程序直接结束&#125;void exceptfun5() noexcept(noexcept(exceptfun())) &#123;&#125;//exceptfun5函数与exceptfun函数的异常说明相同void fun31()&#123; int i; try &#123; if (i &gt; 256) throw std::overflow_error(&quot;too big&quot;);//引发异常 &#125; catch (std::overflow_error e) //异常声明，此处精确匹配 &#123; std::cout &lt;&lt; e.what() &lt;&lt; std::endl; &#125; catch (const std::runtime_error&amp; e) //异常声明，左值引用 &#123; /*...*/ &#125; catch (...) //捕获所有异常 &#123; /*...*/ throw; //catch(...)常与空throw语句一起使用，重新抛出异常 &#125; noexcept(exceptfun()); //返回bool值，exceptfun函数是否不抛出异常（故返回true） noexcept(exceptfun3()); //返回false void (*pf1)() noexcept = exceptfun; //√，指针承诺不抛出异常则指向的函数必须也不抛出异常// void (*pf2)() noexcept = exceptfun3; //×，指针承诺不抛出异常则指向的函数必须也不抛出异常 void (*pf3)() = exceptfun2; //√，指针可能抛出异常则指向的函数可能抛出也可能不抛出异常 void (*pf4)() = exceptfun3; //√，指针可能抛出异常则指向的函数可能抛出也可能不抛出异常&#125;//命名空间、using//using声明引入同名函数时，隐藏相应外层作用域相关声明，若形参列表也相同则报错//using指示引入同名函数时，发生重载，若形参列表也相同不会报错，在调用时使用作用域运算符指定调用的版本int globalint = 1;namespace mynamespace //namespace后跟命名空间名。命名空间可以定义在不同部分，也可以在不同文件&#123; //只要能出现在全局作用域中的声明就能置于命名空间内，包括：类、变量、函数、模板、其他命名空间等 class myclass &#123; public: void func(); &#125;; class D :public myclass &#123; using myclass::func; //√，using声明语句只能指向基类成员，不能声明特定函数而只能声明名字// using std::cout; //×// using namespace std; //×，using指示不能出现在类作用域中 &#125;; double mydouble; int myint = 9; void f1(); void f2() &#123; std::cout &lt;&lt; &quot;fun&quot; &lt;&lt; std::endl; &#125; template &lt;typename T&gt; void f3(T&amp; v); namespace innerns &#123; &#125; inline namespace inlinensp //内联命名空间，必须在第一次出现时标明inline，后面再出现可以不标 &#123; int testint; &#125;&#125; //后面不加分号namespace &#123; //未命名的命名空间，其中成员有静态声明周期，第一次使用前创建，程序结束时销毁。一般使用未命名的命名空间代替本文件变量静态声明 //只能在一个文件内定义本文件的未命名的命名空间，不可跨越文件；头文件有未命名的命名空间时，包含该头文件的文件产生不同的未命名的命名空间 int unnameint;&#125;void fun32()&#123; ::globalint; //使用全局命名空间中的成员 mynamespace::testint; //使用内联命名空间内的成员可以不加内联命名空间名，而直接使用外部命名空间名 unnameint; //使用未命名的命名空间的成员，一定要与全局作用域内的名字有区别，否则歧义 namespace my = mynamespace; //命名空间别名 my::f1(); &#123;//using使得名字可以简写，指定了有效范围内使用的是哪个名字 using std::cout; //using声明，有效范围从声明开始到所在作用域结束为止 using namespace my; //√，using指示，使命名空间内所有名字都可见，有效范围从声明开始到所在作用域结束为止。不能出现在类作用域中 int myint = 50; //隐藏了mynamespace::myint &#125;&#125;//重载new delete//operator new返回类型必须为void*，第一个形参类型必须为size_t且不能有默认实参，可以有其他形参。void* operator new(size_t, void*)不能被重载。//operator delete必须声明noexcept，返回类型必须为void，第一个形参类型必须为void*。作为成员函数时可以有第二个形参为size_t类型。//new和delete运算符可以定义在全局或者类里。作为类成员时，不管是否写static，这两个操作符都是静态的（且不会操纵类的任何数据成员）。重载只是改变内存分配方式，而无法改变基本含义namespace special&#123; void* operator new(size_t size) &#123; if (void* mem = malloc(size)) //malloc接受待分配字节数size_t，成功则返回分配空间的指针，失败则返回0 return mem; else throw std::bad_alloc(); &#125; void operator delete(void* mem) noexcept &#123; free(mem); //free接受malloc返回的void*指针的副本 &#125; void fun() &#123; std::string s; new(&amp;s) std::string(&quot;a&quot;); //定位new，可以在某个位置（此处为s的地址）构造对象，某个位置可以是普通内存也可以是动态内存 &#125;&#125;//dynamic_cast、typeidclass runtimeBase&#123;public: virtual void fun() &#123;&#125;&#125;;class runtimeDeri :public runtimeBase&#123;public: void fun() override &#123;&#125;&#125;;class typeidBase&#123; friend bool operator==(const typeidBase&amp;, const typeidBase&amp;);protected: virtual bool equal(const typeidBase&amp;) const;&#125;;class typeidDeri : public typeidBase&#123;protected: bool equal(const typeidBase&amp;) const;&#125;;bool typeidBase::equal(const typeidBase&amp; rhs) const&#123; /*比较typeidBase对象*/ return false;&#125;bool typeidDeri::equal(const typeidBase&amp; rhs) const&#123; auto r = dynamic_cast&lt;const typeidDeri&amp;&gt;(rhs); //由于相等才能调用equal，当两个对象都是派生类对象时调用这个，所以可以放心将基类转换为派生类 /*比较typeidDeri对象*/ return false;&#125;bool operator==(const typeidBase&amp; lhs, const typeidBase&amp; rhs)&#123; return typeid(lhs) == typeid(rhs) &amp;&amp; lhs.equal(rhs); //typeid用法示例。先判断传入的对象动态类型是否一致，然后调用equal实现真正的比较&#125;void fun33()&#123; //dynamic_cast 要转换到的目标类型需要有虚函数。被转换的对象必须为目标类型的共有派生类、公有基类、目标类本身之一 runtimeBase* bp; runtimeBase&amp; br = *bp; runtimeBase&amp;&amp; brr = runtimeBase(); runtimeDeri* dp = dynamic_cast&lt;runtimeDeri*&gt;(bp); //指针转换为指针。类型转换失败则结果为0。对空指针执行dynamic_cast则得到所需类型的空指针 runtimeDeri&amp; dr = dynamic_cast&lt;runtimeDeri&amp;&gt;(br); //左值转换为左值。类型转换失败则抛出bad_cast异常 runtimeDeri&amp;&amp; drr = dynamic_cast&lt;runtimeDeri&amp;&amp;&gt;(brr); //非左值转换为右值。类型转换失败则抛出bad_cast异常 int n = 100; const type_info&amp; nInfo = typeid(n); //typeid括号内可以是变量 nInfo.name(); //类型的名字（名字生成方式依赖于系统） nInfo.before(typeid(double)); //一个类的typeid是否在另一个之前（顺序关系依赖于编译器） typeid(100) == typeid(int); //typeid括号内可以是表达式、类型名 typeid(100) != typeid(int); typeidBase obj1; typeidBase* p1; typeidDeri obj2; typeidDeri* p2 = new typeidDeri; p1 = p2; typeid(obj1) == typeid(p1); //false typeid(obj1) == typeid(*p1); //true typeid(&amp;obj1) == typeid(p1); //true typeid(obj1) == typeid(obj2); //false typeid(obj1) == typeid(typeidBase); //true typeid(*p1) == typeid(typeidBase); //true typeid(p1) == typeid(typeidBase*); //true typeid(p1) == typeid(typeidDeri*); //false runtimeDeri p3; runtimeBase* p4 = &amp;p3; typeid(*p4) == typeid(runtimeBase); //false typeid(*p4) == typeid(runtimeDeri); //true&#125;//enumenum class enum8 &#123; VI &#125;; //枚举的前置声明，限定作用域的枚举可以不指定成员大小，默认intvoid enumfun(int) &#123;&#125;void enumfun(enum8) &#123;&#125;void fun34()&#123; enum enum7 :unsigned long; //枚举的前置声明，不限定作用域的枚举必须指定成员大小 enum class enum1 //限定作用域的枚举类型，使用enum class或enum struct（没有访问限定区别），后跟枚举类型名 &#123; one, two, three //默认情况下枚举值从0开始，依次+1 &#125;; //结束时有分号 enum enum2 //不限定作用域的枚举类型，去掉class或struct &#123; red = 1, yellow, green //指定一个枚举值之后，后面没指定的依次+1 &#125;; enum &#123; floatPrec = 6, doublePrec = 10, double_doublePrec = 10 &#125;;//未命名的不限定作用域的枚举类型// enum enum4 &#123; red &#125;; //×，重复定义（与enum2::red）。不限定作用域枚举类型的枚举成员 作用域与枚举类型本身相同 enum class enum5 &#123; red &#125;; //√，限定作用域的枚举类型 与 不限定作用域的枚举类型 相同成员不算重复 enum enum6 :unsigned long long //对 限定作用域的枚举类型 指定enum中整数类型，内部枚举值超限会报错（默认int）。（不限定作用域枚举类型的潜在类型足够大，可以容纳枚举值） &#123; charTyp = 255, shortTyp = 65535, intTyp = 65535, longTyp = 4294967295UL, longlongTyp = 18446744073709551615ULL &#125;; // enum class enum7 &#123;&#125;; //×，与前置声明的 是否限定作用域 不一致 // enum enum7 :long &#123;&#125;; //×，与前置声明的 成员大小 不一致 // enum enum8 &#123;&#125;; //×，与前置声明的 是否限定作用域 不一致 enum2 eyes = green; //enum2::green// enum5 peppers = green; //×，enum5枚举成员不在作用域中，在作用域中的enum2::green类型错误 enum5 hair = enum5::red; //√，使用枚举成员或者另一个同类枚举对象给枚举对象赋值 constexpr enum1 e = enum1::one; //枚举成员是const的 int i = enum2::red; //√，不限定作用域枚举类型的枚举成员或对象可以隐式转换为整型// int j = enum1::one; //×，限定作用域枚举类型的枚举成员或对象不可以隐式转换为整型 enumfun(1); //匹配enumfun(int) enumfun(enum8::VI); //匹配enumfun(enum8)&#125;//类成员指针，指向类的非静态成员class MmbPtrCls&#123;public: int mmbint; void fun(); static const std::string MmbPtrCls::* data() //返回数据成员指针的函数，需要是静态的 &#123; return &amp;MmbPtrCls::str; &#125; char get_cursor() const; char get(); char get(int ht, int wd) const; const int fun2(); using Action2 = MmbPtrCls &amp; (MmbPtrCls::*)(); MmbPtrCls&amp; up(); MmbPtrCls&amp; down(); enum Directions &#123; UP, DOWN &#125;; MmbPtrCls&amp; move(Directions);private: static Action2 Menu[]; //静态成员，指向函数的指针的数组 std::string str;&#125;;using Action = char (MmbPtrCls::*)(int, int) const; //成员指针的类型别名MmbPtrCls&amp; action(MmbPtrCls&amp;, Action = &amp;MmbPtrCls::get); //使用成员指针的类型别名，指向成员函数指针的形参也可以有默认实参MmbPtrCls::Action2 MmbPtrCls::Menu[] = &#123; //定义并初始化指向函数的指针的数组 &amp;MmbPtrCls::up, &amp;MmbPtrCls::down&#125;;MmbPtrCls&amp; MmbPtrCls::move(Directions cm) &#123; return (this-&gt;*Menu[cm])(); &#125;void fun35()&#123; const int MmbPtrCls::* pi; //指向常量或非常量MmbPtrCls内int类型成员的成员指针 pi = &amp;MmbPtrCls::mmbint; //指向成员时需在当前有可访问性 MmbPtrCls obj, * p = &amp;obj; auto i = obj.*pi; //成员指针访问运算符 i = p-&gt;*pi; //成员指针访问运算符 const std::string MmbPtrCls::* pdata = MmbPtrCls::data(); //返回成员指针函数的使用 auto s = obj.*pdata; //等同 s = obj.*MmbPtrCls::data(); auto pmf = &amp;MmbPtrCls::get_cursor; //指向类的成员函数的指针，必须显式使用取地址运算符 const int (MmbPtrCls:: * pmfi)() = &amp;MmbPtrCls::fun2; //函数有const则需要加const char (MmbPtrCls:: * pmf2)(int, int) const = &amp;MmbPtrCls::get;//指向char get(int ht, int wd) const;，注意指针pmf2的括号，重载函数需要写上形参表示重载的哪个函数 char c1 = (obj.*pmf)(); //使用指向成员函数的指针时只能通过.*或-&gt;*调用，需要加括号，成员指针本身不是可调用对象 c1 = (p-&gt;*pmf2)(0, 0); Action fget = &amp;MmbPtrCls::get; //使用成员指针的类型别名 action(obj); //调用 含指向成员函数指针形参 的函数 action(obj, fget); //调用 含指向成员函数指针形参 的函数 action(obj, &amp;MmbPtrCls::get); //调用 含指向成员函数指针形参 的函数 obj.move(MmbPtrCls::UP); std::vector&lt;std::string&gt; svec; std::vector&lt;std::string*&gt; pvec; auto fp = &amp;std::string::empty; std::function&lt;bool(const std::string&amp;)&gt; fcn = &amp;std::string::empty;//使用function生成成员函数指针的可调用对象。调用成员函数时this对象被隐式传进来，这里括号内是将隐式形参转为显式形参，括号外bool是成员函数返回bool值 std::function&lt;bool(const std::string*)&gt; pcn = &amp;std::string::empty; // find_if(svec.begin(), svec.end(), fp); //×，指向成员函数的指针fp不是可调用对象，而find_if需要的是可调用对象 find_if(svec.begin(), svec.end(), fcn); //√，function类将成员函数调用转换为正确形式 find_if(pvec.begin(), pvec.end(), pcn); //√，function类将成员函数调用转换为正确形式 //&lt;functional&gt; mem_fn find_if(svec.begin(), svec.end(), mem_fn(&amp;std::string::empty));//使用mem_fn自动生成成员函数指针的可调用对象 auto fn = mem_fn(&amp;std::string::empty); fn(*svec.begin()); //可通过对象或者指针调用mem_fn生成的对象 fn(&amp;svec[0]); //可通过对象或者指针调用mem_fn生成的对象 using std::placeholders::_1; find_if(svec.begin(), svec.end(), bind(&amp;std::string::empty, _1));//使用bind生成成员函数指针的可调用对象，需要将隐式传入的形参this转为显式传入 auto fn2 = bind(&amp;std::string::empty, _1); fn2(*svec.begin()); //可通过对象或者指针调用bind生成的对象 fn2(&amp;svec[0]); //可通过对象或者指针调用bind生成的对象&#125;//union//可以有多个数据成员，但同一时刻只能有一个成员有值，此时其他成员变为未定义状态。除了引用类型之外，数据成员可以是绝大多数类型，包含类类型//使用含有类类型的union要更复杂，若类类型（如string）成员自定义了默认构造函数或拷贝控制成员，在union中相应函数的合成版本是被删除的。若类中定义了含有删除的拷贝控制成员的union，类的相应成员也是删除的//union成员默认public，也可以指定protected和private。union空间大小为至少是最大的数据成员的大小//union可以定义成员函数，包括构造、析构函数，但是不能有虚函数，不能作为基类和派生类void fun36()&#123; union Token //union声明 &#123; char cval; int ival; double dval; &#125;; union //匿名union，不能包含protected和private，也不能定义成员函数 &#123; char c2; int i2; &#125;; Token token1 = &#123; &#x27;a&#x27; &#125;; //初始化一个union，初始值默认初始化第一个成员（即此处初始化了其中的cval成员） Token token2; //未初始化的union Token* pt = &amp;token1; //指向union的指针 token2.dval = 42.0; pt-&gt;ival = 42; c2 = 5; //匿名union的成员可以直接访问&#125;//通过类管理union，通常应用在union中含有类类型成员情况class Token2&#123;public: Token2() :tok(INT), ival(0) &#123;&#125; Token2(const Token2&amp; t) :tok(t.tok) &#123; copyUnion(t); &#125;//进入函数体内执行copyUnion时，拷贝者（相对于被拷贝者）已经被默认初始化了，按照顺序是初始化的第一个成员，不是string，所以不需要进行特殊处理（如销毁string） Token2&amp; operator=(const Token2&amp;); ~Token2() &#123; if (tok == STR) sval.~basic_string(); &#125;//若存的是string，则需要调用string析构函数手动析构，否则为内置类型可以什么也不做 Token2&amp; operator=(const std::string&amp;); Token2&amp; operator=(char); Token2&amp; operator=(int); Token2&amp; operator=(double);private: enum &#123; INT, CHAR, DBL, STR &#125; tok; //直接在最后写变量名，表明该变量的类型是前面这个未命名enum类型 union &#123; char cval; int ival; double dval; std::string sval; //string有析构函数，所以需要类自定义析构函数 &#125;; void copyUnion(const Token2&amp;);&#125;;void Token2::copyUnion(const Token2&amp; t)&#123; switch (t.tok) &#123; case INT: ival = t.ival; break; case CHAR: cval = t.cval; break; case DBL: dval = t.dval; break; case STR: new(&amp;sval) std::string(t.sval); break; &#125;&#125;Token2&amp; Token2::operator=(const Token2&amp; t)&#123;//在赋值运算符调用时，左侧Token2对象可能已经存储了string值，所以在右侧值赋值过来左侧之前，先把左侧string析构掉 if (tok == STR &amp;&amp; t.tok != STR) sval.~basic_string(); if (tok == STR &amp;&amp; t.tok == STR) //左右都存了string，可以直接复制过来，不用构造string sval = t.sval; else //左右都不是string、左string右不string（此时string已经在之前被析构了）、左不string右string，都可走这条线直接copy copyUnion(t); tok = t.tok; return *this;&#125;Token2&amp; Token2::operator=(int i)&#123; if (tok == STR) sval.~basic_string(); ival = i; tok = INT; return *this;&#125;Token2&amp; Token2::operator=(const std::string&amp; s)&#123; if (tok == STR) sval = s; else new(&amp;sval) std::string(s); //定位new，本来不是string的时候先构造一个string tok = STR; return *this;&#125;//volatile（尽量不用！也不能解决多线程中先后顺序问题！）//程序中的某个值可能会被程序的控制或检测之外因素（如被系统时钟定期刷新）改变时，需要声明成volatile。volatile告诉编译器不要对这样的对象进行优化//volatile具体含义与编译器有关，要使使用了volatile的程序在移植后有效，需要进行某些改变class Vo&#123;public: Vo() = default; Vo(const volatile Vo&amp;); //volatile可以与const共存，顺序随意。从volatile进行拷贝的函数 Vo&amp; operator=(volatile const Vo&amp;);//volatile赋值给非volatile对象 Vo&amp; operator=(volatile const Vo&amp;) volatile;//volatile赋值给volatile对象 volatile void fun(); //只有volatile成员函数能被volatile对象调用&#125;;void fun37()&#123; int i; volatile int dis_reg; //该值可能发生改变 volatile int* ivp; //指向一个volatile对象 int* volatile vip; //volatile指针，指向一个int volatile int* volatile vivp;//指向一个volatile int对象的volatile指针// int* ip = &amp;dis_reg; //×，只能用指向volatile的指针去指向volatile对象，引用类似 ivp = &amp;dis_reg; //√ vip = &amp;i; //√ vivp = &amp;dis_reg; //√ volatile int iax[10]; //每个元素都是volatile的 volatile Vo vo; //类的每个成员都是volatile的&#125;//链接指示//使用链接指示指出非C++函数所用的语言，该语言的编译器需要有权访问且与C++编译器兼容//若连接到的语言支持重载，则可用链接指示包含进所有重载函数。如C不支持重载，所以只能包含进一个。可以定义与C包含进来的函数相同名字的函数来重载。extern &quot;C&quot; size_t strlen(const char*); //单语句链接指示，extern 表示语言的字符串 函数声明extern &quot;C&quot; //复合语句链接指示，一次性建立多个链接&#123; int strcmp(const char*, const char*); char* strcat(char*, const char*);&#125;extern &quot;C&quot;&#123;#include &lt;string.h&gt; //可以包含头文件&#125;extern &quot;C&quot; void (*pf)(int); //指向其他语言的函数的指针void (*pf2)(int);//pf = pf2; //×，类型不同extern &quot;C&quot; void exf1(void(*)(int)); //给exf1传递的函数指针也必须是C语言函数extern &quot;C&quot; typedef void FC(int); //类型别名，FC是指向C函数的指针void exf2(FC*); //exf2是C++函数，传进来的形参是要C函数指针extern &quot;C&quot; double exf3(int i) &#123; /*...*/ &#125; //使用链接指示进行函数定义，可以令C++函数在其他语言中可用 二、C++类部分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860////////////////////////////////////////////////////////////////// 学习《C++ Primer》笔记，类部分// edit by 猫耳堀川雷鼓/neko-horikawaraiko////////////////////////////////////////////////////////////////#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;set&gt;#include &lt;vector&gt;//①若一个类需要自定义析构函数，则几乎同样需要自定义拷贝赋值运算符和拷贝赋值函数（基类除外，基类总需要一个虚析构函数，虚析构函数（不管是否= default）也同时阻止了合成移动操作）//②若一个类需要自定义拷贝构造函数（拷贝赋值运算符），则几乎同样需要自定义拷贝赋值运算符（拷贝构造函数）//③若一个类需要自定义拷贝构造函数与拷贝赋值运算符，不一定需要自定义析构函数//若类的 ↓ ，则该类的 → | 合成析构函数 | 合成拷贝构造函数 | 合成拷贝赋值运算 | 合成默认构造函数 | 合成移动构造函数 | 合成移动赋值运算符//某成员的析构函数= delete / 不可访问（如private） | = delete | = delete | | = delete | |//某成员的拷贝构造函数= delete / 不可访问 | | = delete | | | |//某成员的拷贝赋值运算符= delete / 不可访问 | | | = delete | | |//有const/引用成员 | | | = delete | | | = delete//引用成员无类内初始化器，const成员类内无初始化器且未定义默认构造函数 | | | | = delete | |//析构函数 = delete / 不可访问（如private） | | | | | = delete |//某成员有拷贝构造且无移动构造，或未定义拷贝构造且不能合成移动构造 | | | | | = delete | = delete//某成员的移动构造函数= delete | | | | | = delete |//某成员的移动赋值运算符= delete | | | | | | = delete//有移动操作（移动函数和/或移动赋值运算符） | | = delete | = delete | | |//若基类的 ↓ ，则派生类的 → | 合成默认构造函数 | 合成拷贝构造函数 | 合成拷贝赋值运算符 | 合成析构函数 | 合成移动构造函数 | 合成移动赋值运算符//默认构造函数= delete / 不可访问 | = delete | | | | |//拷贝构造函数= delete / 不可访问 | | = delete | | | |//拷贝赋值运算符= delete / 不可访问 | | | = delete | | |//析构函数= delete / 不可访问 | = delete | = delete | | = delete | = delete |//移动构造函数= delete | | | | | = delete |//移动赋值运算符= delete | | | | | | = delete//所以基类显式定义拷贝后，还需要移动就需要也显式定义，否则会按照拷贝操作执行；显式定义移动后，必须显式定义拷贝，否则为拷贝为删除的//拷贝构造函数、拷贝赋值运算符、移动构造函数、移动赋值运算符、析构函数//赋值运算符需要较好处理自赋值能力，有着析构函数和拷贝构造函数的工作，所以一般先将右侧运算对象拷贝到局部临时对象（主要为指针指向的对象），再销毁左侧对象，再将临时对象拷贝到左侧对象//一个类未定义拷贝控制成员时，编译器会合成相应的拷贝构造函数、拷贝赋值运算符、析构函数//一个类未定义任何拷贝控制成员（拷贝构造、拷贝赋值运算符、析构），且类内非static成员都可以移动时，编译器才合成移动构造函数或移动赋值运算符；否则不会合成移动构造函数或移动赋值运算符//移动操作不会被隐式定义为删除的函数，若通过= default要求编译器生成移动操作，但编译器不能移动所有成员，则会被改为= deletetemplate &lt;class T&gt; class std::hash; //友元声明所需class Sales_data2&#123; friend class std::hash&lt;Sales_data2&gt;; friend std::istream&amp; operator&gt;&gt;(std::istream&amp;, Sales_data2&amp;); friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp;, const Sales_data2&amp;); friend bool operator==(const Sales_data2&amp;, const Sales_data2&amp;);public: Sales_data2() = default; //= default 显式要求编译器生成合成版本函数 （= default 只能给构造、拷贝、赋值、移动、析构函数） Sales_data2(const std::string&amp; s) :bookNo(s) &#123;&#125; Sales_data2(const std::string&amp; s, unsigned n, double p) : bookNo(s), units_sold(n), revenue(p* n) &#123;&#125; explicit Sales_data2(std::istream&amp; is); ~Sales_data2() &#123;&#125; //析构函数，唯一，不能被重载，先执行函数体，然后按初始化逆序销毁成员（此处与合成的析构函数等价） Sales_data2(const Sales_data2&amp;); //拷贝构造函数，第一个参数是本身类型的引用，任何额外参数都有默认值 Sales_data2&amp; operator+=(const Sales_data2&amp;); Sales_data2&amp; operator=(const Sales_data2&amp;); //赋值运算符，必须定义为成员函数，参数为本类型引用，返回指向左侧运算对象的引用 std::string isbn() const &#123; return bookNo; &#125; Sales_data2&amp; combine(const Sales_data2&amp;) &#123;&#125;private: double avg_price() const &#123; return units_sold ? revenue / units_sold : 0; &#125; std::string bookNo; unsigned units_sold = 0; double revenue = 0.0;&#125;;//自定义异常处理类class out_of_stock :public std::runtime_error&#123;public: explicit out_of_stock(const std::string&amp; s) :std::runtime_error(s) &#123;&#125;&#125;;class isbn_mismatch :public std::logic_error&#123;public: explicit isbn_mismatch(const std::string&amp; s) :std::logic_error(s) &#123;&#125; isbn_mismatch(const std::string&amp; s, const std::string&amp; lhs, const std::string&amp; rhs) : std::logic_error(s), left(lhs), right(rhs) &#123;&#125; const std::string left, right;&#125;;Sales_data2::Sales_data2(const Sales_data2&amp; orig) :bookNo(orig.bookNo), units_sold(orig.units_sold), revenue(orig.revenue)//拷贝构造函数（此处与合成的拷贝构造函数等价）&#123;&#125;Sales_data2 operator+(const Sales_data2&amp; lhs, const Sales_data2&amp; rhs)&#123; Sales_data2 sum = lhs; sum += rhs; return sum;&#125;Sales_data2&amp; Sales_data2::operator+=(const Sales_data2&amp; rhs)&#123; if (isbn() != rhs.isbn()) throw isbn_mismatch(&quot;wrong isbns&quot;, isbn(), rhs.isbn()); units_sold += rhs.units_sold; revenue += rhs.revenue; return *this;&#125;bool operator==(const Sales_data2&amp; lhs, const Sales_data2&amp; rhs)&#123; return lhs.isbn() == rhs.isbn() &amp;&amp; lhs.units_sold == rhs.units_sold &amp;&amp; lhs.revenue == lhs.revenue;&#125;bool operator!=(const Sales_data2&amp; lhs, const Sales_data2&amp; rhs)&#123; return !(lhs == rhs);&#125;Sales_data2&amp; Sales_data2::operator=(const Sales_data2&amp; rhs)//赋值运算符（此处与合成的赋值运算符等价）&#123; bookNo = rhs.bookNo; units_sold = rhs.units_sold; revenue = rhs.revenue; return *this;&#125;namespace std //打开std命名空间&#123; template &lt;&gt; //模板特例化必须定义在原始模板命名空间中 struct hash&lt;Sales_data2&gt; //特例化的hash，必须定义以下三方面 &#123; typedef size_t result_type; //(1)类型成员result_type（名字不能变），为调用运算符的返回类型 typedef Sales_data2 argument_type; //(1)类型成员argument_type（名字不能变），为调用运算符的参数类型，需要此类型有== size_t operator()(const Sales_data2&amp; s) const; //(2)重载的调用运算符，接受同期关键字类型的对象，返回size_t //合成拷贝控制成员和默认构造函数 //(3)默认构造函数和拷贝赋值运算符 &#125;; size_t hash&lt;Sales_data2&gt;::operator()(const Sales_data2&amp; s) const &#123; return hash&lt;string&gt;()(s.bookNo) ^ //常定义哈希异或运算。定义三个成员的哈希值从而与operator==兼容 hash&lt;unsigned&gt;()(s.units_sold) ^ hash&lt;double&gt;()(s.revenue); &#125;&#125; //关闭std命名空间，后面无分号//////////////////////////////////////////////////////////////////////////class HasPtr_Ptr//类指针型HasPtr&#123;public: HasPtr_Ptr(const std::string&amp; s = std::string()) :ps(new std::string(s)), use(new size_t(1)) &#123;&#125; HasPtr_Ptr(const HasPtr_Ptr&amp; p) :ps(p.ps), use(p.use) &#123; ++*use; &#125; HasPtr_Ptr&amp; operator=(const HasPtr_Ptr&amp;); ~HasPtr_Ptr(); //需要自定析构函数释放动态内存private: std::string* ps; size_t* use;&#125;;HasPtr_Ptr&amp; HasPtr_Ptr::operator=(const HasPtr_Ptr&amp; rhs)&#123;//此处HasPtr_Ptr类似shared_ptr，使用引用计数器标明指向同一对象的指针数量，所以不需要将ps指向的对象拷贝到临时对象 ++* rhs.use; //递增引用计数，避免自赋值导致use递减时为0而销毁对象 if (-- * use == 0) //析构函数作用，销毁左侧对象 &#123; delete ps; delete use; &#125; ps = rhs.ps; //拷贝到左侧对象 use = rhs.use; return *this;&#125;HasPtr_Ptr::~HasPtr_Ptr()&#123; if (-- * use == 0) &#123; delete ps; delete use; &#125;&#125;//////////////////////////////////////////////////////////////////////////class HasPtr_Val//类值型HasPtr&#123; friend void swap(HasPtr_Val&amp;, HasPtr_Val&amp;);public: HasPtr_Val(const std::string&amp; s = std::string()) :ps(new std::string(s)) &#123;&#125; HasPtr_Val(const HasPtr_Val&amp; p) :ps(new std::string(*p.ps)) &#123;&#125; HasPtr_Val(HasPtr_Val&amp;&amp; p) noexcept :ps(p.ps) &#123; p.ps = 0; &#125;// HasPtr_Val&amp; operator=(const HasPtr_Val&amp;); HasPtr_Val&amp; operator=(HasPtr_Val); //定义了swap的类常用swap实现赋值运算符 ~HasPtr_Val() &#123; delete ps; &#125;private: std::string* ps; size_t* use;&#125;;inline void swap(HasPtr_Val&amp; lhs, HasPtr_Val&amp; rhs)&#123; using std::swap; //使得下面调用若有特化版本就调用特化版本，不存在时才调用模板版本 swap(lhs.ps, rhs.ps); //只交换指针即可&#125;/*HasPtr_Val&amp; HasPtr_Val::operator=(const HasPtr_Val&amp; rhs)&#123;//此处HasPtr_Val类似值行为，需要将ps指向的对象拷贝到临时对象 std::string* newp = new std::string(*rhs.ps); //右侧运算对象拷贝到局部临时对象 delete ps; ps = newp; return *this;&#125;*/HasPtr_Val&amp; HasPtr_Val::operator=(HasPtr_Val rhs) //根据传递来的是左值/右值，分别拷贝/移动了rhs进来，所以同时有拷贝和移动赋值运算符的作用&#123; swap(*this, rhs); return *this;&#125;class useHP_Val&#123;public: HasPtr_Val h;&#125;;void swap(useHP_Val&amp; lhs, useHP_Val&amp; rhs)&#123; using std::swap; swap(lhs.h, rhs.h); //虽然前面使用了std::swap，但是此处根据实参类型不仅查找std还查找实参类HasPtr_Val所在的命名空间，最终选择最佳匹配HasPtr_Val定义的swap函数来实现&#125;//////////////////////////////////////////////////////////////////////////class NoCopy&#123;public: NoCopy() = default; NoCopy(const NoCopy&amp;) = delete; //= delete 显式要求编译器阻止拷贝 （= delete 适用除析构外任何函数） NoCopy&amp; operator=(const NoCopy&amp;) = delete; //= delete 显式要求编译器阻止赋值 ~NoCopy() = default;private: int i;&#125;;//////////////////////////////////////////////////////////////////////////class StrVec //string的vector&#123;public: StrVec() :elements(nullptr), first_free(nullptr), cap(nullptr) &#123;&#125; StrVec(const StrVec&amp;); //拷贝构造 StrVec(StrVec&amp;&amp;) noexcept; //移动构造函数，第一个参数为该类型的右值引用，额外参数都有默认实参，通常使用noexcept表示不会抛出异常，移动后源对象必须有效、可析构 StrVec&amp; operator=(const StrVec&amp;); //拷贝赋值运算符 StrVec&amp; operator=(StrVec&amp;&amp;) noexcept; //移动赋值运算符，通常使用noexcept表示不会抛出异常，移动后源对象必须有效、可析构 ~StrVec(); //析构 void push_back(const std::string&amp;); size_t size() const &#123; return first_free - elements; &#125; size_t capacity() const &#123; return cap - elements; &#125; std::string* begin() const &#123; return elements; &#125; std::string* end() const &#123; return first_free; &#125; template &lt;typename ... Args&gt; void emplace_back(Args&amp;&amp;...);private: std::string* elements; //数组首指针 std::string* first_free; //第一个空闲元素指针 std::string* cap; //尾后指针 static std::allocator&lt;std::string&gt; alloc; void chk_n_alloc() &#123; if (size() == capacity()) reallocate(); &#125; //是否容量够 std::pair&lt;std::string*, std::string*&gt; alloc_n_copy(const std::string*, const std::string*); //将一个范围拷贝进来 void free(); //销毁元素，释放空间 void reallocate(); //重分配空间，并将原来元素拷贝进来&#125;;StrVec::StrVec(StrVec&amp;&amp; s) noexcept //声明和定义中都要有noexcept，初始化列表在noexcept后面 :elements(s.elements), first_free(s.first_free), cap(s.cap)&#123; s.elements = s.first_free = s.cap = nullptr; //通过置空指针置于可析构状态&#125;StrVec&amp; StrVec::operator=(StrVec&amp;&amp; rhs) noexcept&#123; if (this != &amp;rhs) &#123; free(); elements = rhs.elements; first_free = rhs.first_free; cap = rhs.cap; rhs.elements = rhs.first_free = rhs.cap = nullptr; &#125; return *this;&#125;template&lt;typename ...Args&gt;inline void StrVec::emplace_back(Args &amp;&amp; ... args)&#123; chk_n_alloc(); alloc.construct(first_free++, std::forward&lt;Args&gt;(args)...); //Args包和args包都扩展&#125;void StrVec::reallocate()&#123; auto newcapacity = size() ? 2 * size() : 1; auto first = alloc.allocate(newcapacity); auto last = uninitialized_copy(make_move_iterator(begin()), //普通迭代器转为移动迭代器，由于uninitialized_copy使用construct“拷贝”元素 make_move_iterator(end()), first); //所以传入移动迭代器后解引用为右值，const将使用移动构造函数来构造元素 free(); elements = first; first_free = last; cap = elements + newcapacity;&#125;//////////////////////////////////////////////////////////////////////////class Foo&#123;public: Foo&amp; operator=(const Foo&amp;)&amp;; //指出返回的*this为一个左值 Foo sorted()&amp;&amp;; //指出返回的*this为一个右值；重载时引用限定符要么都加要么都不加，&amp;&amp;通过右值调用本函数；引用限定符只能用于非static成员函数 Foo sorted() const&amp;; //&amp;在const后；重载时引用限定符要么都加要么都不加，&amp;通过左值调用本函数&#125;;Foo&amp; Foo::operator=(const Foo&amp;)&amp; //&amp;必须同时出现在声明和定义中&#123; /*do something*/ return *this;&#125;////////////////////////////////////////////////////////////////////////////虚函数、派生、继承、友元//虚函数：任何除了构造函数之外的非静态函数都可以是虚函数class Quote //派生类定义前基类必须已定义&#123;public: Quote() = default; Quote(const std::string&amp; book, double sale_price) :bookNo(book), price(sale_price) &#123;&#125; Quote(const Quote&amp;) = default; Quote(Quote&amp;&amp;) = default; Quote&amp; operator=(const Quote&amp;) = default; Quote&amp; operator=(Quote&amp;&amp;) = default; virtual ~Quote() = default; //基类通常定义虚析构函数以保证执行正确的析构函数版本（基类的还是派生类的） std::string isbn() const &#123; return bookNo; &#125; virtual double net_price(size_t n) const &#123;return n * price;&#125; //需要派生类自定义的函数定义为虚函数，virtual关键字只能出现在类内声明，不能用于类外部定义 virtual Quote* clone() const&amp; &#123; return new Quote(*this); &#125; virtual Quote* clone()&amp;&amp; &#123; return new Quote(std::move(*this)); &#125;private: std::string bookNo;protected: double price = 0.0;&#125;;//派生类不继承默认、拷贝、移动构造函数//抽象基类，含有纯虚函数，不能创建抽象基类对象class Disc_quote :public Quote&#123;public: Disc_quote() = default; //基类成员也会被默认初始化 Disc_quote(const std::string &amp; book, double price, size_t qty, double disc)//使用基类构造函数初始化基类部分 :Quote(book, price), quantity(qty), discount(disc) &#123;&#125; Disc_quote(const Disc_quote&amp; d) :Quote(d) &#123;&#125; //需显式使用基类拷贝构造函数，否则基类部分会执行默认构造函数 Disc_quote&amp; operator=(const Disc_quote&amp; d) //需显式使用基类拷贝赋值运算符 &#123; Quote::operator=(d);/**/ &#125; ~Disc_quote(); //无需显式调用基类析构函数，基类析构函数自动执行 double net_price(size_t n) const = 0; //纯虚函数，类内声明的最后写 = 0，可以进行定义，但只能在类外部定义 std::pair&lt;size_t,double&gt; discount_policy() const &#123; return &#123; quantity,discount &#125;; &#125;protected: size_t quantity = 0; double discount = 0.0;&#125;;//派生列表的访问说明符表示派生类从基类继承的成员是否 对用户/对派生类的派生类 可见，派生类本身可访问基类public、protected成员//基类中的 → 成员，经过派生列表 ↓ 的访问说明符， public protected private//变为对外/对派生类的派生类↘// public public protected private// protected protected protected private// private private private private//可将派生类对象绑定到基类引用/指针，基类引用/指针只绑定/指向派生类对象的基类部分上，可把派生类对象当做基类对象用（隐式转换，只适用 引用/指针 ），但不能 隐式 将基类转换成派生类class Bulk_Quote :public Disc_quote //派生类在前置声明时不加派生列表，即class Bulk_Quote;&#123;public: //对构造函数的using保持基类来的访问级别不变（基类public这里也public，基类private这里也private），保持基类来的explicit和constexpr不变 //基类某构造函数的形参含有默认实参时，派生类using继承该构造函数的多个版本，为从右往左每次减少一个形参 //派生类定义了相同形参的构造函数的话，便不会从基类继承相应构造函数，而使用派生类自己的这一个构造函数 using Disc_quote::Disc_quote; //使用using显式注明继承直接基类的构造函数，此时派生类自己的初始成员默认初始化或使用类内初始值初始化 //override好习惯，位置在形参列表、const、引用限定符后面，显式表明重写的哪个虚函数；若不重写虚函数，派生类直接继承基类版本，若基类的为纯虚函数，不重写则仍为纯虚函数，类成为抽象基类； //开头virtual可省略；重写函数必须相同类型形参，最好默认实参相一致，返回类型除非返回本类的指针（基类返回基类指针，派生类返回派生类指针），其他情况必须也相同 double net_price(size_t n) const override; static void statemem() &#123;&#125; //静态成员，在某基类及其派生类中只存在一个，可通过基类、派生类、对象访问 Bulk_Quote* clone() const&amp; &#123; return new Bulk_Quote(*this); &#125; Bulk_Quote* clone()&amp;&amp; &#123; return new Bulk_Quote(std::move(*this)); &#125;private: size_t min_quantity = 0;&#125;;double Bulk_Quote::net_price(size_t n) const&#123; if (n &gt;= min_quantity) return n * (1 - discount) * price; else return n * price; //可以用return Quote::net_price(n);加作用域运算符强行指定虚函数版本&#125;double print_total(std::ostream&amp; os, const Quote&amp; item, size_t n)&#123; double ret = item.net_price(n); os &lt;&lt; &quot;ISBN: &quot; &lt;&lt; item.isbn() &lt;&lt; &quot; # sold: &quot; &lt;&lt; n &lt;&lt; &quot; total due: &quot; &lt;&lt; ret &lt;&lt; std::endl; return ret;&#125;class Basket&#123;public: //将调用shared_ptr隐藏进类代码中。若直接开写可能会添加shared_ptr&lt;Quote&gt;(new Quote(sale))，此时sale若为Bulk_Quote对象，分配动态内存只会截取Quote部分。为避免错误添加clone函数 void add_item(const Quote&amp; sale) &#123; items.insert(std::shared_ptr&lt;Quote&gt;(sale.clone())); &#125; void add_item(Quote&amp;&amp; sale) &#123; items.insert(std::shared_ptr&lt;Quote&gt;(std::move(sale).clone())); &#125; double total_receipt(std::ostream&amp;) const;private: static bool compare(const std::shared_ptr&lt;Quote&gt;&amp; lhs, const std::shared_ptr&lt;Quote&gt;&amp; rhs) &#123; return lhs-&gt;isbn() &lt; rhs-&gt;isbn(); &#125; std::multiset&lt;std::shared_ptr&lt;Quote&gt;, decltype(compare)*&gt; items&#123; compare &#125;;//使用花括号避免被解析为定义了一个函数&#125;;double Basket::total_receipt(std::ostream&amp; os) const&#123; double sum = 0.0; for (auto iter = items.cbegin(); iter != items.cend(); iter = items.upper_bound(*iter)) //upper_bound返回一批相同元素的下一个位置 sum += print_total(os, **iter, items.count(*iter)); //count返回相同元素数目（通过Basket::compare比较isbn，相同isbn算作相同元素） os &lt;&lt; &quot;Total Sale: &quot; &lt;&lt; sum &lt;&lt; std::endl; return sum;&#125;//类名后加final防止被继承，函数形参列表与尾置返回类型后 加final防止被其派生类重写class NoDerived final &#123;&#125;; //加了final的类从其他基类继承//class Bad :public NoDerived &#123;&#125;; //×，不可继承NoDerived类//派生类的成员/友元只能通过派生类对象（而不能通过基类对象）访问基类的protected成员//派生类D public继承基类B时，用户代码可使用派生类D到基类B的转换，protected或private继承时用户代码不能使用转换；//派生类D的成员和友元永远可使用派生类D到基类B的转换；//派生类D public或protected继承基类B时，派生类D的派生类的成员和友元可使用派生类D到基类B的转换，private继承时不能使用转换//基类友元可访问基类与派生类继承自基类的成员，不可访问派生类protected/private成员，派生类友元可访问派生类自己的成员，不可访问基类protected/private成员//友元（类）的基类和派生类不能访问原来的基类和派生类的protected/private成员//使用using更改访问级别，也可以使用using基类的重载函数，并在派生类中覆盖其中几个的方法来定义需要的若干重载函数（其他未被覆盖的就会使用基类的重载版本）class B&#123; friend class friendB;public: B() :mem(0) &#123;&#125; void public_mem() &#123;&#125; void memfun() &#123;&#125; virtual int intfun(); //虚函数protected: void protected_mem() &#123;&#125; int mem;private: void private_mem() &#123;&#125;&#125;;class pubD :public B&#123;public: pubD() = default; pubD(int i) :mem(i) &#123;&#125; //初始化pubD::mem void memfun(int i) &#123;&#125; //此处覆盖而不重载基类的memfun，即使形参列表或返回值不同 int intfun(int); //不是虚函数，新的函数 //同时pubD继承B::intfun()定义 virtual int intfun2(); //虚函数protected: int mem; //隐藏（覆盖）基类同名成员，但是除了虚函数最好不要这样做private: void f(pubD d) //因为是B的派生类 &#123; B* b = &amp;d; b-&gt;public_mem(); d.public_mem(); /*B::*/protected_mem(); //所以可访问基类protected成员// b-&gt;protected_mem(); //×，不能通过基类对象访问 d.protected_mem(); //√，可以通过派生类对象访问 &#125; int j;&#125;;class proD :protected B&#123; void f2(pubD d) &#123; B* b = &amp;d; &#125;&#125;;class priD :private B&#123; void f3(pubD d) &#123; B* b = &amp;d; &#125;public: using B::protected_mem; //在派生类中的public使用using可强制把基类的protected成员改为public的&#125;;class pubpubD :public pubD&#123;public: int intfun(); //override B::intfun() int intfun(int); //隐藏pubD::intfun(int)，并重载intfun int intfun2(); //override pubD::intfun2()&#125;;class pubpriD :public priD&#123; void f4(pubD d) &#123; /* B* b = &amp;d; */ &#125;//×，B不可访问&#125;;class friendB&#123; void f5(B b) &#123; b.private_mem(); &#125; void f6(pubD d) &#123; /* d.j; */ //×，派生类protected与private不可访问 d.private_mem(); //√，基类protected与private可访问 &#125;&#125;;class pubfriendB :public friendB&#123; void f7(B b) &#123; /* b.protected_mem(); */ //×，友元（类）的派生类与基类对本来的protected与private不可访问 b.public_mem(); &#125;&#125;;struct D1 : /*public*/ B &#123;&#125;; //默认public继承class D2 : /*private*/ B &#123;&#125;; //默认private继承void fun()&#123; Bulk_Quote bulk; Bulk_Quote* bulkP = &amp;bulk; Quote* itemP = &amp;bulk; bulkP-&gt;discount_policy(); //√，Bulk_Quote本身没有该成员，但是在外层的Disc_quote中找到成员// itemP-&gt;discount_policy(); //×，Quote本身没有该成员，在外层也找不到找到成员，但是不会往内层（Disc_quote）中找 B* pb; pubD pubd; proD prod; priD prid; pb = &amp;pubd; //√// pb = &amp;prod; //×// pb = &amp;prid; //× prid.protected_mem();// prod.protected_mem(); //×，只有私有继承类priD更改了访问级别 &#123;//对象调用函数时静态绑定，只从对象本类找函数名字；指针调用函数时若不是虚函数则按照在声明指针的类找，虚函数则动态绑定，运行时在被指对象类找函数名字调用，找不到往基类找 B Bobj; pubD pubDobj; pubpubD pubpubDobj; B* bp1 = &amp;Bobj, * bp2 = &amp;pubDobj, * bp3 = &amp;pubpubDobj; pubD* dp1 = &amp;pubDobj, * dp2 = &amp;pubpubDobj; pubpubD* dp3 = &amp;pubpubDobj; Bobj.intfun(); //√，调用B::intfun()// Bobj.intfun(1); //×，找到B::intfun()，参数不匹配// Bobj.intfun2(); //×，找不到B::intfun2()// pubDobj.intfun(); //×，找到pubD::intfun()，参数不匹配 pubDobj.intfun(1); //√，调用pubD::intfun(int) pubDobj.intfun2(); //√，调用pubD::intfun2() pubpubDobj.intfun(); //√，调用pubpubD::intfun() pubpubDobj.intfun(1); //√，调用pubpubD::intfun(int) pubpubDobj.intfun2(); //√，调用pubpubD::intfun2() bp1-&gt;intfun(); //√，运行时调用B::intfun() bp2-&gt;intfun(); //√，运行时调用B::intfun() bp3-&gt;intfun(); //√，运行时调用pubpubD::intfun()// dp1-&gt;intfun(); //×，找到pubD::intfun()，参数不匹配，不去找pubpubD::intfun()// dp2-&gt;intfun(); //×，找到pubD::intfun()，参数不匹配，不去找pubpubD::intfun() dp3-&gt;intfun(); //√，运行时调用pubpubD::intfun()// bp1-&gt;intfun(1); //×，找到B::intfun()，参数不匹配，不去找pubD::intfun(int)// bp2-&gt;intfun(1); //×，找到B::intfun()，参数不匹配，不去找pubD::intfun(int)// bp3-&gt;intfun(1); //×，找到B::intfun()，参数不匹配，不去找pubD::intfun(int) dp1-&gt;intfun(1); //√，调用pubD::intfun(int) dp2-&gt;intfun(1); //√，调用pubD::intfun(int) dp3-&gt;intfun(1); //√，调用pubpubD::intfun(int)// bp1-&gt;intfun2(); //×，找不到B::intfun2()// bp2-&gt;intfun2(); //×，找不到B::intfun2()// bp3-&gt;intfun2(); //×，找不到B::intfun2() dp1-&gt;intfun2(); //√，运行时调用pubD::intfun2() dp2-&gt;intfun2(); //√，运行时调用pubpubD::intfun2() dp3-&gt;intfun2(); //√，运行时调用pubpubD::intfun2() &#125;&#125;////////////////////////////////////////////////////////////////////////////模板类，其成员函数只有使用到时才被实例化template &lt;typename&gt; class BlobPtr; //为了在BlobPtr声名友元需要的前置声明template &lt;typename&gt; class Blob; //为了operator==中Blob类需要的前置声明template &lt;typename T&gt; bool operator==(const Blob&lt;T&gt;&amp;, const Blob&lt;T&gt;&amp;); //为了在Blob声名友元需要的前置声明template &lt;typename T&gt; //一个模板参数名（这里为T）在一个特定模板参数列表中只能出现一次，模板参数名会隐藏外层作用域中声明的相同名字class Blob&#123;public: typedef T value_type; //使用value_type相当于使用T typedef typename std::vector&lt;T&gt;::size_type size_type; //加上typename告诉编译器vector&lt;T&gt;::size_type是一个类型而不是一个成员 friend class BlobPtr&lt;T&gt;; //加上&lt;T&gt;将访问权限限制在相同的T类型 friend bool operator==&lt;T&gt; (const Blob&lt;T&gt;&amp;, const Blob&lt;T&gt;&amp;); //加上&lt;T&gt;将访问权限限制在相同的T类型 Blob(); Blob(std::initializer_list&lt;T&gt; il); template &lt;typename It&gt; Blob(It b, It e); //成员模板，与类模板参数不同表示可接受不同类型迭代器 size_type size() const &#123; return data-&gt;size(); &#125; bool empty() const &#123; return data-&gt;empty(); &#125; void push_back(const T&amp; t) &#123; data-&gt;push_back(t); &#125; void puch_back(T&amp;&amp; t) &#123; data-&gt;push_back(std::move(t)); &#125; void pop_back(); T&amp; back(); T&amp; operator[](size_type i);private: std::shared_ptr&lt;std::vector&lt;T&gt;&gt; data; void check(size_type i, const std::string&amp; msg) const;&#125;;template &lt;typename T&gt; //类的类型参数，必须分开template &lt;typename It&gt; //构造函数的类型参数，必须分开Blob&lt;T&gt;::Blob(It b, It e) :data(std::make_shared&lt;std::vector&lt;T&gt;&gt;(b, e)) &#123;&#125;//调用时通过实参自动推断成员模板实参template &lt;typename U&gt; //定义与声明的模板参数名可不同，但是要有相同数量和种类的参数Blob&lt;U&gt;::Blob() :data(make_shared&lt;std::vector&lt;U&gt;&gt;()) &#123;&#125;template &lt;typename T&gt;Blob&lt;T&gt;::Blob(std::initializer_list&lt;T&gt; il) : data(make_shared&lt;std::vector&lt;T&gt;&gt;(il)) &#123;&#125;template &lt;typename T&gt; //定义在外部的函数也要加这一句void Blob&lt;T&gt;::check(size_type i, const std::string&amp; msg) const //类名后面有&lt;T&gt;&#123; if (i &gt;= data-&gt;size()) throw std::out_of_range(msg);&#125;template&lt;typename T&gt;void Blob&lt;T&gt;::pop_back()&#123; check(0, &quot;pop_back in empty blob&quot;); data-&gt;pop_back();&#125;template &lt;typename T&gt;T&amp; Blob&lt;T&gt;::back()&#123; check(0, &quot;back on empty blob&quot;); return data-&gt;back();&#125;template&lt;typename T&gt;T&amp; Blob&lt;T&gt;::operator[](size_type i)&#123; check(i, &quot;subscript out of range&quot;); return (*data)[i];&#125;template &lt;typename T&gt;class BlobPtr&#123;public: BlobPtr() :curr(0) &#123;&#125; BlobPtr(Blob&lt;T&gt;&amp; a, size_t sz = 0) :wptr(a.data), curr(sz) &#123;&#125; T&amp; operator*() const; BlobPtr&amp; operator++(); //在模板作用域类内模板名可以不指定模板实参T（使用BlobPtr而不是BlobPtr&lt;T&gt;） BlobPtr&amp; operator--();private: std::weak_ptr&lt;std::vector&lt;T&gt;&gt; wptr; size_t curr; std::shared_ptr&lt;std::vector&lt;T&gt;&gt; check(size_t, const std::string&amp;) const;&#125;;template&lt;typename T&gt;T&amp; BlobPtr&lt;T&gt;::operator*() const&#123; auto p = check(curr, &quot;dereference past end&quot;); return (*p)[curr];&#125;template&lt;typename T&gt;BlobPtr&lt;T&gt;&amp; BlobPtr&lt;T&gt;::operator++() //在模板作用域类外，模板名必须指定模板实参T（返回值使用BlobPtr&lt;T&gt;）&#123; BlobPtr ret = *this; //在模板作用域类内，模板名可以不指定模板实参T ++* this; return ret;&#125;//template，模板显式实例化定义语句。实例化了的话，必须在使用模板之前已经定义或者extern声明，一个程序只会使用定义处实例化的版本，未实例化则编译器在每个使用模板的文件中生成一个实例化版本//模板类实例化会实例化所有成员，所以所用类型必须要能用于模板所有成员template class Blob&lt;std::string&gt;;////////////////////////////////////////////////////////////////////////////模板类与友元// 是否需要前置声明 非模板类是 模板类的一个实例是 模板类相应实例是 模板类所有实例是//非模板类的友元 否 是 是 否//模板类的友元 否 是 是 否template &lt;typename T&gt; class TpltCls1; //前置声明(1)，将模板的一个特定实例声明为友元时用到class Cls1 //非模板类&#123; friend class TpltCls1&lt;Cls1&gt;; //类TpltCls1&lt;Cls1&gt;是Cls1的一个友元，使用前置声明(1) template &lt;typename T&gt; friend class TpltCls2;//类TpltCls2所有实例都是Cls1的友元，无需前置声明 template &lt;typename T&gt; void mem(const T&amp; v) &#123;&#125;//成员模板，不能为虚函数，调用时通过实参自动推断成员模板实参&#125;;template &lt;typename&gt; class TpltCls1; //前置声明(2)，将模板的对应实例声明为友元时用到template &lt;typename T&gt;class TpltCls3 //模板类&#123; friend class TpltCls1&lt;T&gt;; //相同模板参数的为友元，需要前置声明(2) template &lt;typename X&gt; friend class TpltCls2;//类TpltCls2所有实例都是TpltCls3所有实例的友元，无需前置声明 friend class Cls2; //类Cls2是所有TpltCls3实例的友元&#125;;class Cls2&#123;&#125;;template &lt;typename T&gt;class TpltCls1 //模板类&#123; friend T; //模板类型参数成为友元，即int为TpltCls1&lt;int&gt;的友元等（C++11标准）public: static size_t count() &#123; return ctr; &#125;//通过类访问静态成员时需要特定实例，如TpltCls1&lt;int&gt;::count(); ，通过对象时不需要 void mem();private: static size_t ctr;&#125;;template &lt;typename T&gt;static size_t TpltCls1&lt;T&gt;::ctr = 0; //类模板的每个实例都独有一个static对象，在外部定义时使用&lt;T&gt;给每个实例独立初始化template &lt;typename T = int&gt; //默认模板参数class TpltCls2 //模板类&#123;&#125;;template &lt;typename T&gt; using twin = std::pair&lt;T, unsigned&gt;; //template不能在函数内，可以在类内template &lt;typename T&gt; using TTplt = TpltCls1&lt;T&gt;; //使用using可以定义类模板的类型别名void fun2()&#123; typedef TpltCls1&lt;int&gt; intTplt; //使用typedef只能使用别名引用 实例化了的类 twin&lt;std::string&gt; authors; //authors是一个pair&lt;string, unsigned&gt; TpltCls2&lt;&gt; tp2; //所有模板参数都有默认实参的类，可以只用尖括号表示使用默认类型（此处为int）&#125;template &lt;typename T&gt;class TpltCls1&lt;T&amp;&gt; &#123;&#125;; //类模板部分特例化，在类名后尖括号中使用参数在模板参数列表中按位置对应。部分特例化版本的模板参数列表是原始模板参数列表的子集或特例化版本template &lt;&gt;void TpltCls1&lt;int&gt;::mem() &#123;&#125; //特例化成员而不会整个类，在使用到的时候先使用特例化版本////////////////////////////////////////////////////////////////////////////多重继承、虚继承、虚基类struct MultiBase1&#123; MultiBase1() = default; MultiBase1(const std::string&amp;); MultiBase1(std::shared_ptr&lt;int&gt;);&#125;;struct MultiBase2&#123; MultiBase2() = default; MultiBase2(const std::string&amp;); MultiBase2(int);&#125;;struct MultiD : public MultiBase1, public MultiBase2 //多重继承，每个基类都指定访问说明符，若为class则默认前面加private，若为struct默认前面加public&#123; using MultiBase1::MultiBase1; using MultiBase2::MultiBase2; MultiD() = default; MultiD(const std::string&amp;); //继承了相同参数的构造函数时，需要为该类提供一个相应版本的自定义函数来覆盖 //自定义拷贝和移动时需要在完整对象上执行，否则出错；合成的操作则会自动对基类部分执行拷贝和移动&#125;;class vBase &#123;&#125;; //vDeri1和vDeri2的虚基类class vDeri1 :public virtual vBase &#123;&#125;; //虚继承，使派生类只含有一份虚基类部分class vDeri2 :virtual public vBase &#123;&#125;; //虚继承，使派生类只含有一份虚基类部分class Deri :public vDeri1, public vDeri2 &#123; Deri() :vBase() &#123;&#125; //√，虚继承中，构造函数可直接使用虚基类的构造函数来初始化。未显式调用虚基类的构造函数时，虚基类的默认构造函数被调用 //构造函数调用顺序：首先是最高层的间接虚基类，然后是直接虚基类，然后是非虚基类的间接基类，然后直接非虚基类，最后派生类自己&#125;;class vDeri3 :public vBase &#123;&#125;;class vDeri4 :public vBase &#123;&#125;;class Deri2 :public vDeri3, public vDeri4 &#123; // Deri2() :vBase() &#123;&#125; //×，非虚继承中，构造函数不可使用普通间接基类的构造函数&#125;;////////////////////////////////////////////////////////////////////////////嵌套类//外层类对嵌套类、嵌套类对外层类都没有特殊访问权限（比如嵌套不能访问外层的protected、private，外层也不能访问嵌套的protected、private）class OuterClass&#123;public: using line_no = std::vector&lt;int&gt;::size_type; class NestedClass; //访问权限由外部类决定，如定义在public下则可被随处访问 NestedClass mem();&#125;;class OuterClass::NestedClass //嵌套类可以定义在类的外部&#123;public: line_no fun(); //嵌套类可以使用外层类的成员 static int static_mem;&#125;;OuterClass::line_no OuterClass::NestedClass::fun() &#123;&#125;//类外函数定义int OuterClass::NestedClass::static_mem = 42;//静态成员定义////////////////////////////////////////////////////////////////////////////局部类int globalint = 1;void fun3()&#123;//外层函数对局部类的成员没有访问特权，所以要么将函数声明为局部类的友元，要么将局部类的成员设为public的 static int si = 0; int i; enum Loc &#123; a = 1024, b &#125;; struct Bar //局部类，所有成员必须完整定义在类的内部（局部类的嵌套类除外） &#123; Loc locVal; //√，可以使用函数内的局部类型名 int barVal; void BarFun(Loc l = a) &#123; //barVal = i; //×，不能使用函数内的局部变量 barVal = ::globalint; //√，可以使用全局对象 barVal = si; //√，可以使用函数内的静态对象 locVal = b; //√，可以使用函数内的枚举成员 &#125; class nestedClass; //局部类可以定义嵌套类 &#125;; class Bar::nestedClass &#123;&#125;; //局部类的嵌套类可以定义在局部类外，外部函数内&#125;////////////////////////////////////////////////////////////////////////////位域//类可以将其非静态数据成员定义成位域，以便向其他程序或硬件传递二进制数据typedef unsigned int Bit;class file_a&#123; Bit mode : 2; //位域声明，类型 名字 冒号 常量表达式，类型必须为整型或枚举型，通常使用无符号类型（带符号型可能会产生奇怪行为） Bit modified : 1; //常量表达式用于指定成员所占的二进制 位数，而不是其中存储的值，比如这句就是modified占1位 Bit prot_owner : 3; Bit prot_group : 3; Bit prot_world : 3;public: enum modes &#123; READ = 01, WRITE = 02, EXECUTE = 03 &#125;; //八进制表示 file_a&amp; open(modes); void write(); void close(); bool isRead() const &#123; return mode &amp; READ; &#125; //一般通过（隐式）内联函数检验或设置位域的值 void setWrite() &#123; mode |= WRITE; &#125; //一般通过（隐式）内联函数检验或设置位域的值&#125;;file_a&amp; file_a::open(modes m)&#123; mode |= READ; //在原来基础上设置READ if (m &amp; WRITE) //检查READ和WRITE打开 /*...*/; return *this;&#125;void file_a::write()&#123; modified = 1; //将modified置位1 /*...*/&#125;void file_a::close()&#123; if (modified) /*...*/;&#125;","categories":[{"name":"学习","slug":"学习","permalink":"https://neko-horikawaraiko.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://neko-horikawaraiko.github.io/tags/C/"}]},{"title":"【鼓哥】带你玩东方-外传（十八）（其他游戏篇）","slug":"【鼓哥】带你玩东方-外传（十八）（其他游戏篇）","date":"2021-08-22T15:19:40.000Z","updated":"2024-11-04T16:22:53.515Z","comments":true,"path":"2021/08/22/【鼓哥】带你玩东方-外传（十八）（其他游戏篇）/","link":"","permalink":"https://neko-horikawaraiko.github.io/2021/08/22/%E3%80%90%E9%BC%93%E5%93%A5%E3%80%91%E5%B8%A6%E4%BD%A0%E7%8E%A9%E4%B8%9C%E6%96%B9-%E5%A4%96%E4%BC%A0%EF%BC%88%E5%8D%81%E5%85%AB%EF%BC%89%EF%BC%88%E5%85%B6%E4%BB%96%E6%B8%B8%E6%88%8F%E7%AF%87%EF%BC%89/","excerpt":"","text":"大家好啊，这里是猫耳堀川雷鼓~ 这一次又到了其他游戏篇的专栏了，本期文章包含的游戏类型有音乐类、视觉小说类、养成类、赛车类，还有些不知道咋分的就统统塞进来了（。来看看有哪些有趣的游戏吧~ No.1（外传总No.271）游戏名：雛ちゃんのリズム職場体験 游戏类型：音乐游戏 Produced by：mizusoba（いすぃ） 一个音乐游戏，与我之前在十三期No.18（外传总No.188）介绍的游戏类似，都是先给你一段预告，然后你跟着相同节奏按键的音乐游戏。不过相比起来这个难一点，因为这个给的示例长短会突然变化，然后反应不过来从而掉评价，掉到“ダメ厄神”评价直接结束。另外这游戏是暂时叫这个名字，以后可能会改名。 No.2（外传总No.272）游戏名：ごうぞくっち 游戏类型：模拟游戏 Produced by：ごましお 之前也是第十三篇中No.6（外传总No.176）介绍的养成游戏的第二代，不过感觉这一代相比起来更像久远的电子宠物了——游戏变少了，有了宠物的四维属性（体魄、智力、幸运、饥饿），还需要打扫房间。实话说游戏性就稍微低了一些了。 No.3（外传总No.273）游戏名：Suite Crumble 游戏类型：音乐游戏 Produced by： 老熟人了，还是这家的音乐游戏，之前我也在专栏介绍过一个（见专栏十三No.2（外传总No.172））。不过这回改成竖方向的了，感觉好多了。仍然是键位还是默认PS手柄，可以像图中一样改成反应比较熟的上下左右来按。不过这里画面左右拉得比较长，有时候就看不过来。 No.4（外传总No.274）游戏名：東方稗想録 游戏类型：视觉小说 Produced by： 之前在第十三篇No.14（外传总No.184）里也介绍过他们的另一个视觉小说。这次这一篇是阿求为主视角的游戏，有关稗田家族转生与记忆之类，自然也就和四季、小町以及历史老师慧音会有互动。 No.5（外传总No.275）游戏名：Nitori’s Factory 游戏类型：动作游戏 Produced by：NewProject 游戏名说是工厂，实际上只会拆东西（。荷取一觉醒来发现周围全是破烂，结果一问才知道又发生了异变，然后就跟灵梦一起在幻想乡拆破烂去了。游戏形式就是按照对应的图标按对应按键，上下左右4方向键+zxcasd，按错了扣时间，时间到没拆完就game over。所以游戏其实考反应力。 No.6（外传总No.276）游戏名：秘封フラグメント 游戏类型：文字冒险游戏 Produced by： 游戏不仅是adv让你看小说，而且你还需要自己拼凑选项答案。剧情的发展路线可以在旁边看到，并且可以随意选择已经见到的某段路线进行回看。在遇到问题时，你作为梅莉要从之前剧情获得的フラグメント（记忆碎片）来找到答案，记载到memo上来继续剧情。当然要进入分支路线也需要在碎片中找到合适的词语才能进行。所以需要一定的日语基础。 （发文前的补充：）现在游戏已经上steam并存在汉化了，所以不需要会日语也能玩了。据说有些谜题根据汉化也做了一定的改动。 No.7（外传总No.277）游戏名：Pat The Ice Fairy 游戏类型：动作游戏 Produced by：Ferdy’s Lab 一个小型休闲游戏，就只是移动一下鼠标摸摸的⑨的头，摸的越多分越高。摸够一定只数可以开启fever模式，扎堆出现一大堆⑨让你摸。当然，在⑨比较密集的地方一次可以摸多只。治愈游戏。 No.8（外传总No.278）游戏名：リズムバンキ 游戏类型：音乐游戏 Produced by：ぱらどっと 这个作者应该挺经常见到，不过有好几个名字，所以Paradot、ぱらどっと、推特@zenerat、給食頭蛮都是指的他。这个游戏是他做的一个超小型节奏游戏，大概是仿节奏天国空手道家那个小游戏做的。游戏含两首歌，各占一个难度，判定比较宽松，fc比较好打。 No.9（外传总No.279）游戏名：SUPER Patchouli’s WHACK-A-KOA 64 游戏类型：动作游戏 Produced by：WRIT 作者在今年帕秋莉日做的一个打地鼠小游戏，一分钟限时间内，姆q用书来敲小恶魔和魔理沙的头，敲到妖精女仆也可以加分，不过很少。画风挺有意思，不过操作手感差了点，快速移动会丢操作。 No.10（外传总No.280）游戏名：ちくしょうとあそぼ 游戏类型：模拟游戏 Produced by：ごましお 和本文No.2同一个作者做的游戏，也是养成类，不过这次改成了八千慧和早鬼两个组长。也是玩小游戏收集金币，然后买衣服、家装来装饰。游戏都比较简单，装饰很快就能买全。另外游戏会读取本地时间，就像第二张图一样，还会给早睡提示…… No.11（外传总No.281）游戏名：霧雨探偵事務所 ～ 名探偵はじめました 游戏类型：文字冒险游戏 Produced by：ミストレイク遊撃隊 和逆转裁判有点相似的游戏，不过要稍微简单点。首先就是魔理沙接到侦探委托，然后去事件地点调查、谈话、重要证物记录本子上。基本上把所有事情做一遍稍微推理就能解决。基本调查完后紫妹会出来问你作案人和重要证物，往后就是各种对质，排除法能选个差不多都（。结案后紫妹会对这个对质和之前的选择打分，解释问题答案。 No.12（外传总No.282）游戏名：东方逆转检事 游戏类型：文字冒险游戏 Produced by：墨雾归尘 揉碎了各种梗切吧切吧扔到游戏里的一个游戏，系统自然是仿照逆转裁判的，不过这里并没有法官，基本就只是灵梦直接审问“犯人”魔理沙的小故事。视频见下： No.13（外传总No.283）游戏名：こいしの旅 游戏类型：视觉小说 Produced by：フォレスト 恋恋周游幻想乡的小故事，看到了魔理沙在偷书，小伞吓不到人但是恋恋一下子就吓到小伞了，看到秦心表演能乐然后再顺走一个面具被灵梦打一顿。挺短的（ No.14（外传总No.284）游戏名：幻想小遊戯集 游戏类型：解谜、动作游戏 Produced by： すい～と・らぴーぬ，老朋友了，之前介绍过几个他们的游戏。这次这个是个小游戏合集。 第一个，文字棋盘里找答案。根据阿求提出的问题找到相应的答案，这个答案必须在文字盘内是横着或者竖着的一条直线，然后点击这个答案的第一个字算答对。比如上面这个就是直接在文字盘内找“夢想封印”这直线连在一起的四个字，答案倒数第五行左数第三到六列，单后点击“夢”这个字算答对。其他难度就不是直接找字了，而是确确实实的问题，比如“XXX的符卡”。 第二个，密室逃脱，转转侦探接到红魔馆的信，找妹妹大人，然后却被打倒扔在了密室里，游戏就是找钥匙逃出密室。 第三个，果果突击取材，实际上就是障碍跑，考反应力的。 第四个，转转钻头，那种传统的滑条方向力度然后比谁砸的深的游戏。 第五个，比谁反应速度快的。之前写过一个类似的，外传八No.3（总No.73），以后可能还会有类似的。 No.15（外传总No.285）游戏名：東方 うー☆パチュRY ～鬼巫女の試練場～ 游戏类型：视觉小说、角色扮演游戏 Produced by：アルケミスト・ラボ 一个视觉小说+迷宫地牢的游戏，之前其实也介绍过这个社团的一个游戏了，是外传十三No.3（总No.173）那个東方探偵倶楽部。这次又是异变发生，不过是姆q出动了，说是偷走了建立博丽大结界的一个关键道具，灵梦要维持结界脱不开身，于是让魔理沙去找姆q的那么个故事背景。实话说这种文字风格的rpg打起来没点感觉，赢了输了都没啥刺激。 No.16（外传总No.286）游戏名：東方永月譚 ～Capriccio of Imperishable Princess.～ 游戏类型：动作游戏 Produced by：キツネノヨメイリ 一个带一点小剧情的打砖块，就是辉夜为了排解无聊然后找天狗发了个新闻，说是要改符卡规则，成功把灵梦引来了，不过结果是打砖块打的把衣服脱了（。就比如最后这个图，下一帧可就露了（当然没到r那种程度）。缺点很大，就是球和砖块都太小了，打一关十分钟，这谁受得了（。不过可以用spell变成穿透球，可以稍微打的快一点点。 No.17（外传总No.287）游戏名：魔理沙のコソ泥一番星! 游戏类型：文字冒险游戏 Produced by：キツネノヨメイリ 一个魔理沙去红魔馆偷书的视觉小说。魔理沙潜入红魔馆，碰巧遇到同样来搞事的三月精，然后魔理沙拿“宝藏”忽悠三月精去一块找线索。因为三月精和魔理沙观念里的“宝藏”不一样，实际上她们只能提供一些线索以及奇奇怪怪的小物品，魔理沙要分析这些线索最后找到那本书。游戏有时间线，魔理沙和三月精约定在几个时间点去某个屋子集合商量线索，其他时间可以在馆内逛，每个地方之间行进会消耗半小时。因为每次移动时馆内也有其他一些人在移动，在不巧的时间点不巧的位置碰上不巧的人就可能bad ending（。 No.18（外传总No.288）游戏名：ウルトラ健全ブロック崩し 游戏类型：动作游戏 Produced by：（オートリ電子/特殊装甲隊） 夜雀的三个打砖块关，不过这个游戏还是文明多了，球速正常，大小正常，砖块没那么小，还可以买一些道具增加通关率，有加命、双球、球下落接近板时慢速、自动打这四个。 No.19（外传总No.289）游戏名：AerobeatPlus 游戏类型：音乐游戏 Produced by：Remical Soft 也不是专门的东方的音乐游戏，不过带一些东方要素，作者默认提供的曲子里面有几个东方曲。这游戏挺有意思的，首先是操作上，可以用鼠标，也可以用摄像头；鼠标就是移动到那个魔法阵图样的方框上就算击中，摄像头就是需要拿一个绿色（游戏默认设置绿色）的东西比如绿色贴纸饮料瓶子（康师傅绿茶？），像动作捕捉这样打到那个方框（我没试过。其次是方框位置只有八个。然后是音乐方面，内置了一部分乐谱文件，再其中一部分有相应音乐或者背景动画，有这些音乐和背景动画的可以直接玩，只有乐谱的需要到官网上找到相应视频链接，自行下载视频（wmv格式，官网说还可以读avi和mpeg，但是我没成功）装进游戏数据文件夹里。当然也可以自制谱，官网也有教程。这游戏自由度挺大的，就是判定稍微严了一点点。 No.20（外传总No.290）游戏名：幻想マリサカート 游戏类型：模拟游戏 Produced by： dBu做的游戏，首先音乐肯定没得说，很好听。不过代码力可能确实差了一点。首先这是个赛车游戏，因为还在体验版，暂时没法换车，暂时没法换人，但是车的手感有些飘，灵敏度有点高。整个赛程现在是五个赛道，每个三圈，赛道挺简单。可以用普通子弹打人，ai其实互相打的挺起劲的（；也可以用抽的道具，有加速、防御、攻击三种；还可以放符卡魔炮，不过后坐力巨大。其实最糟心的是赛道，bug有点多，有的时候径直冲过去就卡墙里了，有的时候根本看不清赛道在哪（例如有个地图叫第四槐安通道），掉出赛道倒是会有救援，但是救出来可能给你放不好位置，让我多跑大半圈的事发生好几次了都（。 本来写的那一篇十八期果然不适合，所以我挪了下位置。 【鼓哥】带你玩东方-外传（十八-里）（r18篇） 在这里，看到真正的第十八期。 pid=84502889 volantis.js(\"https://unpkg.com/pandown\").then(pandown)","categories":[{"name":"游戏","slug":"游戏","permalink":"https://neko-horikawaraiko.github.io/categories/%E6%B8%B8%E6%88%8F/"}],"tags":[{"name":"带你玩东方","slug":"带你玩东方","permalink":"https://neko-horikawaraiko.github.io/tags/%E5%B8%A6%E4%BD%A0%E7%8E%A9%E4%B8%9C%E6%96%B9/"}]},{"title":"【鼓哥】带你玩东方-外传（十七）（解谜、策略游戏篇）","slug":"【鼓哥】带你玩东方-外传（十七）（解谜、策略游戏篇）","date":"2021-08-07T18:59:34.000Z","updated":"2024-11-04T16:23:21.028Z","comments":true,"path":"2021/08/08/【鼓哥】带你玩东方-外传（十七）（解谜、策略游戏篇）/","link":"","permalink":"https://neko-horikawaraiko.github.io/2021/08/08/%E3%80%90%E9%BC%93%E5%93%A5%E3%80%91%E5%B8%A6%E4%BD%A0%E7%8E%A9%E4%B8%9C%E6%96%B9-%E5%A4%96%E4%BC%A0%EF%BC%88%E5%8D%81%E4%B8%83%EF%BC%89%EF%BC%88%E8%A7%A3%E8%B0%9C%E3%80%81%E7%AD%96%E7%95%A5%E6%B8%B8%E6%88%8F%E7%AF%87%EF%BC%89/","excerpt":"","text":"大家好，这里是猫耳堀川雷鼓~ 这篇专栏呢，是关于一些需要动动脑子的游戏的集合，包括解谜、益智、策略之类，毕竟相比其他游戏来说这个动脑子算多的（。其中有几个还是有点意思的，比如类似slay the spire的卡牌游戏，还有类似马里奥聚会的聚会类型游戏，不过其他的就确实差点意思了。 No.1（外传总No.251）游戏名：メディスンクイズ ～マイメランコリー～ 游戏类型：解谜游戏 Produced by：強鈴グリコシド 这个问答硬核到爆炸，指另一些问题。如图，它是单选和多空选择的混合题目，这一部分是东方设定等问答，比较偏于原作、一设等文字。另一些问题是指，药学（。毕竟梅蒂欣称号是“XXXX毒药”，于是作者搞了一大群药学问题，甚至是（日本）国家药剂师测试的题目搞了上来。外行看个热闹就行了（。 No.2（外传总No.252）游戏名：幻想砲劇詩 ～ Art of Curtain FireAggression. 游戏类型：策略游戏 Produced by： 游戏机制有些特点的一个策略&amp;射击游戏（自称）。乍看其实挺像一个塔防游戏，有四个据点需要守，然后部署炮塔打敌人妖精。但是给分了几个阶段。首先需要选择一个据点开始部署，周围会围起围墙，墙内可以布置炮台或者角色（不同占地面积和布置消耗点数），然后利用这些打击进犯的妖精/boss。下一阶段就是所谓的stg要素，即时敌我战斗，就是互相发弹幕（。限时打完之后需要修复围墙，利用和俄罗斯方块似的围墙块，把围墙重新修复起来成为闭合的才算完成，如果时间到了没闭合直接判负（我因为这个条件直接判负了好几局）。然后就是循环开打。每关几个回合，判负条件也可以看看文件夹的说明文档。其实这游戏挺有难度的，这stg炮打的抛物线，打到了妖精都已经跑了（。 No.3（外传总No.253）游戏名：Tactics on Fairy Fables 游戏类型：策略角色扮演游戏 Produced by：ほわいとふれあ（46flare） 这是个稍微有点特别的战棋类游戏。你可以花钱买能力、等级提升，或者买妖精副手，然后带着这些打关。关卡里行动不是回合制的，而是类似于体力条。每次敌我行动都会有相应体力条cd时间，谁的cd先减到0谁行动，所以有可能会有连续行动两次的情况。不过这游戏还没完成，难度上有点偏高。 No.4（外传总No.254）游戏名：東方十七歩 游戏类型：策略游戏 Produced by： 根据日本麻将玩法“十七步”做出来的游戏。十七步简单来说就是每人先发34张牌，挑选能做出满贯以上的牌型，然后把剩下的牌在每一回合扔掉，谁先打出让对方和牌的牌就判负。具体有哪些牌型可以参考游戏内的役一览。每一组两个人物，选择有符卡的话在游戏中可以发动符卡，比如能打出让对方看不到的牌之类。详细的说明可以在以下官方文档了解。 東方十七歩特設ページhttps://illucalab.com/17walk/ No.5（外传总No.255）游戏名：ふぉーちゅんすたー☆ぱにっく 游戏类型：解谜游戏 Produced by： 魔理沙主角的策略解谜游戏。使用画面所示的黄色星星方块铺路，目标吃到指定数量的星星（有星环的那几个）。魔理沙可以在白地上放阻挡物限制推出去的星星方块的位置，在绿地上没法放，所以需要考虑地形来阻挡。有些关卡非常难搞，杀时间好手） No.6（外传总No.256）游戏名：グモンカードゲームGB 游戏类型：策略游戏 Produced by： 用rpgmaker做的一个卡牌对战游戏。双方使用3张卡片进行对战，如图黑色数字为血量，红色为攻击力。每张卡都有一个基础类型灵、魔、妖。卡片都有一些特殊能力，比如对某些类型敌人增加攻击力，或者什么条件下可以加血之类。这三张卡片在开打之前设置，有先后顺序，每次一张卡被打败才换下一张，基本上就是定了卡定了顺序，跟对方对战就是一个固定的流程了。打败敌人会得到一些新的卡片（可能重复），不过打之前不知道敌人啥卡啥顺序，所以被打死就GG，从头开始。 No.7（外传总No.257）游戏名：異変のくせになまいきよ!! 游戏类型：策略游戏 Produced by： 说是塔防，其实还是有些不同的特点的。首先布置塔，也就是什么辅助的小妖精啊毛玉啊获得的角色啊之类，需要先有一块空地，而空地啥样是需要你自己挖出来的，比如挖成我图上那样，每挖一块地消耗10块钱。布置好的塔可以决定朝向，可以随意移动，可以阻挡敌人，可以升级，这一点倒是像《明日方舟》。不过放好的塔也可以在每关间隔时移动，就有点意思。打赢一关获得的角色只能布置一个，被打没血就没了，而普通妖精毛玉可以无限，自然这两类的攻击防御能力就不一样。不过主机是⑨，血量高，但是攻击防御稍微弱点，不能升级，被打没血就game over了。 No.8（外传总No.258）游戏名：まりさパーティ 游戏类型：策略游戏 Produced by： 像是一种大富翁与马里奥派对的结合体，应该也有这种游戏，不过一时确实想不起来像啥了）。收集到越多的蓝点和星星（星星为主）排名越高，地图上也有一些固定地点，会触发一些小事件，还有每局会有1v3或2v2小游戏，就像上面这个图就是选四要石之一站上，但是要看运气不要被天子掀要石掀飞。不过小游戏确实有点少，还是按手柄按键给的指示，对键盘不友好）。 No.9（外传总No.259）游戏名：妖精カードローグ 游戏类型：策略游戏 Produced by：ほわいとふれあ（46flare） 一个仿照杀戮尖塔（Slay the Spire）模式做的卡牌游戏。由于写文时游戏还是未最终定名的体验版，可能与最终成品有所区别。这里的迷宫地牢还不是选择分支，而是直线形式，随机刷新移动步数，根据已有步数选择来前进。遇到敌人进入战斗，战斗就和尖塔几乎一样了，使用卡牌打伤害与防御、加buff。地牢还有加血点和商店，加血点恢复一定量的血量，商店卖几张卡片，打赢敌人获得钱来买。 No.10（外传总No.260）游戏名：パチュメンタルカード 游戏类型：策略游戏 Produced by：ルート ルート做的一个新的卡牌游戏。规则大致是用相应颜色的卡片填满相应位置。从牌堆（山札）里抽牌，然后从手牌（手札）中打出相应颜色的牌到面前的五色区域中，自动按照对应颜色放在对应区域，五个区域谁先都填满就算胜利。卡牌有可能不止一种颜色，需要区域内某一种颜色已经有卡片打上去了，多色卡牌才能自动打出到另一个区域中。卡牌也有相应能力，比如抽卡、换卡、破坏对方卡片之类，也有可能把卡片从山札或手札中移到墓地，墓地里的卡只能由相应功能的卡片才能复活。游戏虽然规则简单但是因为加上卡片能力，变得挺有意思，推荐尝试一下。 No.11（外传总No.261）游戏名：弾幕パズル！ にとりの河登り 游戏类型：解谜游戏 Produced by：Keio Digital Vertex 这荷取吧，整天整些新活。这次是解谜性质的游戏，荷取有初始きゅうりパワー，需要在能量归零之前到达目标goal。每次移动以及敲碎墙壁、攻击敌人都耗费不同数量能量值，黄瓜会加能量值，考虑一条合理的道路到达目标，其实很多时候这种路都是唯一的。你进行上面这些操作的时候，妖精也会按照显示的方向移动，被撞到当然就直接gameover。当失败一定次数的时候，游戏就会给你提示，毕竟死也过不去容易弃游不是？ No.12（外传总No.262）游戏名：東方風売買人（いーすととれーだーEast Trader） 游戏类型：策略游戏 Produced by： 也是浪漫沙加3里面的trade小游戏复刻，之前在外传九的No.17（总No.107）写过一个。用自己物件的可提出金额与流动资产来买地，然后用新买的地收租攒资产之类。在具体一点到这个游戏，就是从自己掌管的区域收取“信仰”（资金），在收取新的区域时从自己管的区域里收集临时信仰做“提出金”，再加上手上已经存下来的信仰，加起来去“押宝”（？），与新区域的原主人对抗，基本是谁出的信仰多，获得了压倒性胜利，就拥有了区域控制权。为了增加趣味还增加了道具系统，装备一些道具可以提升收集临时信仰的速度（游戏里叫提出（钱的）速度），提升信仰量，或者人物技能之类。目标最快买下幻想乡所有区域。具体游戏方法可以看下面这个视频。 No.13（外传总No.263）游戏名：⑨Driller 游戏类型：解谜游戏 Produced by： 这种类型游戏之前应该介绍过，比如とある天女の螺旋穿孔（见第十期专栏游戏No.18），就是往下钻地这一类的游戏，不过这次主角改成了⑨而已。当然这个游戏在社团“大变”之后也暴毙了。 No.14（外传总No.264）游戏名：ゆっくり撃っていってね! 游戏类型：策略游戏 Produced by：voidaste 实际上就是个塔防游戏，就是别让这些食物被最后的油库里吃到就可以了。 四种塔，区别不是很大，魔理沙就是小范围单攻便宜，妖梦大范围单攻稍微贵一点，橙喵小范围连发而且升级增加不是很大，而且贵，阿麟（？）中范围单攻初始攻高，稍微贵点。（说白了就是把图上的玩意翻译了一遍）而且没看到群攻塔，作为一个塔防这真的好吗？ No.15（外传总No.265）游戏名：Flee, fairies, flee! 游戏类型：解谜游戏 Produced by：Atrufulgium 由于恶作剧太过分，灵梦来退治了。用wsad和上下左右分别操作皮丝和⑨，使用死后效果合作过关。⑨死亡之后会冻结两格成为冰块，皮丝死亡之后会使周围木质物燃烧消失。利用这个特性爬上高台或者清除阻挡物。死亡之后按各自的“下”会在另一方的位置重生，如果同时两个都死了只能重来了。一个人操作的话比较难受，还是再找一个人陪着玩吧。 No.16（外传总No.266）游戏名：妖精大探双 游戏类型：解谜游戏 Produced by： 其实只要见到“妖精大XX”这名字都应该是这社团做的游戏（这个游戏呢，是轮番操纵大酱和琪露诺按下按钮，通过一些特殊地形，然后拿到宝箱。总体来说难度还是有些大，毕竟你不说没人会想到能通过卡位（卡住彩色砖块的显示）来破关）。当然卡着卡着有可能就进死胡同出不来了，只能重开（。 No.17（外传总No.267）游戏名：Nitori &amp; the One-Shot Cube 游戏类型：解谜游戏 Produced by：stak134 这一届河童重工不行啊（x 荷取捡到一个魔方块，但是这个方块一关只能发一发子弹（抠啊）。你需要用这一发子弹把所有敌人都干掉。那么有人问，一发子弹怎么干掉两个敌人呢？这一发子弹还是有点来头，它撞到墙能分裂成3颗子弹，所以游戏成了几何学问题，怎样通过反弹（实际上还是蒙）用这3个子弹打败所有敌人。说实话，也挺难的，音乐也无趣，很容易就想放弃。 No.18（外传总No.268）游戏名：東方武闘外伝 游戏类型：解谜游戏 Produced by：夏季限定 实际上就是个超能力俄罗斯方块：俄罗斯方块+符卡。消掉带阴阳玉的行就收集阴阳玉，至少一个就可以发动符卡，不同阴阳玉数量发动的符卡不一样，不同人物也不同符卡，有六个人物可以选。比较奇特的一点是两人的方块后备槽共用，也就是中间那方框里，谁先放好方块，谁就可以从里面拿下一块方块。 No.19（外传总No.269）游戏名：まりさとありす 游戏类型：解谜游戏 Produced by： 这个社团挺喜欢做爱丽丝和魔理沙主角的解谜游戏，比如本文No.5那个游戏。这个就是魔理沙邀请爱丽丝探险，然后实际上是爱丽丝找魔理沙的一个策略类游戏。用鼠标操控爱丽丝走走过各种路，或者掉下来（，去到达魔理沙的goal那里。地图上元素有路、粉色那样子的开关（开了就可以走，关了就是洞那种）、梯子可以让爱丽丝爬上去，之类，不过不要碰到毛玉这类的小怪，碰了GG。星星是过关给一个，每关地图里有两个，每一大关收集到一定数量可以开boss关，找到各处的boss“分身”全都踩头算过关。不过有些关我是真的不知道怎么过（，难度稍微有点高。 No.20（外传总No.270）游戏名：うちの橙知りませんか？ 游戏类型：解谜游戏 Produced by：ルート 和上面No.10同一个作者的游戏。这个游戏是橙喵找蓝妈的解谜类游戏，玩家一个人分别控制两边，使用各种道具拿到钥匙开门然后蓝和橙相遇为成功。蓝的速度慢一点，跳跃高度两格，身高一格多；橙速度快一点，跳跃高度一格，身高一格。画面上各种道具比如团扇可以加速，钥匙去开门，阴阳玉做炸弹之类，玩家需要在橙和蓝之间交替切换，打开开关，互相扔道具，然后主要是橙去开门然后找到蓝这边来。（因为门就是一格，所以蓝身高一格多点就过不了门去）毕竟解谜游戏，所以难度还是有的。 pid=59572603 volantis.js(\"https://unpkg.com/pandown\").then(pandown)","categories":[{"name":"游戏","slug":"游戏","permalink":"https://neko-horikawaraiko.github.io/categories/%E6%B8%B8%E6%88%8F/"}],"tags":[{"name":"带你玩东方","slug":"带你玩东方","permalink":"https://neko-horikawaraiko.github.io/tags/%E5%B8%A6%E4%BD%A0%E7%8E%A9%E4%B8%9C%E6%96%B9/"}]},{"title":"【鼓哥】带你玩东方-外传（十六）（动作游戏篇）","slug":"【鼓哥】带你玩东方-外传（十六）（动作游戏篇）","date":"2021-07-24T18:05:32.000Z","updated":"2024-11-04T16:23:14.482Z","comments":true,"path":"2021/07/25/【鼓哥】带你玩东方-外传（十六）（动作游戏篇）/","link":"","permalink":"https://neko-horikawaraiko.github.io/2021/07/25/%E3%80%90%E9%BC%93%E5%93%A5%E3%80%91%E5%B8%A6%E4%BD%A0%E7%8E%A9%E4%B8%9C%E6%96%B9-%E5%A4%96%E4%BC%A0%EF%BC%88%E5%8D%81%E5%85%AD%EF%BC%89%EF%BC%88%E5%8A%A8%E4%BD%9C%E6%B8%B8%E6%88%8F%E7%AF%87%EF%BC%89/","excerpt":"","text":"大家好，这里是猫耳堀川雷鼓，（在专栏方面）好久不见了。 近期嘛，也是事情比较多，加上有些游戏不玩一玩真的不好去理解游戏怎么玩，导致专栏进度缓慢。不过总算也是肝出来了新的一期。本期游戏都是动作类的，不过有些做的挺有意思，有些充满恶意，感兴趣的话可以玩玩看。接下来，进入正文~ No.1（外传总No.231）游戏名：ひがスト 2005 游戏类型：动作游戏 Produced by： 这是个多人对战游戏，类似于现在市面上的各种大乱斗。不过这个主要进攻方式都是弹幕类，打击敌人时会掉落一些道具，吃道具可以改变攻击方式几次。不过这个攻击受击硬直时间都非常长，很容易墙角惨案。 No.2（外传总No.232）游戏名：Suwako in Pixiv 游戏类型：动作游戏 Produced by： 给一个关键词：猫里奥，剩下的不用多说了吧（ UTG还做了一个类似的愚人节游戏叫《諏訪子 in ニコニコ動画》，一样的套路，不想提了（ No.3（外传总No.233）游戏名：熱っ血東方格闘伝説 游戏类型：动作游戏 Produced by：Mr.X、Ａ.Ｓoushi等 一个热血系列热血格斗的东方改版，本体是作者“对FC热血格斗的改良版”，然后后来人打了一个东方补丁。不知道有没有把获胜条件之类的改掉，我打了几局没到头就先停了。人物很多，从th01到th14的绝大部分都有，光人物特性就可以研究一会了，但是感觉打的时候神奈子很强。喜欢的人可以详细研究研究，甚至再叫上7个人一起打） No.4（外传总No.234）游戏名：るみゃんランド 游戏类型：动作游戏 Produced by：魔道琥珀研究所 rumialand主角当然是露米娅了，主线是露米娅的寻找食物小探险，传统“找门”类动作游戏。打掉路上的妖精，或者使用特殊射击“そ～ なの か～”来把敌人涂黑，然后当垫脚石用。另外一眼可以看到的亮点就是露米娅的动作帧率还挺高的，但其他的确实没了）。 No.5（外传总No.235）游戏名：東方落試合 游戏类型：动作游戏 Produced by： 绝对要两人及以上才能玩起来的游戏，因为一个人进不去游戏（。图中可以看出来可选人物挺多的，当然每个人物也有自己的特性。规则就是打没血或者掉下擂台面就算失败，途中类似于香霖（？）头像的那玩意里面是随机的东西，有可能是特殊子弹，或者障碍物之类。按照总共获胜局数（获得星星）来决定最终胜者。 No.6（外传总No.236）游戏名：白黒さん ～ 罰地の冒険 游戏类型：动作游戏 Produced by： 一个魔理沙的打怪小游戏，风格仿照fc的《忍者君阿修罗之章》（感谢@By干脆面的提示）。在时间结束之前找到所有的敌人+boss并打败她们，说是打败也就一个弹幕或者踩两下头的事情。不过相比fc忍者君来说这个游戏给玩家的视口更小，所以容易在往上跳或者往下跳时候正好碰到敌人弹幕而GG。 No.7（外传总No.237）游戏名：鈴仙妖夢の活劇録 游戏类型：动作游戏 Produced by： 又是一个仿洛克人的游戏，不过这个里洛克人远了点。打道中敌人获得灵力，消耗灵力在灵梦那升级副武器，每次进关只能带一种副武器，消耗SP使用副武器以及冲刺。难度不是特别大，升级了副武器之后能帮不少忙（也可能只有追踪弹帮助更大吧，我只用追踪）。道中miss会丢掉所有灵力，在下一次破关打到死亡地点可以再捡回来，而boss战miss可选择扣两成灵力续关，不续关则这关只能重打。悠遊亭一贯的游戏时快时慢在这里也有，其实难度也主要在这变速上了。 No.8（外传总No.238）游戏名：白黒大罰地 / 激！白黒大罰地 游戏类型：动作游戏 Produced by： 小游戏集合，不知道是不是也是一个fc游戏的翻版。也是操控自机打妖精或者毛玉，不过这次不能和本专栏No.6似的踩头了。“激！白黒大罰地”版本是原版的强化版，自机残机数变多了，关卡更难了，更打不过去了。 No.9（外传总No.239）游戏名：チルノフリーザー 游戏类型：动作游戏 Produced by： 还是ZWEi做的动作闯关游戏，这次的主角换成⑨了。⑨可以冻住部分敌人，可以当垫脚石用；还能冻部分弹幕，在boss战主要以这种方式打boss。普通关部分是限时从起点跑到终点，如果对地图近路不熟悉的话时间还是挺紧张的，掉下去或者被打死或者时间到从本关重来，不消耗continue次数。boss关每个boss有不同打法，被打死会消耗continue次数。多试验几次来通关吧。 No.10（外传总No.240）游戏名：Touhou project Magical Dinner below the full moon 游戏类型：动作游戏 Produced by：chainedTan, White Pikmin, J’ Camilo 红魔馆为了做一顿perfect的饭，找到一张只能读一次的食谱。操作咲夜找到菜单上需要的材料放在桌子上准备做菜。路上有各种敌人，需要通过时停和刀砍（不是扔刀子差评）探路，并找到对的食材拿回厨房。只能被打五次，可以通过吃掉落的心回复次数；时停可以控制释放长短，吃掉落的p点恢复。整体难度有些高，而且不能续关，需要非常注意。 No.11（外传总No.241）游戏名：PAD ATTACK 游戏类型：动作游戏 Produced by：galateasrbb 一个绿色兵团的东方同人改版，还原度嘛“请观众老爷们评判吧”（作者这样说的）。毕竟忽然扒到游戏作者是站内的一个老人up，之前介绍过的TH Contra也是他做的（外传二No.10（外传总No.20），不过当时没找到作者），下面是作者自己的通关视频。 No.12（外传总No.242）游戏名：図書館ではお静かに! 游戏类型：动作游戏 Produced by： 一个简单的姆q接书小游戏。目标是就是在魔理沙弹幕捣蛋情况下接书，被打到掉一条命，书没接到掉一本书的机会，任意一个减超过0就失败。姆q有体力槽可以冲刺去接书，不冲刺状态自动恢复。随着接的书数量上涨，魔理沙的弹幕会变得越来越难躲。果然魔理沙就是姆q在借书上的死对头啊（。 No.13（外传总No.243）游戏名：幻想探索 にとろいど！ 游戏类型：动作游戏 Produced by： 阿空逃了，神奈子很没办法，然后悬赏找她。荷取发现了机会，准备在其他人之前先找到，好好利用一下核能。游戏就是在地牢（看着也不像啊）里到处探索，寻找必要的工具，顺便收集蘑菇从魔理沙那换东西。整个大关是一个world，其中的小关互相连通，需要在某一小关拿了物品或道具，开其他小关的路。相对应的需要到处跑路，看看从哪能突破一点拿到新的东西，简直路痴杀手（。 No.14（外传总No.244）游戏名：走る！咲夜さん 游戏类型：动作游戏 Produced by： 算是一个爽游吧，操纵咲夜冲冲冲，在限定时间内到达终点。路上其实比较难走，有一些“悬崖”不小心就会掉坑，还有地上的刺、路上敌人以及弹幕，冲得快就会比较难躲，冲得慢就有过关时间限制和大坑强迫你冲刺。注意一下血条吧。 每一关都有道中和boss部分分开，过一关要打好几个部分，各部分之间残机共享。不过残机挺多，而且也有加残道具，相对来说也算是人性化了。 No.15（外传总No.245）游戏名：小町でアクション 游戏类型：动作游戏 Produced by：うたかたグラビティ 一个玩起来还挺有意思的小町主角动作游戏。因为灵梦懒了，所以四季让小町运动运动去解决异变（啥么子啊）。有近战砍和远程扔钱，不过还是砍伤害比较高。可以在香霖堂买一些技能和血、能量上限，还有砍妖怪回血回魔那个技能，确实好用。因为道中路上挺难走，砍一砍回回血也好走；当然也有一些地形是即死的。boss越来越难打，需要背出招然后提前做应对。打完之后还有ex模式，不过我是真的打不动了（ No.16（外传总No.246）游戏名：幻想郷大乱闘 游戏类型：动作游戏 Produced by：ごらんのすぽんさー 也是一个大乱斗形式的对战动作游戏，根据文件来看应该是可以四人连网对战的。不过因为没人和我玩也就没测试。行动还是射击跳跃攻击防御四个基本操作，不过行动还是有点硬的，比如跳跃一下跳的老高没法控制高度之类。不过画风似乎还不错。 No.17（外传总No.247）游戏名：げんそうきょう ふぁんたじあ 游戏类型：动作游戏 Produced by： 一个短小而挺有意思的游戏。 就如同上面这几个画面，主线是灵梦被雷雨惊醒，发现赛钱箱没了，判断是魔理沙偷走了，然后去找魔理沙干一架的事。鼠标点击控制移动方向、拾取物品，双击使用右下角item里的物品。有一些类似需要装备的，比如灯笼，要放在右上角的快速栏里自动使用，而恢复药之类也可以放在右上角，按相应按键使用。 有些地形需要跳跃可以按鼠标右键，而跳不过去的大坑要去花田收幽香，来用伞飘过去。一共可再收四个人物，每个有不同特性，比如速度和攻击。攻击是自动模式，朝向敌人即可。花田还有个小集市，可以买恢复药。有一个细节挺惊奇的，就是它会读取你的游玩时间，就像途中左上角，按照时间会有游戏内的黑夜白天变换。（毕竟也是peposoft做的，pepo还做过月神夜，月神夜里蕾米战背景钟楼也会显示当前时间） No.18（外传总No.248）游戏名：Spring Catastrophe 游戏类型：动作游戏 Produced by：ほわいとふれあ（46flare） 46flare是一个挺专一的社团了，主要都做的是莉莉白为主角的游戏。这个游戏因为暂时还是未完成版，所以体验可能会与完成版不太一样。 游戏操控莉莉白打小怪，然后收集掉落的各种素材，做一些可以增加春度的摆设，在据点里摆一摆，达到一定春度就可以打开下一个地图继续探险。暂时只有这样很简单的机制，游戏性稍微欠了点。不过立绘是用了pudding太太的莉莉白（大概），立绘挺漂亮。 No.19（外传总No.249）游戏名：Touhou The Shrine Maiden 游戏类型：动作游戏 Produced by：fairyhell 一个仿三目童子做的作品，比如钱越打越大，还有扔 神鹰 御币作为跳板这些有特点的要素都学的有模有样。当然商店就是香霖堂了，可以买命买血买装备。不过相比起来这个游戏的操作手感并不算好，比较僵硬，几乎全身判定给弹幕躲避造成了难度。 No.20（外传总No.250）游戏名：妖魔ディスガイザー 游戏类型：动作游戏 Produced by：non-study 大狸子主角的动作游戏。大狸子伪装人类在铃奈庵打工，小铃让她回收散落在各处的被借走的书，然后大狸子就拉上恋恋去行动了。大狸子有三种攻击，远射和两个近程，消耗左下角HP红心上面的卡片发动（发动后自动恢复，且恢复期间不能使用），而且还能使用变化玉把敌人发来的子弹变成自己的子弹打回去。被撞到掉血不是立刻掉，而是会警示一下，这期间再被碰到就会掉血。cpu恋恋会自动攻击，不过ai在行走上可能有点傻），当然也可以双打。打败敌人会获得她的能力，而且变化子弹对打boss有很大用处。 pid=29081096 volantis.js(\"https://unpkg.com/pandown\").then(pandown)","categories":[{"name":"游戏","slug":"游戏","permalink":"https://neko-horikawaraiko.github.io/categories/%E6%B8%B8%E6%88%8F/"}],"tags":[{"name":"带你玩东方","slug":"带你玩东方","permalink":"https://neko-horikawaraiko.github.io/tags/%E5%B8%A6%E4%BD%A0%E7%8E%A9%E4%B8%9C%E6%96%B9/"}]},{"title":"【鼓哥】带你玩东方-外传（十五）（射击游戏篇）","slug":"【鼓哥】带你玩东方-外传（十五）（射击游戏篇）","date":"2021-03-06T17:43:05.000Z","updated":"2024-11-04T16:23:39.759Z","comments":true,"path":"2021/03/07/【鼓哥】带你玩东方-外传（十五）（射击游戏篇）/","link":"","permalink":"https://neko-horikawaraiko.github.io/2021/03/07/%E3%80%90%E9%BC%93%E5%93%A5%E3%80%91%E5%B8%A6%E4%BD%A0%E7%8E%A9%E4%B8%9C%E6%96%B9-%E5%A4%96%E4%BC%A0%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89%EF%BC%88%E5%B0%84%E5%87%BB%E6%B8%B8%E6%88%8F%E7%AF%87%EF%BC%89/","excerpt":"","text":"大家好，这里是猫耳堀川雷鼓~ 这一篇呢，是给大家带来飞行射击游戏，也就是常见的简写为stg的一类游戏，的一些游戏介绍。文章中的游戏总的来说可玩性还可以，不乏有些有希望做的好但是最后没做完的游戏，其实有些挺可惜的…… 另外，从这一篇开始准备只有有需要才把游戏发出来了，可以私信或者在文章下评论，如果能发出来就向所有人公开，毕竟度度动不动就分享不出去，一个个找来打包不管是上传还是下载都麻烦。 No.1（外传总No.211）游戏名：ドSな早苗さんは切なくて霊夢ちゃんを見かけるとつい喧嘩売っちゃうの 大爆発 游戏类型：飞行射击游戏 Produced by： 和下面要介绍的两个游戏是同一个人作品，都是小体量的stg。手感相较官作差了一点点，但是游戏性还不错。灵梦的立绘属于萌系，来自于はーとふるふぁんしー，而早苗就是作者自己画的了。音乐却选择了魅魔的主题曲。 No.2（外传总No.212）游戏名：ドSな早苗さんは切なくて小傘ちゃんを見るとすぐ虐めちゃうの 大往生 游戏类型：飞行射击游戏 Produced by： 这个就是相对早一些的了，评价嘛，和上一个差不多。 No.3（外传总No.213）游戏名：すたぁこいしあたっく！（Star Koishi Attack!） 游戏类型：飞行射击游戏 Produced by： 这个作者的第三个东方同人stg，相较前两个介绍的游戏来说，内容稍微少了点。游戏两种模式整体都是一节一节的循环，一节中就是几种妖精及发弹方式的随机排列，然后打一次阿燐，打赢升一个等级，提升等级相对应的弹量变多，掉落物（三角形的“星星”？）变多，也就是多得分。两种模式区别在于，2分钟的模式残机无限，打赢阿燐掉落30s的加时道具，而无限模式只有2残，阿燐掉的是加分道具。 到这里再补充一句，这个作者的最新stg游戏也已经上架steam了，就是 DANMAKAI: Red Forbidden Fruit（弹幕魔界:红色禁果），很好玩的一个stg，喜欢stg的玩家可以前去了解一下。 No.4（外传总No.214）游戏名：東方古魔郷 游戏类型：飞行射击游戏 Produced by： 这是一个fc风的红魔乡复刻版本，流程可以说是非常还原了。受限于“机能”，游戏只做了一个难度，大概在easy+左右的水平，通关一般都不是问题。音乐跟着做了8bit风。手感相对于官作也是差了点。但是最遗憾的是流程只有前三面，也就是个体验版的长度。 No.5（外传总No.215）游戏名：東方環境破壊Touhou Kankyo Hakai - Parable of Irreplaceable Disposeables 游戏类型：射击游戏 Produced by：hp78, RaythalosM, RozenRozarai 游戏机制很奇特的一个游戏。魔理沙的扫把和八卦炉丢了，于是她前去寻找异变原因。魔理沙初始有三发子弹，通过打爆妖精或者木桶来获得新的子弹，所以子弹需要省着点用。子弹形式在左下角显示，比如图二中开花一圈样式就是一层旋转开花弹，三分叉就是三颗子弹分叉样射出。左下角框中显示的是下一发子弹样式。被打到的话会掉落最后拾取的两发子弹，掉没了再被打一次游戏结束。游戏画面比较清爽，协调性也不错，音乐是星之器和magus night，好听但是稍微有点不搭（。难度上，稍微有点难度，也在正常范围内。 No.6（外传总No.216）游戏名：風 游戏类型：飞行射击游戏 Produced by：さくらもち製作所 在普通stg基础上加了风向影响，风不仅会影响子弹方向，而且影响移动，不过低速模式会抵抗风的移动。自机的B是拍照消弹，与文花帖差不多。自机有个特殊能力也是吹风，从下向上方向，可以吹一些特殊子弹，有一些符卡解谜会用得到。 No.7（外传总No.217）游戏名：紅 游戏类型：飞行射击游戏 Produced by：さくらもち製作所 上一个游戏的前作）。本作的特殊能力是蕾米高速移动时会在身边形成红雾，可以消除部分弹幕生成point。前面忘了说，这两作都是point每10000奖一个残。 No.8（外传总No.218）游戏名：あやや 游戏类型：飞行射击游戏 Produced by：Noro 毛子兄弟做的一个射击游戏，只有一关，大概是文文去解决春雪异变？（因为对话是俄语所以根本看不懂瞎猜的）不过有一个非常有意思的特性是，文文普攻蓄力是放旋风，可以吹走大部分子弹，但是要大于30%蓄力才能释放。手感有点滑，不知道是因为文文还是数值设定没选好，而且有些小米弹混在背景不容易发现。 No.9（外传总No.219）游戏名：東方幻勇夢 ～ Brave and Darkness. 游戏类型：飞行射击游戏 Produced by：五層式洗濯機 一个类ex单关的stg游戏，不过却做了4个难度，我只打了normal感觉比正作的ex简单点。机体四个，灵梦魔理沙加上两个不认识的（原创角色吧），整体手感有点滑，按键因为没法设定shift为低速所以会比较奇怪。判定很小，可以放心猴（ No.10（外传总No.220）游戏名：Runtime Massacre 游戏类型：飞行射击游戏 Produced by：HP78, Lactose Intolerance, bentoreo, RozenRozarai 阿燐为主角的横版射击游戏，系统其实挺像收集荷取的。一开始只有一条直线的自机弹幕，打倒妖精或者毛玉就可以用推车收集上来，就可以发射相应弹幕。也不是一直都可以收集的，推车可以装的妖精应该是有一个上限。不过就这些在遇到关底boss基本也都可以秒杀了，血条很薄。欧美作者，画风就是那种很传统的欧美感觉，音乐也做的不错。 No.11（外传总No.221）游戏名：東方雨仰石 游戏类型：飞行射击游戏 Produced by： 一个很出名的鸽子游戏，从2017年开始就停更了，然后没有任何消息（但这社团更新了方解梦异闻的补丁都不更这个）。 主要是讲幻想乡又被下雨淹了，然后灵梦魔理沙小碗去解决异变。这一作特殊系统是雨水，收集雨水到左侧槽，满一格就可以释放满水御札，画面出现一个降水区域，在这个区域被击破的敌人会掉落双倍资源，得点也是最大得点。 No.12（外传总No.222）游戏名：Touhou ~Unmei no Hoshi~ 東方運命の星 游戏类型：飞行射击游戏 Produced by：chronoDave pico-8风格的射击游戏。最近接触的最多的pico-8风游戏应该是《Celeste》里那个小游戏，这个也是同种风格。这个游戏只有4个boss战，主角倒是可以选灵梦魔理沙。游戏音乐也是8bit风，挺好听的；美术风格像patchcon风。操作上和正作有点区别，x射击，z放b，方向键方向，射击时自动低速，所以有些弹幕并不好躲。整体还挺推荐玩玩，但是有点小bug，上一句放没的b下一局都不会自动恢复（ No.13（外传总No.223）游戏名：東方紅夜翔 游戏类型：飞行射击游戏 Produced by：ちびっこ娘々 一个能用很多人物的stg，不过都只有一条命，也只有一个难度。自机可以在美铃、早苗、咲夜、uuz、铃仙、文文、爱丽丝、魔理沙里面切换，每个人物有不同的射击特性，比如铃仙小范围爆炸弹，文文穿透弹（仅指敌人）、早苗全方位弹……。不过难度还是有点的，尤其是很容易从屁股后面来敌人向你发弹，而且地形有碰撞判定即死，比较恶心。而且游戏只有一点音效，没有bgm。 No.14（外传总No.224）游戏名：超小傘 游戏类型：飞行射击游戏 Produced by： 小伞从外界找到了两个新的辅机，然后回来找早苗报仇了（辅机是俩兄贵，音效也超兄贵，所以标题就这么来的）。横向射击游戏，早苗的符+非总共个数就是右边蓝绿色条块数，很类似于ex配置，但是有难度选择。因为是横版所以可能习惯于纵版stg的人不太舒服。 No.15（外传总No.225）游戏名：だんまくちくおんき / Newだんまくちくおんき 游戏类型：stg（音乐射击游戏） Produced by： 两个挺神（但是理解里面的原理之后就不那么神秘了，虽然我也还不懂是什么原理）的音乐游戏。看到两边的波形图了吗，那是背景音乐的波形图，这两个游戏分析bgm的相关波形，并让敌人作为弹幕节奏打出来。最主要的是可以设定自己的bgm，只要放进/bgm文件夹里就可以读取，但仅限于.ogg文件。第一个游戏是较早版本，小伞的弹幕几个阶段轮换着来，只配合节奏；第二个new版换成了夜雀，虽然也配合节奏但是没有明显的阶段了，而是根据乐器音色（？）配合在一起，比如较脆的音色发星星弹，较沉的音色发光玉等，所以各种弹幕会混在一起。相比起打游戏来，这游戏主要还是听歌用吧。 这让我想起之前玩过的另一个音乐射击游戏，是根据音乐生成敌人的，名字《Symphony》，中译名《自由交响》，华丽程度很高，所以比较瞎眼。说实话当时觉得挺难的（ 《自由交响》游戏截图 另外听说还有一个游戏叫《Beat Hazard》也是类似的游戏，不过我没试过。 No.16（外传总No.226）游戏名：蒐集王 游戏类型：飞行射击游戏 Produced by： 火 达 火 火 人 火 火 王 火 达人王怎么玩这个就怎么玩就是了（ No.17（外传总No.227）游戏名：Touhou 2: The Story of Eastern Wonderland NES Demake 游戏类型：飞行射击游戏 Produced by： 一个复刻旧作的团体做出来的封魔录复刻。手感上要比原作好，也加上了低速模式。道中那些弹幕设计改了一些，有的地方变简单了有的变难了。也没有了原作的连按增加火力的bug。可以作为娱乐打打，“大致”见一下原作是啥样，但是完全不能作为参考。 No.18（外传总No.228）游戏名：東方虹夢化学 ～illegal Science～ 游戏类型：飞行射击游戏 Produced by： 一个比较特殊的射击游戏，需要通过自己变颜色吃同色弹幕来提升攻击力。右边每攒满一瓶颜色就会清一次相应颜色弹幕，达到圈内中间的数值就清一次全颜色弹幕。这是类似于斑鸠的设计，但是颜色太多了，要分心看弹幕颜色的话就容易撞，其实也算是一种设计缺陷。 No.19（外传总No.229）游戏名：東方水晶宮 游戏类型：飞行射击游戏 Produced by：Fe 一个比较知名的stg，界面非常像风神录。作品只有3关的长度，所以难度上相当于1+4+6这三关。手感与原作相近，音乐也是主要使用了同人曲。前面boss都为原作角色，而3boss为知名同人角色左城宫则纱（感谢@深海_Salt指正）。 No.20（外传总No.230）游戏名：萌える弾幕Stg もえだん 游戏类型：飞行射击游戏 Produced by： 一个比较出名（？）的弹幕游戏，“芙兰也能懂的弹幕教室”。介绍了一些基础的弹型，也介绍了躲法，不过是日文（该看不懂的还是看不懂）。由于弹幕都特简单，适合作为stg新手入坑练习使用。不过相应的中文游戏也有一个，就是之前的《弹幕音乐绘：基础教学篇》，也是介绍弹型及躲法，不过比起这个来弹幕也是难了点（指音乐绘最后一讲）。 pid=65002165 volantis.js(\"https://unpkg.com/pandown\").then(pandown) volantis.js(\"https://unpkg.com/pandown\").then(pandown)","categories":[{"name":"游戏","slug":"游戏","permalink":"https://neko-horikawaraiko.github.io/categories/%E6%B8%B8%E6%88%8F/"}],"tags":[{"name":"带你玩东方","slug":"带你玩东方","permalink":"https://neko-horikawaraiko.github.io/tags/%E5%B8%A6%E4%BD%A0%E7%8E%A9%E4%B8%9C%E6%96%B9/"}]},{"title":"【鼓哥】带你玩东方-外传（十四）（解谜、策略游戏篇）","slug":"【鼓哥】带你玩东方-外传（十四）（解谜、策略游戏篇）","date":"2021-02-17T14:52:11.000Z","updated":"2024-11-04T16:23:33.811Z","comments":true,"path":"2021/02/17/【鼓哥】带你玩东方-外传（十四）（解谜、策略游戏篇）/","link":"","permalink":"https://neko-horikawaraiko.github.io/2021/02/17/%E3%80%90%E9%BC%93%E5%93%A5%E3%80%91%E5%B8%A6%E4%BD%A0%E7%8E%A9%E4%B8%9C%E6%96%B9-%E5%A4%96%E4%BC%A0%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89%EF%BC%88%E8%A7%A3%E8%B0%9C%E3%80%81%E7%AD%96%E7%95%A5%E6%B8%B8%E6%88%8F%E7%AF%87%EF%BC%89/","excerpt":"","text":"大家好，这里是猫耳堀川雷鼓~ 这一篇介绍一些策略或者益智类的游戏，反正都需要动脑子讲策略，不如好好活动活动大脑吧~ No.1（外传总No.191）游戏名：紅魔の鍵 游戏类型：解谜游戏 Produced by： 神子想去红魔馆找蕾米打个招呼，结果需要一扇门一扇门找钥匙找上去才能见到。这个游戏就是操作神子，通过搭建砖块拿到钥匙到达关卡终点门的游戏。不过路上小怪还是比较恶心的，你一个都不能碰，还有小怪会发弹打你，不过可以用砖块来挡两下。可以吃一些敲碎砖块得的道具来助力，比如红药水就可以发一次子弹打掉妖精，符卡直接全屏清怪，表盘进行时停等。还有符札、八卦炉可以召唤油库里，吃掉10个可以加一条命。但是因为神子走得比较慢（冲刺也不好使），所以提高了整体难度。 No.2（外传总No.192）游戏名：MARIALIDOLL～魔理沙伝～ 游戏类型：策略游戏 Produced by：すいかも▲共和国 如果有玩过ドラゴンボール3 悟空伝（七龙珠3 悟空传）的朋友应该一眼就能认出来，这个游戏就是完全仿照悟空传来做的。在大地图上消耗卡片，按照八卦炉的黑色区域数目移动步数；进入标记区域会发生事件、获得道具等。战斗时比较选择的卡片八卦炉黑区数目进行攻击优先度判定，如果比对方小就靠右下角数字减伤。战斗获胜获得经验，可以提升能力。在菜单可以使用道具卡之类回血、换卡等。总的来说难度不算太高，需要一些策略才能比较好通关。 No.3（外传总No.193）游戏名：EAT&amp;BITE with東方 游戏类型：解谜游戏 Produced by：grayf 一个猜数游戏。通过各种提示在20次操作之内猜中一个各位不相同的三位数。High&amp;Low给提示每一位处于什么范围，Low是0-4，High是5-9。直接点击数字组成三位数，系统给判断一共有多少位是Eat，多少位Bite。Eat数代表有多少位是正确的（位置和数字），Bite数代表Eat之外有多少位是数字猜中但是位置不对。 No.4（外传总No.194）游戏名：妖精大回籠 游戏类型：解谜游戏 Produced by： 这的社团的又一个作品。其实看游戏名就有印象，这个社团的游戏大多以妖精大XX为题，主角也是大妖精（或者加上⑨）。 这个解谜游戏是操纵大妖精，在可以旋转的地图中获得钥匙打开门。橙色砖块可动，类似推箱子，两个叠在一起不可推动，这个时候推砖块者推动墙壁的时候，可以将整个地图转九十度。靠着这种机制在限制的回转数之内进到门里。整个游戏难度挺大，因为相似机制的游戏并不多，也没有什么统一解法。 No.5（外传总No.195）游戏名：Touhou Yahtzee 游戏类型：策略游戏 Produced by：poltergasm 这个游戏就是Yahtzee快艇骰子的东方版，每次选择要重抽的牌，三次后选择更合适的组合形式来记分，每种组合形式只能选一次。由于本来是骰子游戏，所以牌也只有1-6的六张。详细记分法可以搜索这种游戏了解。 No.6（外传总No.196）游戏名：东方淫乐乐 游戏类型：策略游戏 Produced by：漂亮同人堂 一个根据打出的点数牌的张数来对战的卡牌游戏，说是卡牌实际上还是不太像的。就如图所示，中间的1-5点数的牌堆是你和对方总共打出来的牌，只要你打出的牌使得有一摞牌张数超过4就能给对面造成伤害。把对方的血打完你就赢了。游戏系统很简单，可以作为打发时间来玩玩。人物可以加属性点来提升能力，使用技能，使用道具等，不过因为这些名字太有“个性”了怕过不了审，所以图就不放出来了。 No.7（外传总No.197）游戏名：妖精大穿功 游戏类型：解谜游戏 Produced by： 还是那个社团做的大妖精解谜游戏。这次是大妖精射击来打靶，把关卡内全部靶都打中就算过关。由于大妖精的射程很短，游戏设计了一些道具，比如穿透弹、远射弹等来打击特殊位置的靶子。有些道具可以不使用，有多种办法可以打靶子，但是场上拿道具的顺序还是有些讲究的。 No.8（外传总No.198）游戏名：东方霁月牌 游戏类型：策略游戏 Produced by：千葉玖濑 说实话，这游戏我没玩懂（。图上手牌中像水晶一样的东西叫“霁石”，大致意思就是互相抽牌，然后通过各种功能牌设置霁石攻击次数、个人减伤等等，然后全部人的防御之和达到4时由手中有一张特殊牌（11号牌）的人指定发动攻击的霁石属性，此时相应属性霁石会攻击玩家。目标就是把boss打倒。不过这挺难打的，最好手中有11，猜对boss手上有什么霁石然后直接打，要不就会很拖拉…… No.9（外传总No.199）游戏名：東方でおちげー 游戏类型：解谜游戏 Produced by： 算是带点策略的游戏吧，有点像噗哟噗哟，通过调整下落的块来将底下的块消除。消除规则是至少两个同样颜色阴阳玉，连带这之间水平或竖直的人物方块消除，消除会给右边人物造成伤害（单人模式）。每一阶段都会有相应阶段的爆衣立绘（但是有点冲不起来……）。单人模式有多个关卡，不熟悉机制的话还算挺难的，方块下落速度有点快。 No.10（外传总No.200）游戏名：東方水晶郷 游戏类型：解谜游戏 Produced by：⑨、liqunsz 用宝石迷阵3的宝石素材做的一个三消解谜游戏，主线是借用了红魔乡的boss，每个人物守一关，每关都有一个限制条件，就是boss的技能，达到右侧写的击破条件就算过关，实际上没什么难度。自机power随着时间慢慢减少，按鼠标右键消耗较大量power放符卡，星星数是可放符卡数，星星和power随着消宝石恢复。 No.11（外传总No.201）游戏名：東方どろっぷす 游戏类型：解谜游戏 Produced by： 跟俄罗斯方块挺像的一个游戏。不过不是消除方块，而是搭方块让角色走到终点门。角色只能爬一阶台阶，所以上坡只能慢慢搭上去，下坡就什么高度都可以了。路上可能会有一些妖精发弹幕打角色的血，打没也算失败。落下的东西不仅有方块，还有炸弹，可以炸掉周围8格的东西；还有角色符卡，不同等级符卡有不同效果。后面会让多个角色进门，由于不是同时从入口出来，给搭方块造成了些难度。 No.12（外传总No.202）游戏名：東方ぱねたま 游戏类型：策略游戏 Produced by： 这个解谜游戏挺像一个益智游戏叫nonogram（中文一译作“数图”），不过和那个还是有些区别的。这个游戏是收集“天气玉”然后凑符卡给对方造成伤害。中央棋盘上四周的方块里的彩球代表三种颜色的玉在相应行列各有多少个，翻棋盘格来寻找天气玉，凑出来相应条件符卡时，可以发动来给对方造成伤害，把对方血条打没算胜利，当然能打多少血也要看你能不能把对方逼得没地方走（这时候像是不能射击的stg）。主要有两种模式，一种是一人翻一次，另一种是所有人随便翻，一人一次的非常考验分析能力。 No.13（外传总No.203）游戏名：アリパチェ in Wonderworld 游戏类型：解谜游戏 Produced by： 又是一个悠遊亭的游戏，这次是一个解谜，主角是迷失在书中的姆q和爱丽丝（双七党欢喜）。目标是轮流控制两人，通过各种能力以及“操作”打开终点大门过关。爱丽丝和帕秋莉能力不同，爱丽丝跳的矮而且稍微远一点，可以获得人偶道具，然后扔一个爆炸人偶，可以炸掉砖和敌人，可以被姆q踩着移动；姆q跳的高但是近，可获得两本魔法书，放火焰烧雪球或者放“翡翠巨石”当垫脚石，被爱丽丝踩着不能移动。根据这些特性来拿到一把终点门的钥匙，一个人进门就可。每大关过了前面几关会有终boss，打败boss才可到下一大关。 No.14（外传总No.204）游戏名：チルノでポン 游戏类型：解谜游戏 Produced by：無限旋律 一个只能平着交换的三消游戏，新的方块都从底下出来，随着时间（？）上升会越来越快，就是尽量多消除吧。 No.15（外传总No.205）游戏名：ばいなりぃすわちるの 游戏类型：解谜游戏 Produced by： 前几天说的那个游戏，它来了。这确实是一个“双人游戏”，因为是一个人要控制两个角色。主控的方向是青蛙子，⑨是按照左右相反上下相同的方向来走。所以需要碰墙来调整相对位置。目标确实是到达红心终点，但是要同时到达，而且有些关有蓝点，所有蓝点都吃了红心才会开放。另外动态说掉下洞去怎么样，实际上也不怎么样，就是游戏失败而已（ No.16（外传总No.206）游戏名：守矢神社の鍵 游戏类型：解谜游戏 Produced by： 实话说，这些XXXXの鍵的游戏都挺相似的，比如本篇第一个。类似的，人物可以放置砖块来垫脚或者阻挡敌人等，目标是吃到所有星星或者按顺序吃一些砖块来打开终点门。这游戏总100关（挺长的），我去100关看了看完全不知道咋解。后排提示小心音效（ No.17（外传总No.207）游戏名：東方SRPG乱愚風 游戏类型：策略角色扮演游戏 Produced by： 一个策略角色扮演游戏，一看就知道也是仿火纹的系统。这里的妖精需要你自己花钱购买进行选择，不同妖精有不同作用。玩家的主操是人物，可以放技能及反击，并且己方妖精在人物的“影响范围”内会有能力加成。每一关有特定的胜利失败条件，打关时注意把握机会吧。 No.18（外传总No.208）游戏名：東方賭博録カグヤ 游戏类型：解谜游戏 Produced by： 名字一看就是模仿了赌博默示录，立绘也挺模仿的，不过就是个解谜解谜游戏合集。比如先跟红魔乡众玩剪子包袱锤，直到6赢3为止。然后去跟灵梦魔理沙躲弹幕，最后压官职游戏（皇帝平民奴隶）拼概率之类。主要凭借对方的话来判断他的下一步动作，然后选择自己的出招。作者贴心的在自己网站上做了攻略，不过也有所保留。 No.19（外传总No.209）游戏名：波乱盤外！？香霖堂！ 游戏类型：策略游戏 Produced by：ルート 一个卡牌对战游戏，主要就是在7回合内每回合打出一定的手牌，通过手牌的各种效果增加己方或减少对方的power值（卡牌上红色圆圈的数字），使总power大于对方从而获胜。玩起来还是有点意思的，详情可以看下面@KK的献祭的专栏以及他的视频。 【东方同人游戏】波乱盘外香霖堂 基本安利https://www.bilibili.com/read/cv1863618 No.20（外传总No.210）游戏名：東方牌乱符 游戏类型：策略游戏 Produced by：隣の世界（隣野みとも） 和平常打麻将差不多，但是役种不同且带有符卡的一个棋牌类游戏。因为牌面上是人物，所以没有“吃”这一说，只有三张牌“碰”，部分牌有9张，另外部分只有6张。具体的役种可以看说明书，比如上面这个紅魔館 All Stage就是两主角各2张，3-extra的boss各一张。符卡对对局会有些影响，比如不能碰只能自己摸之类。因为牌少所以打的非常快，也挺有意思的。 pid=42888153 volantis.js(\"https://unpkg.com/pandown\").then(pandown)","categories":[{"name":"游戏","slug":"游戏","permalink":"https://neko-horikawaraiko.github.io/categories/%E6%B8%B8%E6%88%8F/"}],"tags":[{"name":"带你玩东方","slug":"带你玩东方","permalink":"https://neko-horikawaraiko.github.io/tags/%E5%B8%A6%E4%BD%A0%E7%8E%A9%E4%B8%9C%E6%96%B9/"}]},{"title":"【鼓哥】带你玩东方-外传（十三）（其他游戏篇）","slug":"【鼓哥】带你玩东方-外传（十三）（其他游戏篇）","date":"2021-02-10T18:08:34.000Z","updated":"2024-11-04T16:23:27.093Z","comments":true,"path":"2021/02/11/【鼓哥】带你玩东方-外传（十三）（其他游戏篇）/","link":"","permalink":"https://neko-horikawaraiko.github.io/2021/02/11/%E3%80%90%E9%BC%93%E5%93%A5%E3%80%91%E5%B8%A6%E4%BD%A0%E7%8E%A9%E4%B8%9C%E6%96%B9-%E5%A4%96%E4%BC%A0%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89%EF%BC%88%E5%85%B6%E4%BB%96%E6%B8%B8%E6%88%8F%E7%AF%87%EF%BC%89/","excerpt":"","text":"大家好，这里是猫耳堀川雷鼓~ 这是分类后的第二篇啦，不过这一篇比较偏杂项，包含音乐游戏、视觉小说、养成游戏还有啥啥啥不知道该分到哪一类的游戏，因为这几类游戏现在看着比较少就先合成这一个专栏了。 No.1（外传总No.171）游戏名：ネムノリズム 游戏类型：音乐游戏 Produced by： dbu开始做游戏之后确实有点优势啊（不过劣势也很明显） 这是dbu的新一款游戏，操纵欢姐来按节奏切菜做饭。游戏整体上和muse dash区别不大，可以认为是muse dash东方版（。不过这个游戏判定感觉上要宽松一点，而insane模式音符速度非常快（确实也有人能打这么快就是了）。 No.2（外传总No.172）游戏名：こなぐすりの達人 游戏类型：音乐游戏 Produced by： 这个社团的有一个音乐游戏（似乎做了好多音乐游戏啊），这次的按键依然是推荐PS手柄，看图上的符号表示就知道了。在设置里也可以设置为一些比较好反应的符号比如上下左右箭头，就能比较舒服地用键盘来玩了。不过依然音乐有点少，只有四首歌各四个难度，再加上斜向过来相当于不同基准线的音符，较为严格判定但似乎有些音符节奏不对缺乏校准的系统，上手确有一些不舒服。 No.3（外传总No.173）游戏名：東方探偵倶楽部 游戏类型：文字冒险游戏 Produced by：アルケミスト・ラボ 紫妹突然消失，大结界出现大量裂缝，橙喵迷路无踪，蓝妈不知所措，便向灵梦求助解决异变，寻找消失的紫妹修补大结界。整个游戏是以文字冒险为主，剧情、行动都通过文字选项操作，颇有当年文字武侠游戏风范，不过这里加上了图片可以点击，还能够获得地图，不至于需要太多空想或者手记。作为侦探游戏，难点是需要进行文字分析找到出去的路线，但是最大的难点其实在于日文看不懂（ No.4（外传总No.174）游戏名：どーるずうぉーきんぐ 游戏类型：模拟游戏 Produced by：萃符東方合同企画 一个挺特别的养成游戏，是爱丽丝制作的自立人形的养成。首先游戏是一大段avg小说介绍背景，然后就可以进入游戏养成了。人形有多种属性值，就比如左边列出来这一堆，进行不同的事情概率增加/减少不同的属性值，不过属性值越高/进行次数越多减少的概率会越小。还可以在休息日外出游玩，或者去香霖堂买东西使用之类。不过游戏确实没有个明确结束目标，就当是一直在养成好了。 No.5（外传总No.175）游戏名：半月昇夜 游戏类型：视觉小说 Produced by： 因为四季的失误而“被死亡”的霖之助，等待着下个月的转生机会。在变成灵体之后，他会看到什么样的幻想乡呢？又会和少女们发生什么样的事情呢？在本游戏中你会找到答案。 不过这个作者写的同人文确实多，他博客上密密麻麻几十上百个同人文。部分是系列部分是短篇，每一篇/部分大概就是一个网络小说一章的长度。 No.6（外传总No.176）游戏名：しんれいびょーのおへや 游戏类型：模拟游戏 Produced by：ごましお 这是一个神灵庙角色养成游戏，和小时候玩的宠物机挺相似，不过这个系统要简单得多，用不着时时刻刻注意饿没饿死什么的（ 主要流程就是玩小游戏，内置10个不同类小游戏，有什么躲子弹、移动射箭、贪吃蛇之类，根据得分给相应的金钱，然后买房间装饰和花园的装饰装点着玩。 No.7（外传总No.177）游戏名：レミリアのドキワク紅魔館～前編～ / ～後編～ 游戏类型：文字冒险游戏 Produced by：float counter 红魔馆里发生异变了，迷之眼镜肌肉男袭来，馆内居民失踪。蕾咪需要在红魔馆里重新找回这些人。前篇找到了咲夜，但是被袭击之后又丢了。后篇里有了后宫美铃和姆q，再寻找剩下的人。在馆内探索各种奇怪的地方，带领不同后宫来破除迷局。整体视角只有中间一小块，肌肉男会在某些地方突然出现抓人，被抓就扣一次机会，注意存档吧…… No.8（外传总No.178）游戏名：東方弾幕崩 游戏类型：动作游戏 Produced by： 把弹幕当成砖块打的游戏见过没，这就是一个。游戏把原作弹幕形式提取了一些特征，然后做成了以子弹为砖块的打砖块游戏。相比起来，因为“下压严重”，所以很容易阴阳玉打出去之后一反弹直接掉下屏幕miss。与原作灵异传有点相似之处，比如可以发封魔针（灵异传是符札）把子弹砖块打掉，但是是有限制的，就是右下角的P点，可以通过打砖块掉落补充。 No.9（外传总No.179）游戏名：虹色の監獄 游戏类型：视觉小说 Produced by：毒電波新聞社 Warning！！！注意个人不良反应 芙兰为主角的视觉小说，但是主题非常……反正是比较过，有异文石2那味道了。想了解详情自己可以看看（反正我也是看不懂日语） No.10（外传总No.180）游戏名：ゆっくりのある生活 游戏类型：模拟游戏 Produced by： 就是一个养油库里的小游戏，和灵梦魔理沙蕾咪三选一的油库里做各种互动，看她撒娇啊生气啊买萌啊……，然后培养能力，升级什么的。不过因为是日语所以很可能就看不懂了。说实话里面口头禅“ゆっくり”是真的多。 No.11（外传总No.181）游戏名：雛ちゃんシースーロワイヤル 游戏类型：动作游戏 Produced by：mizusoba（いすぃ） 爱雏大师的作品之一，一个“拼手速”吃寿司小比赛。尽量吃上足够好足够多的寿司然后把别人比下去吧。人名下面的大概算是“体力条”，四种不同颜色盘子的寿司会增加不同体力，如果吃到带旗子的盘子就有可能掉体力的。玩家可以在盘子里放芥末，如果放了芥末的盘子被别人吃到，就会扣体力条；还可以做假动作而不放芥末（仍然插旗子），被别人或自己吃了会大幅增加那个人的体力条。完完全全一个算计与套路的游戏（ No.12（外传总No.182）游戏名：春告精を守れ！ 游戏类型：动作游戏 Produced by：ほわいとふれあ（46flare） 需要点分心的游戏，鼠标控制莉莉白在空中飞行，键盘控制大酱左右移动，向上射击来把威胁到莉莉白的妖精、毛玉等打倒，所以游戏就叫做了“守护报春精”。不过要注意不要射击打到莉莉白，那样莉莉白也会死（ No.13（外传总No.183）游戏名：いるからぼっくす_PART1 游戏类型：动作游戏 Produced by： 这个是illucalab做的flash有些合集的第一部分。第一个小游戏钻头露娜，就是按asx lkm这六个键来控制钻的方向，尽快往深处钻。画面上方的弧形条减少到没就游戏结束，这个条在钻的时候会增加。 第二个，鼠标控制小伞在伞上弹跳，避免掉落下去，尽量弹的次数越多，总距离越远越好。 第三个，鼠标或按键控制萃香张开嘴喝酒，避免吃到石头。每1000分会蹦一个小萃香到背景趴着去，这个也会加分。 No.14（外传总No.184）游戏名：東方逢縁譚 游戏类型：视觉小说 Produced by： 估计是因为打架，妹红头磕了一下，然后给磕失忆了，不过是近期的记忆。回到家后发现慧音在家，但是就想不起来对方是谁。游戏从多视角出发，讲述了妹红寻找记忆的过程……（不过确实配音不错） No.15（外传总No.185）游戏名：みらくる＠でぃざすたーず 游戏类型：角色扮演游戏 Produced by： 转转、椛椛、早苗三人的地牢冒险之旅，打倒路上的敌人逃出迷宫吧。三人能力不同，转转主要是打魔法伤害，但是行动速度慢；椛椛是物攻，血厚，速度快；早苗相当于奶妈，很脆，速度快。战斗是即时的，角色头上的行动条满了就可以行动。打到后期可以收新角色。总体来说整体气氛比较轻松，难度不高，就是容易迷路。 No.16（外传总No.186）游戏名：スワコチャンリフレクション 游戏类型：动作游戏 Produced by： 这游戏怪得很，毕竟是个April Fool’s Day特供游戏。表面上看是个打砖块，实际上会出现很多奇怪的现象，比如中间图的球直接穿过砖块而不打碎，下面的stage clear了但是到不了下一关等，还有些奇奇怪怪的现象等你发掘（ No.17（外传总No.187）游戏名：東方ローグライク 游戏类型：角色扮演游戏 Produced by：ｋnow 多个主题的小型不思议迷宫。啊实话说这些游戏都挺类似的，没啥可介绍的，不如以后类似的游戏也就放张图算了，除了去介绍aquastyle那个系列时候再多加点字吧） No.18（外传总No.188）游戏名：七色の人形遣いの 続・人形創り 游戏类型：音乐游戏 Produced by：kurama 表面看不出来是啥然而其实是个音乐游戏的游戏。只有两首歌，一个是蓝妈一个是紫妈。模式是先给你一个example turn，然后你跟着这个节奏把player turn打出来，是利用了这两首歌都有“每连续两个乐句近似重复”这么个特点。总体比较简单。 No.19（外传总No.189）游戏名：ルーミアちゃんブロック崩し 游戏类型：动作游戏 Produced by： 其实一看到XXX人物“ブロック崩し”之类的名字，就能大概知道游戏会是啥内容了，就是把人物衣服打掉然后XXXXX（数据删除），剩下的就是评价一下砖块（衣服）打起来的游戏手感和cg质量咋样了。这游戏的话……游戏手感有点差，但是cg还可（？ No.20（外传总No.190）游戏名：ゴムゴムぽん！ 游戏类型：动作游戏 Produced by： 又是一个打砖块，不过这个就相当有特点了，就是你的接板可以歪着，也可以跳起来，就像上图一样。主控诹访子的方向，然后板拉着鵺走，诹访子和鵺都可以跳起来，就能造成一个斜的板来接球。游戏性上当然比No.19好，但是加上lsp滤镜就不一定了。 pid=78366862 volantis.js(\"https://unpkg.com/pandown\").then(pandown) volantis.js(\"https://unpkg.com/pandown\").then(pandown)","categories":[{"name":"游戏","slug":"游戏","permalink":"https://neko-horikawaraiko.github.io/categories/%E6%B8%B8%E6%88%8F/"}],"tags":[{"name":"带你玩东方","slug":"带你玩东方","permalink":"https://neko-horikawaraiko.github.io/tags/%E5%B8%A6%E4%BD%A0%E7%8E%A9%E4%B8%9C%E6%96%B9/"}]},{"title":"【鼓哥】带你玩东方-外传（十二）（动作游戏篇）","slug":"【鼓哥】带你玩东方-外传（十二）（动作游戏篇）","date":"2021-01-02T16:49:18.000Z","updated":"2024-11-04T16:22:59.802Z","comments":true,"path":"2021/01/03/【鼓哥】带你玩东方-外传（十二）（动作游戏篇）/","link":"","permalink":"https://neko-horikawaraiko.github.io/2021/01/03/%E3%80%90%E9%BC%93%E5%93%A5%E3%80%91%E5%B8%A6%E4%BD%A0%E7%8E%A9%E4%B8%9C%E6%96%B9-%E5%A4%96%E4%BC%A0%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%EF%BC%88%E5%8A%A8%E4%BD%9C%E6%B8%B8%E6%88%8F%E7%AF%87%EF%BC%89/","excerpt":"","text":"大家好，这里是猫耳堀川雷鼓~ 从这一篇开始，我尽量把游戏按照个人感觉上的游戏分类归类介绍，相对来说会比较整洁一些吧。本期的内容是动作类游戏。 No.1（外传总No.151）游戏名：神魔討綺伝 ～ Magus in Mystic Geometries 游戏类型：动作游戏 Produced by： 这个游戏应该挺多人也听说过，因为zun曾经给这个游戏专门做了一首曲子《神魔討綺伝 AN ORDEAL FROM GOD》，作为第五关boss关的主题曲。主角姆Q，目标是消灭入侵的“魔界居民”，幽灵、人偶、十字玉这些。评价来说，算是一个爽游，按住射击键不放就行了。但是这几种敌人有不同的行动方式，注意不要被撞到，体术直接掉残。每关有一定数的残机与炸弹，但是掉残不会补充炸弹。尽量生存下去，吃掉敌人掉落的白点，吃到白点个数越多，敌人打爆得分越高，按照总分获得奖牌（boss关需另外击破boss）。不过比较恶心的是，敌人生成时候容易直接刷在脸上暴毙。 No.2（外传总No.152）游戏名：Mima’s new life 游戏类型：动作游戏 Produced by：Tristama 操纵魅魔通过跳跃和射击，躲避敌人的子弹，到达终点打败矜羯罗（矜羯罗：关我啥事？）。这是一个touhou fangame jam3的参赛作品，游戏前小故事说明了国外玩家其实也挺希望魅魔“复活”的，这个游戏就是魅魔为了证明自己“仍然强大”、“不是死了的角色”做出来的。 No.3（外传总No.153）游戏名：The underground Heist 游戏类型：动作游戏 Produced by：White Pikmin White Pikmin制作的又一个地牢类游戏，或者说是之前游戏的完成版，见下面专栏No.1（总No.91）的游戏。这次的游戏更新了部分美术素材，加了新的音乐与关卡，总的玩法和之前一样。新加入“收集品”，不过只是增加金钱而已，钱可以在5为尾数的关卡中的商店里购买物品（大P、满P、雷、半个残），一定程度上降低了游戏难度吧，毕竟道中这些小怪不掉B道具，很少掉回血道具，但是攻击方式还不太好躲。 No.4（外传总No.154）游戏名：フルモッコにしてやんよ! 游戏类型：动作游戏 Produced by： 看画风感觉还不错，但是游戏是的确不好玩的那种游戏。就是操纵妹红到处打一打跳一跳跑一跑，清完一关画面内所有的怪可以进入下一关。但是游戏打击感欠缺，攻击方式略微单调，而且敌人没有血量显示，打多少下才会死根本不知道。 No.5（外传总No.155）游戏名：东方启示录2：核子危机 游戏类型：动作游戏 Produced by：九州烽火工作室 一个坑向游戏，不过确实没有坑向iwanna这么虐就是了。说是灵梦为了抵抗外来侵略者的一个闯关动作游戏，游戏主要坑点也在于跳出去，就不一定会碰上什么了…… No.6（外传总No.156）游戏名：東方紅魔弾 游戏类型：动作游戏 Produced by： 一个难度很高的动作游戏。整个游戏故事过程和红魔乡近似，从游戏标题也看得出来。在路上有各种小妖精各种弹幕呼你脸上，要慢慢打过去或者利用擦弹系统（类似则的飞行擦弹机制）躲过去，因为作为一个动作游戏，这个弹幕量还是比较难躲的，加上操控不是那么精准情况下。虽然可以调整初始残机数比较高，但是没有续关，整体难度并不会因为这个简单多少。收集物是个芙兰标志，可能集满画面上方正中条的话会开启ex关吧。我也打不过，只能猜一下了（ No.7（外传总No.157）游戏名：Wriggle Story（リグルが自機のゲーム） 游戏类型：动作游戏 Produced by：GlowGloat 一个还未定名（2020.10.18，后定名Wriggle Story）的游戏，莉格露的虫子发现了一个异变（看文本是巨大甲壳虫？），于是就去探险了。暂时流程主要按照天空璋的顺序发展。游戏实际上是动作游戏和部分stg的结合，另外加上一点解谜要素。整个风格是按照八位机设计，操作上也比较简单容易上手，可以期待一下。（2023.6.22记：已经可以不用期待了，游戏本来在booth上卖，已经不卖了） No.8（外传总No.158）游戏名：ソードマスターテンシ 游戏类型：动作游戏 Produced by：ぴお 天子为主题的“剑术”游戏（？），总之就是一个砍砍砍的游戏，砍起来还是比较爽的。所有攻击都是各种“斩法”，幻影斩、天翔斩、有顶天破斩等等，普攻就是平连段，技能按X算是普通技能，奥义（特技）需要消耗左下角skill槽发动。一路就是砍各种敌人，打倒boss。不过boss的ai有些高，血量多的时候还好，一半的时候就像一个相对0被相对2打差不多，一旦被妖梦连击到基本都是2000伤害以上，而且妖梦的剑还比你长，技能比你时间长，还比你优先级高（似乎），确实难度不太合理。 No.9（外传总No.159）游戏名：東方幣札遊戯 游戏类型：动作游戏 Produced by： 叫币札游戏还真是币+札的游戏……灵梦可以通过挥御币和扔符札来打敌人，御币不管是木棍还是纸结打到敌人都会造成伤害，红符札是通过爆炸造成范围伤害，还能粘在敌人身上，蓝符札就是符卡，召唤4个阴阳玉自动追踪，持续一定时间的伤害。游戏在御币伤害上还是有点新意的，不同纸结可以多次造成伤害。整个游戏手感还可以，有惯性系统，音乐也不错，有boss战，可以尝试玩一玩。 No.10（外传总No.160）游戏名：蛮々奇々~ give me neck 游戏类型：动作游戏 Produced by：non-study 以赤蛮奇找头为目标的动作游戏。赤蛮奇用头来攻击敌人，算是一种近战方式。另外还可以把头扔出去，打中的敌人会暂时定住，此时可以当做垫脚石踩。路上收集丢失的头，在过关后可以增加一些能力。设置了boss战，有趣之处在于需要用飞头打中敌人多次，使之暂时陷入害怕状态，然后就可以近战造成大量伤害。 No.11（外传总No.161）游戏名：クロックコープス 游戏类型：动作游戏 Produced by：人形機械論 在3分钟时间内，操作咲夜扔飞刀击杀幽灵，尽量获得高分的一个游戏。可以使用时停将一定范围的幽灵减速（过一段时间会恢复），多积攒一些然后扔出飞刀进行连爆，可以获得更高的分数。每隔一段时间会有四个妖精出来发射弹幕，有些弹幕可以和妖精一样被摧毁或者连爆。收集幽灵爆炸后的“刻符”可以延长一小段时间，被弹会减少时间。游戏操作手感不错，稍微有点滑，整体来说游戏性也好。 No.12（外传总No.162）游戏名：ナズーリンの探しもの 游戏类型：动作游戏 Produced by：Little Prayer 纳兹琳找的东西？（游戏名）当然是找宝塔了。这个游戏就是操纵纳兹琳在各种地形跳来跳去，最后达到终点拿到宝塔。由于只有移动和一段跳，在有些地方还是比较难走的。根据每关所耗时间可以有ABC三个评价（测了很多次只有这三个），努力都拿到A吧。 No.13（外传总No.163）游戏名：疾きこと文の如し 游戏类型：动作游戏 Produced by：α-storage 算是一种竞速游戏吧，控制文文高速飞行躲避障碍。有三种模式，分别按达到的最高速、5000m到达时间、最远距离排名，主要游戏系统就是在右侧蓄力条超过border线之后按下z键加速。路上有各种柱子椛椛河童草丛柱子萃香挡路，上下左右躲避开这些障碍，用超高速飞行吧。不过加速之后自然地障碍之间的反应时间就非常短了。 No.14（外传总No.164）游戏名：こまフル 游戏类型：动作游戏 Produced by：礼門屋 故事背景是有个大魔王复活了，于是小町和咲夜出去联手打妖怪（反正没啥意思）。操作上也没什么好说的，不过在得到一些技能水晶之后可以放出一些特殊技来。路上在两人之间切换，小町主要近战拿镰刀砍，伤害比较高，而咲夜是飞刀远程，伤害低。最恶心的是血条和几乎没有一样，有些怪打起来不舒服会被碰到，虽然血条可以增加上限，不过被碰几下人还是GG。 No.15（外传总No.165）游戏名：弾けぬものなどあんまりない 游戏类型：动作游戏 Produced by： 一个妖梦为主角的动作游戏，不过手感不算很好（。如图，整体的艺术风格非常有特点（虽然我也说不出叫什么风格，就那种纯色简约和风吧），不过对（大概是白玉楼的？）庭院刻画还是有些奇怪了点。妖梦有冲刺斩和弹反两个技能，在血量消耗干净之前尽量打的远一点吧。 No.16（外传总No.166）游戏名：ソウルアンカー2 游戏类型：动作游戏 Produced by： ZWEi制作的几个动作游戏之一。游戏目标是限时之内到达终点，路上会有妖精挡路可以打掉，还有各种颜色的钩子可以用锚勾住，荡秋千似的荡过去一些地坑。不过按键可能比较难受，造成了时间不够用的情况，即使路上有一些时钟可以增加时间。 No.17（外传总No.167）游戏名：マリサランド·レガシー 游戏类型：动作游戏 Produced by： 这游戏KK已经直播玩过很多次了，我也不做过多介绍。主系统是仿照马里奥来的，吃星星和打怪、顶砖块都会加蓝点，300蓝点奖一条命。还有收集彩色星星，每关收集全也可以奖命。有小蘑菇，最多吃到4头身（最小2头身，但是也只一次可碰怪的机会），还有长蘑菇，在4头身基础上会进无敌模式一段时间，3头身吃长蘑菇会增加射击能力，2头身吃长蘑菇到4头身。手感略微差了点，容易跳不起来，路上多注意一下吧。（好像又写多了） No.18（外传总No.168）游戏名：チルダッシュ 游戏类型：动作游戏 Produced by： 一个⑨为主角的跑酷游戏，只有左右控制和跳，吃到路上水果和钻石增加分数，敌人通过踩头来消灭，当然也有boss战，也是踩头来打（踩5次）。自己有五格血，在左上角头下方用冰晶显示，正面撞到障碍物或者撞上敌人都会掉一格血。游戏整体有点难度，障碍物布置很不舒服，不过可以选择多点残机多挑战几次。 No.19（外传总No.169）游戏名：桜花蒐集録 游戏类型：动作游戏 Produced by：絶望リンカエラー 压榨“童工”了，uuz懒得收集春度托给了紫妹，紫妹托给蓝妈，蓝妈又托给了橙喵（我猜的）。不过确实这次是橙来收集春度，整个游戏算是平台跳跃，跳各个位置的台子来收集樱花。难得的是，这游戏的橙是3D建模，不过相应的，社团好像忘了注意一下手感，比较糟。有反墙跳，不过是反的屏幕边缘。这种设定使得游戏手感变得怪怪的。 No.20（外传总No.170）游戏名：うどりん 游戏类型：动作游戏 Produced by： 悠遊亭做的一个动作游戏（其实他家做的概念性上仿经典fc游戏挺多的），本作是仿照洛克人来做的，主角铃仙阿燐二选一。当然像洛克人一样有克制链，不过没什么规律。有滑铲，没有蓄力，而是以角色本身带一个能量槽，用连续按键来代替蓄力炮。不过整体而言有些难度，因为手感没那么好，而且有些怪和路的设置比较阴间，不过刺不是即死的，也算是一种缓和。神奇的是有双人模式，估计是可以同屏双打？不过我没找到2p怎么操作…… 经过了这么长时间，终于把下一篇发出来了。因为个人时间比较紧张，只有周末才能玩一下，直接就来测游戏然后写专栏了。因为想着从这一期开始，最好是把游戏分分类来展示，所以分成了几篇交替着写，就更慢了……希望下一篇能早点出来吧。 pid=86603664 volantis.js(\"https://unpkg.com/pandown\").then(pandown)","categories":[{"name":"游戏","slug":"游戏","permalink":"https://neko-horikawaraiko.github.io/categories/%E6%B8%B8%E6%88%8F/"}],"tags":[{"name":"带你玩东方","slug":"带你玩东方","permalink":"https://neko-horikawaraiko.github.io/tags/%E5%B8%A6%E4%BD%A0%E7%8E%A9%E4%B8%9C%E6%96%B9/"}]},{"title":"【鼓哥】带你玩东方-外传（十一）（小游戏篇）","slug":"【鼓哥】带你玩东方-外传（十一）（小游戏篇）","date":"2020-09-03T17:09:41.000Z","updated":"2024-11-04T16:23:47.883Z","comments":true,"path":"2020/09/04/【鼓哥】带你玩东方-外传（十一）（小游戏篇）/","link":"","permalink":"https://neko-horikawaraiko.github.io/2020/09/04/%E3%80%90%E9%BC%93%E5%93%A5%E3%80%91%E5%B8%A6%E4%BD%A0%E7%8E%A9%E4%B8%9C%E6%96%B9-%E5%A4%96%E4%BC%A0%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%EF%BC%88%E5%B0%8F%E6%B8%B8%E6%88%8F%E7%AF%87%EF%BC%89/","excerpt":"","text":"大家好，这里是猫耳堀川雷鼓~ 因为最近“键盘封印”啥的，也没法推进什么游戏进度/填坑，所以就来写专栏介绍小游戏啦（这不自爆了本来懒得写吗？）。其实这几天看过我直播的有所了解，写一个游戏小介绍其实还是挺麻烦的，解压安装游玩录屏截图写评，好玩的游戏还好说，不好玩的游戏真是折磨。而且还有几个怎么也打不开的游戏，只能找虚拟机跑跑了。 No.1（外传总No.131）游戏名：⑨式 游戏类型：角色扮演游戏 Produced by：ちびっこ娘々 森罗公司举办了一个地牢探险大会，我们的⑨应邀前往参加（年代记？）。地牢探险之前可以在香霖堂够用sp点买符卡，不同的符卡有不同的效果，比如近战、远程、防御、恢复等。进入地牢之后是格子型的探索，有些格子会发生不同的事件，比如遭遇据点、遭遇敌人、获得蓝点之类。战斗中消耗行动值使用指令组合打击敌人，打赢得到经验可以对自己能力进行升级。深入玩的话就需要对战斗策略、符卡搭配什么的进行稍微细致一点的研究了。 No.2（外传总No.132）游戏名：東方文々。新聞～新聞大賞への道～ 游戏类型：模拟游戏 Produced by： 为了夺得年度新闻大会优胜奖，文文从头开始了新闻修炼之旅。从实地取材开始，可能在行进点上出现特殊事件获得比较好的新闻素材，其他就是在路上随便拍一些花花草草，可能也会与意外收获。 每天有限体力，以及有限的行动回数，行进路消耗体力，采集素材或者事件交互会消耗一点行动回数，其中一个为零就要回家休息第二天再来采集素材了。与角色对话可以提升好感，到一定程度就可以作为助手雇用，帮助采编。 获得了素材之后就起稿报纸，卖出去可以获得收入以及提升评判点。事件和卖报纸也可提升经验值，获得能力点，提升取材起稿能力或者运气。总之是个虽然轻松但也要一些小策略才能获胜的游戏，推荐尝试游玩。 No.3（外传总No.133）游戏名：幻想キネ子伝 〜宇佐見菫子の弾幕実習 游戏类型：飞行射击游戏 Produced by： 特殊的stg，特殊在自机不能发弹幕，像是文花帖一样，但是也不能拍照。游戏目的是根据敌方发射的弹幕，恢复被打乱的空间。可以miss 5次，放b 5次，在这些资源消耗完之前将错乱空间尽快地恢复原样，每miss一次+30s，每放b一次+15s，根据时间排名。按键还是和stg一样，只不过z键吸附当前空间，再方向键就可移动空间。 No.4（外传总No.134）游戏名：東方探偵録 弐 游戏类型：文字冒险游戏 Produced by：みかん茶 想象一下逆转裁判的无汉化状态，大概就是本游戏了。不过这个游戏更偏重侦探推理。从故事（背景）开始，作为其中一个角色（不过有可能你前后扮演不同角色）参与事件，到事件发生实地调查、嫌疑人讯问，分析得出真正犯人。谜题设计还可以，不过语言是最大难题。 No.5（外传总No.135）游戏名：東方暴れん坊天狗 游戏类型：飞行射击游戏 Produced by：N2De - Garena 这是一个flash的横版stg游戏，不过已经暴毙了。相比起来，这个游戏弹幕量很大，以至于经常掉帧。不过敌方弹幕存在一定时间会消失，可以利用这一点来跟小怪或者boss拉开距离打伤害。主角文文，因为体验版缘故敌人都是圆球，boss是主角三人组，然而第四关也是早苗因为没新立绘所以让早苗上了。自机可以左右射击，射击自动低速，还可以按A使用自动瞄准模式，不过范围就不是太大了。 No.6（外传总No.136）游戏名：すい～と・くらんぶる（Suite Crumble） 游戏类型：音乐游戏 Produced by： 推荐使用PS手柄游玩…… 很传统的音游，下落“音符”对应四个按键，照着按就可以了（。相比现代音游来说还是系统简单了点。音乐自然也都是东方同人曲。 No.7（外传总No.137）游戏名：小傘のこんにゃく大作戦 游戏类型：飞行射击游戏 Produced by： 这游戏看起来是stg，但是完全不能射（击）。自机青蛙子，实际上是闲的没事去找小伞避弹玩了（那也不能和平模式不射击啊？），一共6个难度，每个难度有几关，撑到倒计时为0算过关，然后就会有那种立绘。其实眼尖的话在第一张图会看见CG Viewer选项，获得的立绘就可以在那里欣赏啦，在那里大概就能射了（火车开动）。 No.8（外传总No.138）游戏名：群弾 游戏类型：策略射击游戏 Produced by： 游戏名“群弹”，突出了一个“群”字，你要控制的是一“群”人去攻击（虽然最多显示10个人）。左上角显示的1000兵力，就相当于你的一千滴血的血条，每次受到攻击或者体术就会掉兵力，显示在游戏里就是场上人数减少（大约1:100比例划分）。在没受到攻击时会慢慢回复兵力。游戏基础兵力是幽灵，打过每一关boss之后会把boss纳入麾下，角色们各有各的能力，对阵型、火力、移速等有影响。还有一点就是阵型排布，示意图在画面上方，就是方形、行星型、长条形，游戏中可以随意切换来减少伤亡增加输出。 No.9（外传总No.139）游戏名：レイムノゲェム 游戏类型：动作游戏 Produced by：ねこもなか 还是那个社团的作品，还是那种类iwanna的游戏，还是那种不太舒服的手感，还是不想多介绍（ 他家这类游戏总共有レイムノゲェム、チルノノゲェム、サクヤノゲエム以及相应はぁどもぉど（hard mode）共六个游戏，就不再写了，之前两期都各介绍过一个了 另外，steam上的Death Cave就是这个是社团进军steam的游戏，就换了个人物，机制不变，估计手感也不变（ No.10（外传总No.140）游戏名：東方吸闘紀 游戏类型：动作游戏 Produced by： 暴毙了的游戏+1 一看画面其实就知道也是一个仿星之卡比的游戏，这次的主角是姆q。姆q用魔法书来吃掉敌人，也去使用魔法书托着飞行。总的来说关卡简单了点，可能是作为操作手感相对不好的补偿。（注意：游戏运行文件夹要全英文） No.11（外传总No.141）游戏名：ころころれいむ ちゅー / ころころれいむ 游戏类型：动作游戏 Produced by： 一个灵梦可以“变身”的策略游戏，灵梦可以变身成阴阳玉去撞敌人，撞到敌人（小怪）就能消灭。普通状态下可以移动，在上升气流中漂浮，也可以在弹床上弹起来，但是碰到敌人会掉一滴血，吃阴阳玉可以回血。变身成阴阳玉只能以极慢速移动，不可跳跃，在上升气流和弹床上会掉下去，不过自身无敌，而且可以顺着斜坡滚下去，以及撞碎特殊砖块之类。关卡里有一些角色的小收集品，每关三个。打完还有boss战，需要用阴阳玉形态来打。如果不收集而纯过关的话并不难，加上收集品的话就需要些考虑以及操作了，免得在阴阳玉飞行途中解除变身而掉下悬崖来之类的。 而且标题写的ちゅー和大大的2字表明还有一个作品1代，就叫ころころれいむ，如下图，游戏进行方式基本一致。 No.12（外传总No.142）游戏名：霧雨陰陽伝 The Brawl Between Life and Death 游戏类型：飞行射击游戏 Produced by：Mark Li 如果这游戏做的量再大一点，或许可以好好介绍一番。 这是一个（大概角色都是手绘的，而且是动态的）stg游戏，作为touhou fangame jam3的参赛作品提交。与正作相比，首先这是个横版射击，其次操作有了一些变化，因为你不仅可以往前方射击，实际上是可以八方向射击。boss只有小町一个，就是魔理沙去找小町干了一架。难度上比较简单，但是作为72小时的成品质量已经挺高了。 No.13（外传总No.143）游戏名：ゆっくりボウルDX 游戏类型：动作游戏 Produced by：agrippa 一个类似那个一起来打高尔夫的击球游戏。说是“击球”因为这个更像是打台球，不过台面是异形的，规则也有些区别。就像途中有多个小怪（幽灵、妖精之类），需要打台球一样打出去撞这些小怪，剩下的最后一个小怪所在位置就会变成终点球洞。因为有些小怪是漂浮在空中的，需要打跳球才能打到，不过大部分时候剩下那个飘着的当球洞就好了。上下键控制打普通球还是跳球，打的时候控制力度。中间shot统计本关球洞几杆进洞，右侧酒是限制，四个酒杯垫表示四杆之内没进洞就会消耗下方的一条命，当然台面上也有道具恢复酒杯的量。打到一些特定敌人会获得符卡，就是变形的阴阳玉那个位置显示，击球出去之后释放符卡会获得一些特殊加成，比如蕾米的符卡就是用冈格尼尔砸扁灵梦球，比如在洞上了但是要超过去的时候用这个就可以定住球而进洞。游戏挺有意思的而且不难。 No.14（外传总No.144）游戏名：雛ちゃんのリポート万歳 游戏类型：文字冒险游戏 Produced by：mizusoba（いすぃ） 和上一篇专栏（No.8）介绍的一样，这个也是一个填文字的游戏。这次的情景是转转和荷取一起做电视报道，在特定情景需要说什么话，让你填上2或3个文字（当然是日语）。根据回答判定合适度，以及整个报道观赏度会收到来自观众的投币，目标自然是越多越好。所以不会日语还是玩不下去（ No.15（外传总No.145）游戏名：雛ちゃんSOS 游戏类型：文字冒险游戏 Produced by：mizusoba（いすぃ） 这个就是转转在森林里迷路了，需要你通过这个通信器指示转转慢慢走出来，规则和上面的一样，也是回答三个字之内。 No.16（外传总No.146）游戏名：東方月下祭 游戏类型：动作游戏 Produced by：無邪氣工房 和No.114相近的套路，不过这个游戏更自由一些，自机选择多，而且在已划线范围内可以自由移动，其他特性基本一样。 No.17（外传总No.147）游戏名：私のお嬢様 游戏类型：视觉小说 Produced by：いろは 画风挺可爱的一个avg，主要就是咲夜和蕾咪的一个个小故事，你是咲夜，需要陪着蕾咪玩，就像养个小孩子似的…… No.18（外传总No.148）游戏名：Touhou mix 游戏类型：音乐游戏 Produced by：kailang 国人做的东方专属音乐游戏，风格仿照voez的感觉，在windows、安卓、ios都已经上架。乐谱采用東方ピアノEasyモード网站上的曲谱，并按照出处做好了分类。估计喜欢音游的人肯定都听说过这个游戏了，游戏现在主要在官方q群讨论，欢迎各位加群1020610194了解（但是真的不是五毛一条）。 No.19（外传总No.149）游戏名：東方大作戦 游戏类型：动作游戏 Produced by： 爽游+1 大批的咲夜突然就袭击过来（这什么吊毛游戏背景），灵梦要阻挡她们，不让她们到达下方danger区域。阻挡（攻击）方式就是体术或者射击，攻击达到一定次数可以把咲夜踢飞，相比起来体术方式要快得多。随着剩余人数减少，咲夜受击次数会增加，而且会出现同时一大批咲夜涌过来的情况。但是不要怕，偶尔画面上会飞过来辅助人物，文文可以消除全屏的咲夜，魔理沙增加自身速度。偶尔画面会下来一只大小姐，飞得慢但是血量很厚，差不多是刷连击送分的（打飞也算一个咲夜（草）），但也比较挡路。 No.20（外传总No.150）游戏名：アリスブレイカー 游戏类型：动作游戏 Produced by： 魔理沙又偷走了重要的东西（人偶），爱丽丝急着赶回家去（老夫老妻开始打情骂俏了？）。结构很简单的游戏，按↑骑着稻草人（？）跳过沟，注意跳跃后power没了就会掉下去，目标就是跳过所有沟安全到终点。一共8关，流程很短，而且可以背板。 pid=34844544 volantis.js(\"https://unpkg.com/pandown\").then(pandown)","categories":[{"name":"游戏","slug":"游戏","permalink":"https://neko-horikawaraiko.github.io/categories/%E6%B8%B8%E6%88%8F/"}],"tags":[{"name":"带你玩东方","slug":"带你玩东方","permalink":"https://neko-horikawaraiko.github.io/tags/%E5%B8%A6%E4%BD%A0%E7%8E%A9%E4%B8%9C%E6%96%B9/"}]},{"title":"【鼓哥】带你玩东方-外传（十）（小游戏篇）","slug":"【鼓哥】带你玩东方-外传（十）（小游戏篇）","date":"2020-08-04T17:08:54.000Z","updated":"2024-11-04T16:22:39.613Z","comments":true,"path":"2020/08/05/【鼓哥】带你玩东方-外传（十）（小游戏篇）/","link":"","permalink":"https://neko-horikawaraiko.github.io/2020/08/05/%E3%80%90%E9%BC%93%E5%93%A5%E3%80%91%E5%B8%A6%E4%BD%A0%E7%8E%A9%E4%B8%9C%E6%96%B9-%E5%A4%96%E4%BC%A0%EF%BC%88%E5%8D%81%EF%BC%89%EF%BC%88%E5%B0%8F%E6%B8%B8%E6%88%8F%E7%AF%87%EF%BC%89/","excerpt":"","text":"大家好，这里是猫耳堀川雷鼓~ 这篇文章……不会再咕一年了吧…… 最近写专栏有一部分游戏会直播玩的，想看游戏具体玩起来什么样子可以到直播间一窥（ No.1（外传总No.111）游戏名：東方白色伝 游戏类型：视觉小说 Produced by：蒼木 跟上一篇里最后一个（总No.110）游戏同样的制作人做的游戏，这个故事换成了一个现界人幻想入的事情。（不过这种只有文字的小说还是兴趣不大啊） No.2（外传总No.112）游戏名：たとえどんな切ない恋をしたって 游戏类型：视觉小说 Produced by：うなだれ 恩……和幽香谈恋爱，想想就刺激（。而且这游戏作者相当自恋，游戏开头会让你输一个名字，不管怎么输都会最终成为“うなだれ”，不管怎么推gal都是相当于作者在推（真有你的啊）。这幽香比我们印象的要软一些（ No.3（外传总No.113）游戏名：mawaru marisa 游戏类型：动作游戏 Produced by：Cachi Córdova 鼠标按着魔理沙开始转，松开就会向当前方向发射出去，躲避子弹（或者擦弹），撞向妖精。这游戏玩法怎么看怎么着也散发着一股怪味，就像是魔理沙把尻击改练头槌了。随着分数（打掉妖精数？）增长会逐渐增加难度，子弹增多，说实话本来也就很难控制，魔理沙撞到画面边上反弹，一头就扎子弹上了。 No.4（外传总No.114）游戏名：東方蛇封陣 游戏类型：动作游戏 Produced by：RECOIL 基本就是《Qix》的玩法，大概也是一类游戏？操纵角色在途中范围内划线，绿色线是可以行走的位置（只能沿着绿色线走），然后从绿线某位置开始划线，被框住的部分就是自己已经占领的区域。占领区域超过一定百分比（80%）就可以过关。不过划线的时候会有子弹和妖精/boss的干扰，被打到就miss，不过没划线的时候没有判定。划线把妖精框住就能消灭妖精，框住那个阴阳玉可以变p点增加行动速度。自己的行动只有划线以及躲子弹，其他啥都不能做），而且如果死了会掉speed，后面的关就难打了。 No.5（外传总No.115）游戏名：レイセンの悪夢 游戏类型：动作游戏 Produced by：カナ江 booth上在做（然而有一年半没更新了）的一个游戏，你是铃仙二号，月面战争结束后你本来可以安稳睡觉，但是你就是做噩梦了，在梦里你拿起枪来干翻敌人（年糕），打败敌人会留下一小团年糕，你需要把年糕臼给填满。不过确实也对得起噩梦这个名字，游戏难度因为敌人数量多而变得像噩梦一样。 No.6（外传总No.116）游戏名：ヘカッティアブロックバベル 游戏类型：动作游戏 Produced by：青山有人 就像游戏名所展示的，这是个赫卡为主角的打砖块游戏。不过这个砖块呢，似乎是⑨和大妖精等几个人，挡板也不是正常在画面正下只有一个，而是三个，就像图中一样分布在圆盘三个方向。弹球的个数是无限的，随着时间会慢慢恢复一个，发出去的球可以通过这三方向的赫卡挡板接住反弹，当然也可以不接，只看自己控制的这一个就好。对方是发弹幕来打你，自己控制的机体可以跳跃躲避（其他方位不受击）。自己和对方都有被击数上限，就看自机或者对方身上的方框护盾，没有了就是最后一条命了（每次被打之后护盾会有颜色变化但是不太好记），每过一关会加满护盾，就是上图中的红心。随着过关，难度上升的挺快的，而且是3D不太好打。 No.7（外传总No.117）游戏名：YUKARI’S CREVICE 游戏类型：动作游戏 Produced by：みすたぁさいど☆ふぇいす 稍微带点操作的解谜游戏。异变发生，紫妹变成油库里了，然后用油库里身材去解谜的事。紫妹可以行走跳跃，还可以扔蓝妈出去打怪，不过毕竟有些地方比较高，可以从扔一对隙间贴到墙上或地上，从一侧进入可以从另一侧出来，不过砖块样子的墙就没法把隙间贴上去了。还有更高的地方可以踩着比如红色的飞行妖精上，然后被驮着飞到高处，甚至可以开隙间把这些妖精也送到需要的位置多次利用。蓝色妖精这一类的就是敌人，扔弹幕被打会扣血。不过毕竟穿墙这事，总会有bug，比如隙间扔的位置不好会被判定扔在墙缝里，然后红妖精一传送过来就被卡跑了，再也找不到了（。 No.8（外传总No.118）游戏名：もてなせ！にとりちゃん 游戏类型：文字冒险游戏 Produced by：mizusoba（いすぃ） 萃香要来找荷取玩了，你该怎么应对她呢.jpg。-游戏主线可以看做一个avg，但是需要比较强的日语水平/常识。荷取遇到问题时“心中所想”会是三个假名，你要根据上下文以及问题找到这三个字是什么并填上去。（我不太确定会不会有多个答案合适，毕竟我日语水平不高）所以玩这游戏大概需要一个会日语的朋友一起玩） No.9（外传总No.119）游戏名：동방 브레이크（東方Break） 游戏类型：动作游戏 Produced by：pictorial 横向的打砖块游戏，不是对战。自机灵梦打出的是符札，所以轨迹稍微有些奇怪。目标是把场上的砖块全打完，boss不用管，是给你加障碍的。如果玩到后面的关卡的话，背景图会有变化哦。 No.10（外传总No.120）游戏名：なげるーみあ！ 游戏类型：动作游戏 Produced by：土佐 这游戏有点策略+动作的感觉吧，是露米娅去用箱子/石头等东西去砸这些妖精，全打败就可以去吃那个肉过关了。露米娅可以举箱子、沿地面扔箱子、踢箱子，最奇葩的是可以坐上扔出去的箱子在空中飞。这些妖精也可以踢箱子，露米娅被箱子石头撞到也是会损血。 目前（2024.5.24）游戏也准备上steam了，可以也来看一看 No.11（外传总No.121）游戏名：Lost Donation Box Incident 游戏类型：飞行射击游戏 Produced by：Nihirash! 回去读了一遍游戏说明，这游戏其实是一个模拟器游戏，设计在ZX Spectrum运行，不过游戏作者提供了一个打包好的版本。灵梦丢了她的赛钱箱和阿吽（怎么能丢了人的），然后准备去找回来。主路线是沿着红魔乡的路线开打，但是没有露米娅（）。总体手感“还算可以”，但是没有低速和bomb系统，判定是整个身体，相对地敌人子弹也比较稀疏。打掉妖精会掉p点和心点，p点吃一个增长一阶段自机火力，但是也就直线射击增快、子弹加多而已；心点一个一条命，数量还是不少的。整体弹幕比较单调，后面还有无数体术杀，游戏体验极差（。 No.12（外传总No.122）游戏名：東方氷禄弾 游戏类型：飞行射击游戏 Produced by：LIMIT CYCLE 又一个暴毙的游戏（ 故事大概发生在星莲船后，天空上出现了五色彩云，⑨就想飞上去冻云彩做成刨冰吃（？）。事情就是这么无厘头。⑨自机周围有一个冰冻结界，结界碰到云彩就能把云冻成冰块，⑨发射子弹（空格）就能把冰块冻成刨冰，吃掉刨冰得分。冰块结成刨冰时候会有“爆炸”连锁（和大战争似的）。彩色云朵冻成刨冰吃掉会有不同的效果，比如改变子弹模式，扩大结界范围，结界内云冰全消除等。但是子弹恢复速度非常慢（30s一格），而且⑨撞到冰就game over（你不是冰妖精吗？）。游戏性比较不错，就是没有游戏说明比较蛋疼。 No.13（外传总No.123）游戏名：Fly Marisa Fly 游戏类型：飞行射击游戏 Produced by：2D Emotion 啥也没有说明的一个躲子弹(?)游戏，方向键移动，鼠标射击。画面不是很讨好，但是自身和子弹判定点很明显地标出来了。就是尽量不被打到，然后消灭路上的敌人（魔爱啊啊啊啊啊）。其实画面顶上的刺挺突兀的，但是知道这社团后来做过东方的i wanna之后就会觉得这刺挺亲切的（？） No.14（外传总No.124）游戏名：東方腐卵臭っぽいもの 游戏类型：动作游戏 Produced by： 一个很有趣但是有点小难度的游戏。芙兰浑身臭乎乎的在房子里乱跑，咲夜就要去打败路上敌人然后把芙兰扔澡盆里给洗一洗（静止水不怕咯？）。敌人很凶猛，除了发飞刀之外，咲夜可以借助美铃挡一下（挡箭牌），可以叫出蕾米火箭筒来一发冈格尼尔打人。操作手感还可以，但是按键设置很恶心（方向键、左shift、x）。 No.15（外传总No.125）游戏名：Super Marisa World 游戏类型：动作游戏 Produced by： 又一个东方X马里奥的游戏。说的是魔理沙为了姆q“打遍幻想乡”的故事（魔帕组欢喜）。魔理沙是接到了姆q的一封求救信，但是出门发现幻想乡被一种“马里奥魔法”（我自己造的）变了样。在路上像马里奥一样可以顶砖块、踩毛玉、进管道，跨过重重艰险。但是游戏手感……确实拉胯。物理引擎做过头了，走起来不容易刹车。但是有些独特东方元素还是有新意，比如魔理沙拿到扫帚就可以坐上飞（可以参考马里奥里面的羽毛道具）。 No.16（外传总No.126）游戏名：东方梦月抄 游戏类型：飞行射击游戏 Produced by：（未知） 一个普通又不普通的stg。普通是遵循了东方传统stg的感觉，故事大概和儚月抄有点关联（我没读过），不普通是没有难度选择，自机可以在四人中切换，因此放的雷也会不一样。 No.17（外传总No.127）游戏名：ボン・メイリン（BOMB MEIRIN） 游戏类型：动作游戏 Produced by： 炸弹人的模子，但是玩起来就感觉不舒服。放炸弹的时候会向背后退一格，所以有时候连着放炸弹就把自己堵在里面了。除了炸弹倒是可以用普通子弹来打怪，直线方向比较短的距离。一般怪会掉一个炸弹道具出来，捡了能放炸弹，炸弹不是横竖四方向而是圆形爆炸范围。道具的话炸这些树会掉，也有地牢可以进去捡，不过地牢里完全没有光，最好是在外面打道具掉一个蜡烛再进去，可以照亮周围半径两格。能量是血条/时间条这类设定，随时间会减少，被怪碰到也减少，减少到0掉命，可以用道具补充。不过被自己炸弹炸到就直接掉命了。 No.18（外传总No.128）游戏名：Touhou Bounce Bounce Ball 游戏类型：动作游戏 Produced by：EiZi 操作有点特殊的打砖块游戏，只有主题是搞了点车万风格。这个弹球的话真有点现实生活的跳跳球感觉——即重力摩擦力效果，弹板就像是硬地面。所以需要按空格在弹板蓄力，在弹球到板前的一小段里松开蓄力给球加个力“吹”上去。另外弹板通过鼠标控制，跟鼠标左右走，但是还能根据按住左键右键来左旋右旋弹板。其他没啥说的，图上都写了。其他不用说，Bomb的话是原地一个爆炸效果，右边power条蓄满了蓄力弹出去有个一次的穿透效果。 No.19（外传总No.129）游戏名：東方秋神録 ～ Every day of Autumn 游戏类型：飞行射击游戏 Produced by：黒幕機関 仿风神录的一个stg。不过也只有体验版（也只有一关）了，社团官网早就看不了了（ plus.3（外传总No.130）游戏名：漫步在幻想乡 游戏类型：pv Produced by： 用RPGmaker做的非正常pv），原曲就是相关专辑《東方ノ森~Sonata tra le foglie》的《漫步在幻想乡》这首歌。这个“游戏”就是用幽香视角漫步幻想乡所见。一边听歌一边看一看梗也是不错的） pid=64319523 volantis.js(\"https://unpkg.com/pandown\").then(pandown)","categories":[{"name":"游戏","slug":"游戏","permalink":"https://neko-horikawaraiko.github.io/categories/%E6%B8%B8%E6%88%8F/"}],"tags":[{"name":"带你玩东方","slug":"带你玩东方","permalink":"https://neko-horikawaraiko.github.io/tags/%E5%B8%A6%E4%BD%A0%E7%8E%A9%E4%B8%9C%E6%96%B9/"}]},{"title":"【鼓哥】带你玩东方-外传（⑨）（小游戏篇）","slug":"【鼓哥】带你玩东方-外传（⑨）（小游戏篇）","date":"2020-07-05T16:50:12.000Z","updated":"2024-11-04T16:21:06.819Z","comments":true,"path":"2020/07/06/【鼓哥】带你玩东方-外传（⑨）（小游戏篇）/","link":"","permalink":"https://neko-horikawaraiko.github.io/2020/07/06/%E3%80%90%E9%BC%93%E5%93%A5%E3%80%91%E5%B8%A6%E4%BD%A0%E7%8E%A9%E4%B8%9C%E6%96%B9-%E5%A4%96%E4%BC%A0%EF%BC%88%E2%91%A8%EF%BC%89%EF%BC%88%E5%B0%8F%E6%B8%B8%E6%88%8F%E7%AF%87%EF%BC%89/","excerpt":"","text":"大家好，这里是猫耳堀川雷鼓~ 不得不说，越临近开学越没什么干劲了，所有的坑一概不想填，心里乱糟糟的。想找人面基，又不知道该说什么。想就那样面对面坐着，虽不说话，但不尴尬。 以上是去年写的东西，所以说这一篇实际上已经鸽了近一年了（ No.1（外传总No.91）游戏名：The Shrine Maiden’s Subterrestrial Excursion 游戏类型：动作游戏 Produced by：White Pikmin 回去看的时候，这个游戏已经被作者撤掉了） 一个demo版本的stg+rougelike类游戏，鼠标控制射击与放b，所以精准度还是要比较好操控的。继承了rougelike的随机地图，每一层有一个小怪会掉钥匙，捡到后就能进下一层，一共10层，最后一层打露米娅。 当然可以通过绕圈或者躲柱子后面来避免被打到，总的来说还算有点意思。 No.2（外传总No.92）游戏名：東方不要戦 ～ Fortuitous Strife in Arcane Land 游戏类型：飞行射击游戏 Produced by：Kousaku-P (NovaWare) 大概是个活动作品） 仿旧作风的一款stg demo，很短的一关，道中+道中boss+关底boss。不管什么方面都挺像旧作的，操作也是像旧作一样有点不舒服。有专门做的pc98风的曲子。 比旧作好的地方就是，有明显的判定点。但说到最后这毕竟是个活动作品，记分会比较乱） No.3（外传总No.93）游戏名：ようせいのおもちやばこ 游戏类型：解谜游戏 Produced by：ほわいとふれあ（46flare） 两个小游戏给整一块去的游戏。其中一个在之前文章介绍过（总No.84），莉莉白的打砖块游戏，这个是打砖块·改（虽然我也不知道改了什么，好像是只增加了内容）。 另一个就是像这样的拼图，4x4，5x5，6x6三种。不过我拼了一会好像有bug（？ No.4（外传总No.94）游戏名：うなきゃっちゃー 游戏类型：动作游戏 Produced by： 小碎骨抓八目鳗的小游戏，やるき（干劲）会不断往下掉，（身后魔法阵消失前）只要有连击（连续抓到八目鳗）会恢复，干劲没了游戏结束。 随着游戏时间变长干劲掉落速度越来越快，可以按空格键放“灵击”生生增加一个combo来续连击。 No.5（外传总No.95）游戏名：This Is The Only Stage 游戏类型：动作游戏 Produced by：skipp 一个算是iwanna风格的游戏吧。首先确实如题目所说，是唯一的关卡。 但是这一关被玩出花来了。比如自机周围黑，操作反向，重力反向等。模仿了一个挺老的似乎在外网挺出名的游戏This Is The Only Level。 看起来是比较资深的iwanna玩家做的，不过编程水平也确实有限，操作手感非常差，加速度似乎没设置上限，分辨率调整之后画面缺一块等（ No.6（外传总No.96）游戏名：上海爆撃団～ 東方巡回帰番外編 游戏类型：飞行射击游戏 Produced by：T-noin 看标题能看出一点名堂来，“番外編”说明有个本篇，名字叫“東方巡回帰 ～ A Little Rest.”，但是这游戏已经找不到了）。另一件事是“上海”，和上海人形有关。 所以这个游戏是个非常特殊的stg。主机爱丽丝，通过蓄力扔的方式把上海人形扔出去并爆炸来消灭妖精。就比如上面第一张图，自机周围的绿色圈表示力度，蓝色圈表示方向。扔出去以后根据力度，人形可能会在画面内反弹打掉妖精并消弹，然后爆炸。自机两残，doll表示可以扔多少人形，随时间恢复，最大为10。打掉妖精可以提升combo与分数，combo越大恢复doll越快。按分数奖残，level最大100，详细可以看游戏的readme。 No.7（外传总No.97）游戏名：COOYAN(くーやん) 游戏类型：射击游戏 Produced by： 看到COOYAN有没有一种熟悉的感觉。看下面这张图 所以嘛，玩法基本和fc这猪小弟游戏一模一样。只不过相比起来COOYAN弹幕要多一些，而且会有斜向射来的弹幕。 左上角是分数和剩余敌人数，每次miss之后敌人数不会回满，所以不用担心好几个残机打不过一关这类事情） No.8（外传总No.98）游戏名：ミョンムソー 游戏类型：动作游戏 Produced by： 其实这游戏挺好玩的，该做成视频（小声bb） 动作爽游，操控妖梦乱砍。从普通下劈到升龙斩、双圆月斩（呃，没了），妖梦用多种刀法尽量多的砍掉画面的妖精，妖精爆出来的灵雾可以回血。砍过几个场景后会面对boss，boss攻击都挺犀利的（如果你操控不熟练的话），砍着砍着你血条就没了。 No.9（外传总No.99）游戏名：Bun N’ Gun 游戏类型：射击游戏 Produced by：Gman8r, Pigu-A, Vivid Turtle 嘛，西部枪手类型的游戏。鼠标点击射击，AD可以左右移动躲一下子弹。其他的应该不用多说了吧，每个人都即使没玩过也见过，没见过上手也会玩那种。对面兔子的子弹还是很慢的，很好躲。 No.10（外传总No.100）游戏名：サクヤノゲエム 游戏类型：动作游戏 Produced by：ねこもなか 恩……之前一篇中提到过的游戏的前身）（第八期总No.88） 在不想说啥，对这类游戏没有耐心），反正就每次试探着路前进吧，有啥虚的路不会给提示，要背板）。 No.11（外传总No.101）游戏名：チルノのパーフェ外さんすう教 游戏类型：解谜游戏 Produced by：月のあくび 其实摆上图片就知道了这游戏是什么了。说白了就是锻炼瞬间反应与计数能力的。先给你走过去几只⑨，然后问你⑨有多少个。随着答对数量增加等级上升，给你数⑨的时间减少，⑨数量增加，大概到最后就是拼一个模糊印象对不对了。 No.12（外传总No.102）游戏名：妖精とこころの迷宮 游戏类型：角色扮演游戏 Produced by：ほわいとふれあ（46flare） 不可思议幻想乡那一类的随机地牢游戏，就是主角改成了莉莉白和秦心，在开始的博丽神社那里可以换人。 No.13（外传总No.103）游戏名：Citadel of Celestial Cascades 游戏类型：动作游戏 Produced by：nadomodan 我觉着这才算真正的“雨夜暴徒”（x 天空飘来一个城堡，然后幻想乡下起了雨，因为怕幻想乡被淹没所以妖梦开始了调查。（这雨淹幻想乡的剧本怎么这么多人写啊）控制妖梦在平台奔走击杀幽灵进而通关，妖梦可以射击，也可以平砍，击杀敌人时会临时获得一次二段跳，遇到远距离平台可以反墙跳，击杀全部幽灵之后，目标是进入像图上左下角那个绿色圆点处。游戏完成度挺高，操作手感也不错，就是键位不太舒服。 No.14（外传总No.104）游戏名：東方異迷宮 不思議な程度のダンジョン 游戏类型：角色扮演游戏 Produced by：agrippa 玩过不思幻的玩家应该都熟悉的一种游戏类型，可能叫随机地牢？ 就是很传统的捡道具、杀敌、升级、维持饱腹度、探索迷宫这一类的操作，在当时（2009年）应该也算完成度不错的游戏了，不过似乎查看不了物品说明？还是我日语不好没找着…… No.15（外传总No.105）游戏名：さとり様は大変な弾幕を想起させていきました 游戏类型：飞行射击游戏 Produced by：ごもく 根据文花帖lv9所做的fc风游戏，规则和文花帖一样。但是这屏幕分辨率受不了（400*300），而且文文高速感觉比原版要滑的多。打这游戏，也许就图一乐吧（ 打不过就被小五嘲笑吧 No.16（外传总No.106）游戏名：Garden of Doll 游戏类型：解谜游戏 Produced by：Asterids 为了让你知道什么键有用，特意在旁边给你写上的游戏是鉴）。其实这游戏一看内容就知道是什么类型的游戏了。通过各种箱子压按钮啊之类的打开或者关闭相应砖块，来找到通往下一关卡的门的通路。主角呢是罕见的转转），但是主角换成谁都一样（小声bb） No.17（外传总No.107）游戏名：東方ロマンシングトレード 游戏类型：策略游戏 Produced by：ZNP 浪漫沙加3里面的trade小游戏复刻。大概就是比谁手速快，利用蓝点（钱）和对方对标，下注蓝点比对方越多就越快压倒对方，然后中标就能买下中间的“店铺”。下注是通过发射弹幕与打到对方来反映，发射/打到对方弹幕越多相当于你下注越多。 No.18（外传总No.108）游戏名：夜雀チャーム弾 游戏类型：飞行射击游戏 Produced by：耳小屋 这是个挺有意思的射击游戏。 虽然主角是米斯琪但是她不会放弹幕啊。夜雀只能通过叫声“ちん”来魅惑没有蓝色魔法阵的敌人，让魅惑到的敌人（标注红色魔法阵）发弹幕来打击敌人（说白了就是魅惑菇）。鸟目弹就是一个小型消弹bomb。穿过挺长的道中会遇到关底boss，打完进下一关。 No.19（外传总No.109）游戏名：B.Q.WARSバカルテットウォーズ 游戏类型：动作游戏 Produced by： （既然拆出来了那就先说一下吧） 这个游戏是著名东方flash动画游戏社团迷走ポタージュ在例大祭7上发布的東方咲待夢中的一款游戏。看着画面就知道又是笨蛋四人组的捣蛋事了。游戏机制大概与QQ堂的推箱子模式一样，把图上的圆球推出去砸人，砸到血条没了就临时out，时间内out数最少的人胜利。普通球撞到人或者撞墙消失，还有一些特殊球出现，比如图上阴阳玉就会按照顺时针（大概）反弹几次才消失。作为休闲游戏真的挺不错。 No.20（外传总No.110）游戏名：東方短編集 游戏类型：视觉小说 Produced by：蒼木 个人制作的视觉小说类型游戏。目前（但是也没后续了）只有一个游戏，美しき紅い月の咲く夜，从多人视角看魔理沙强闯红魔馆之后的事情（，日语苦手没法透露太多，想看的可以自己看一下 天知道为什么我咕这么久，可能是stg打上头了吧（ pid=82141238 volantis.js(\"https://unpkg.com/pandown\").then(pandown)","categories":[{"name":"游戏","slug":"游戏","permalink":"https://neko-horikawaraiko.github.io/categories/%E6%B8%B8%E6%88%8F/"}],"tags":[{"name":"带你玩东方","slug":"带你玩东方","permalink":"https://neko-horikawaraiko.github.io/tags/%E5%B8%A6%E4%BD%A0%E7%8E%A9%E4%B8%9C%E6%96%B9/"}]},{"title":"【鼓哥】带你玩东方-外传（八）（小游戏篇）","slug":"【鼓哥】带你玩东方-外传（八）（小游戏篇）","date":"2019-08-20T15:50:40.000Z","updated":"2024-11-04T16:21:16.242Z","comments":true,"path":"2019/08/20/【鼓哥】带你玩东方-外传（八）（小游戏篇）/","link":"","permalink":"https://neko-horikawaraiko.github.io/2019/08/20/%E3%80%90%E9%BC%93%E5%93%A5%E3%80%91%E5%B8%A6%E4%BD%A0%E7%8E%A9%E4%B8%9C%E6%96%B9-%E5%A4%96%E4%BC%A0%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%88%E5%B0%8F%E6%B8%B8%E6%88%8F%E7%AF%87%EF%BC%89/","excerpt":"","text":"大家好，这里是猫耳堀川雷鼓~ 我来继续更新下一期啦~ 不过似乎肩膀疼并没有减轻多少啊……不知道对更新频率有多少影响（本来也是咕的多吧你）。本次想了想，放上20个游戏吧，要不文章太多了……_(:3」∠❀)_ No.1（外传总No.71）游戏名：ようむゲー 游戏类型：动作游戏 Produced by：アカ 妖梦练剑术的小游戏（x），你需要根据画面上出现的按键提示按下相应按键得分，不过嘛…… 按键是用日语给出的……日语苦手遭难了。其实给出的按键也没多少，共6个，うえ（↑）した（↓）ひだり（←）みぎ（→）L（Q）R（W），不过不认识日语的话反应挺难的。60s限时挑战高分，还有三个乱入的东西，饭团+3s时间，米斯蒂娅+3点分数，都是按对了才有这奖励；灵梦-5点时间，可以通过按错键避免。 No.2（外传总No.72）游戏名：ちるばいと！ 游戏类型：动作游戏 Produced by：惑星まりも 这游戏玩起来有点上头，让我先再玩一局再说…… 小恶魔把幻想乡众人糊成粘土人啦，琪露诺要把她们冻成冰块推下舞台去！按z扔出冰块来，砸到黏土人先现出原形，再砸一次冻成冰块，方向+z朝相应方向推出去。推出去挤到人会一并推到台下，一个人1分，不过如果这个人现出原形（或者冰块）的话被挤到的人会变为10分，推出去的这个冰块会按照人数以一定增长率增加分数，比比最终谁的分数高吧~ 整个游戏3分钟计时，期间会有小恶魔扔火球。左下角是符卡槽，随时间增长，还可以吃到特殊道具——糖果——攒满，满了放符卡（x键）将前方一排粘土人直接冻成冰块。 No.3（外传总No.73）游戏名：刹那の妖夢 游戏类型：动作游戏 Produced by：ZNP 这是个考反应力的游戏，就是那种给个信号比谁反应快的。说一个代表就知道了，pants争夺战…… 题外话，似乎这个红装妖梦（官方设定是半灵）还挺可爱的？ No.4（外传总No.74）游戏名：Touhou fantastical pursuit 游戏类型：动作游戏 Produced by：White Pikmin, J’ Camilo, chainedTan 小町在⑨做的饼干里悄悄下了毒，准备收割灵魂了。可怜的主角二人组吃了饼干，为了躲避死神追杀前往永琳那寻求解药。 可操作角色就是主角二人，灵梦跳得高，魔理沙跑得快。一共会跑五个场景，想知道是啥，来玩一下啊~ 小町会一直在后面追你，路上还有坑，被追上就是一刀game over，掉下坑去也是g o。不过小町追的不是很紧，发挥得好的话能有那么四五秒供你调整的时间。玩腻了其他游戏，作为休闲减（zeng）压来玩还是不错的（ No.5（外传总No.75）游戏名：懐式倣緋萃 ～ NEARLY EASTERN STORY 游戏类型：格斗游戏 Produced by： 这个……猜一猜……也能猜到……是fc风的画质吧…… 没错，确实是fc风。给你的是nes文件，需要模拟器运行。当然这个游戏也有卡带卖。 在pc游戏、新世代主机游戏已经成为常态的现在，有那么一个社团做了那么一个fc上的格斗游戏，音乐也是8bit复刻。游戏质量算不上上乘，但是确实给人怀旧感。游戏有一定的打击感，可以放符卡，还有回旋踢。只不过肯定比不上现在的格斗游戏，立回啥的都没有，只是相比起来，比那个叫《功夫》的游戏质量好得多。 No.6（外传总No.76）游戏名：符遊置楽宴 游戏类型：策略游戏 Produced by：、とし（無限旋律） 这是一款十多年前发售的卡牌游戏……的pc复刻版本，原作者邀请一位程序员做了这个游戏复刻。 手中卡牌上数字表明了卡牌的攻击力/防御力，颜色是不同的属性、功能。每回合可以进行人物走动、卡牌走动、符卡发动等操作，目标是把对方打倒。每个人物仅有1血，要通过合理布置弹幕，打到敌人没还手之力。弹幕攻击卡片分为“光”“丸”“尖”，有不同的排布规则，也可以消耗相应数量卡片使用符卡攻击等。弹幕打到脸上时需要用“避”卡，打出比对方弹幕攻击高的数值才能免伤。具体的游戏玩法各位可以自行尝试。这游戏还有可能联机哦，不过我没找到好友尝试。 No.7（外传总No.77）游戏名：Youmu is a Zombie! 游戏类型：解谜游戏 Produced by：CookieGames 故事说，妖梦冬天感冒了，打喷嚏很厉害，然后死了（？？？）。幸好魂魄给包在一个泡泡里，现在你是半灵，要帮妖梦拿回她的魂魄。 这啥沙雕故事啊…… 你作为半灵，可以穿过一些比如图上木栅栏似的地方，也能在刺上行进。不过也因为是半灵，推不动箱子，但是能推动那个魂魄泡泡。你可以附身在成为“僵尸”的妖梦身上，来推动一些箱子，也可以有些其他用途，就是后面几关的要求了。游戏玩法还不错，就是……音乐和操作确实不怎么样…… No.8（外传总No.78）游戏名：かえるなんてこおらせてやるわ！！ 游戏类型：动作游戏 Produced by：α-storage 我什么也不说，这是坠吼的。 No.9（外传总No.79）游戏名：Recollection! Fantasy 游戏类型：动作游戏 Produced by： 恩……一款小⑤为主角的横版过关仿星之卡比游戏，没太多好说的…… 音乐还算可以，手感很糟糕，惯性非常大。后面有地方要用比较高的精度但是你就是操作不出来的感觉。画风……看得出来吧，很生硬…… No.10（外传总No.80）游戏名：なずゲーム、なずルーイン 游戏类型：解谜游戏 Produced by：牛乳屋 嘛……这个游戏才是真的休闲游戏。这两个游戏同种类型，算是1代2代吧，就只介绍二代なずルーイン。 你要做的就是选择一个角色，然后打败她们，然后收入后宫（x）。在这个棋盘上这些格子中，有些带有金子，有些是地雷，还有一些可能的随机选项。在几个回合中，要挖到最多的金子，保证不要被地雷炸死，然后排一排所有人的金矿数，最多的就是第一名，然后就可以把打败的人选（shou）择（ru）使（hou）用（gong）。这游戏完全就是看脸游戏，所以……来验一下血统吗？ No.11（外传总No.81）游戏名：東方降神曲 游戏类型：格斗游戏 Produced by： 根据作者，这游戏是仿照fc游戏“热血进行曲”做的。不过作者早就已经停止这个游戏更新了，坑掉了…… 方向键移动，z手打，x脚踢，这就是基本按键了。你可以选择一队人出战，但是每场还是只能上一个人。这就是四人大乱斗那种模式。因为说是模仿fc那游戏，所以打击感啊画风啊音乐啊都是那种fc的感觉，只不过加上了东方元素，换成了东方人物。然后画面上是谁就只能通过帽子来认了（ No.12（外传总No.82）游戏名：だてんこ 游戏类型：动作游戏 Produced by：α-storage 真正的休闲游戏x2。 你是紫……妹（！），要在屏幕上赶掉捣乱的天子，让橙回隙间，让蓝妈在外面瞎逛（？）。左键点击攻击，目标天子，不让他们捣乱；右键点击释放隙间，让橙进入；对蓝妈……啥也不管，从屏幕中放走。你看看这就是区别对待啊！最高关数不知道，我最高玩到83关45w分，有没有人来挑战一下啊~ No.13（外传总No.83）游戏名：東方紅翔我 游戏类型：动作游戏 Produced by： 封面欺诈（ 标题灵梦挺漂亮的，但是游戏的3d建模实在是……考虑到人家也是09年的游戏，就算了吧。 如图，这是个3d场景的act游戏，主角灵梦魔理沙，然后跑到红魔馆……偷书来了？z跳跃x击打c符札射击v符卡，可以二段跳。音乐还不错，打击手感比较僵硬，而且前后摇都很高。挺普通的一游戏，不过放在09年还是挺不错的。 No.14（外传总No.84）游戏名：りりーのぶろっくくずし！ 游戏类型：动作游戏 Produced by：ほわいとふれあ（46flare） 非常普通的打砖块游戏。操作莉莉白来接弹球，（大概是）分数奖命，道具只有+1球，打到毛玉也给这个道具（毛玉不伤人）。左右键移动，z开始，没啥好介绍的（，不过音乐不错。 No.15（外传总No.85）游戏名：幽玄の幻夢零 游戏类型：动作游戏 Produced by：Keio Digital Vertex 这名字看起来……像是一个视觉小说。 然而其实，是个横版过关哒！（这是哪里见过类似的话来着？）不同于一般的横版过关在地上跑，这个直接就是在空中飞，就和stg一样。攻击方式就是拿剑横砍和竖砍，有低速移动，人物和你的攻击判定体积都挺大的，所以卡位置砍可以奏效。过几个版面之后是boss战，总体来说还算简单的，道中一直跑不攻击没什么大问题的，敌人攻击追不上你，除非刷到脸上了。 No.16（外传总No.86）游戏名：Youkai Strike!! 游戏类型：策略游戏 Produced by：GhostlyFeline 这是一个……撞球（？）游戏？ 进入游戏，你有三组每组三个人物可以选择。鼠标点击人物拉拽，向对应方向发射，和那些台球游戏差不多。每次行动一人，可以行动的人只会有一次闪烁提示（不亲民）。目标就是将屏幕中的所有不是你操作的人物消灭（就比如图上这是水滴还是啥的也要消灭）。己方的行动回合，所有被 发射人物 打到的己方人物会放技能，所有被打到的非己方人物掉血，相撞几次掉几次血。所以ai经常“打壁球”或者用多妖精碰撞造成大伤害。 No.17（外传总No.87）游戏名：HAKUREI JUMP 游戏类型：动作游戏 Produced by： 嘛……好奇怪的窗口分辨率（ 嗯，就是专门为这个游戏系统设计的。上键跳跃，星星槽有8个，每跳跃一次消耗一个，接触敌人会自动垫脚跳，并且回复一个星星。就这样一边垫脚一边跳去追更高的高度。游戏完全固定板面，背板的话就能跳得非常高。不过要注意敌人是会发弹幕的哦，被打到直接GG，掉出画面下方也是GG。 No.18（外传总No.88）游戏名：〇〇〇ノゲエム 游戏类型：动作游戏 Produced by：ねこもなか 死了啦，都是…… 游戏害的啦。游戏从你还没进入就开始满满的恶意，启动exe的名字叫deathgame（。进入后……emmmm……就像iwanna吧，各种初见杀和恶心人的坑，不知道怎么的就被弄死了。每关有特殊道具，拿不拿无所谓，只是加分用。幸好和iwanna一样命数无限，只是记录一个死亡次数…… No.19（外传总No.89）游戏名：おんりょうをもてあます 游戏类型：动作游戏 Produced by：α-storage （阿燐好可爱啊……） 真正的休闲游戏x3。阿燐带着小推车来收（？）骷髅头啦，说是收，实际上是托（打砖块？）。推着小推车左右移把骷髅头弹回去。当然还有一些干扰的东西，比如说觉之眼啊（没啥作用，弹起来软弹软弹的，不过不能掉），恋之眼啊（不规则路径），阿空的赤之目啊（弹一次点燃，第二次爆炸GG，需要掉到地上）啥的。下面红条就是冲刺条，核能幽灵能燃料跑过去接骷髅，不过耗光了就只能慢慢走着等充能咯。 plus.2（外传总No.90）游戏名：紅魔郷4面魔道書地帯を作ろう 游戏类型：飞行射击游戏 Produced by：pls 打过红魔乡的人都知道的地方的练习（器？） 下次真的不知道啥时候更新了……任务就要来了…… pid=73360667 volantis.js(\"https://unpkg.com/pandown\").then(pandown)","categories":[{"name":"游戏","slug":"游戏","permalink":"https://neko-horikawaraiko.github.io/categories/%E6%B8%B8%E6%88%8F/"}],"tags":[{"name":"带你玩东方","slug":"带你玩东方","permalink":"https://neko-horikawaraiko.github.io/tags/%E5%B8%A6%E4%BD%A0%E7%8E%A9%E4%B8%9C%E6%96%B9/"}]},{"title":"【鼓哥】带你玩东方-外传（七）（小游戏篇）","slug":"【鼓哥】带你玩东方-外传（七）（小游戏篇）","date":"2019-07-16T17:06:43.000Z","updated":"2024-11-04T16:22:21.852Z","comments":true,"path":"2019/07/17/【鼓哥】带你玩东方-外传（七）（小游戏篇）/","link":"","permalink":"https://neko-horikawaraiko.github.io/2019/07/17/%E3%80%90%E9%BC%93%E5%93%A5%E3%80%91%E5%B8%A6%E4%BD%A0%E7%8E%A9%E4%B8%9C%E6%96%B9-%E5%A4%96%E4%BC%A0%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%88%E5%B0%8F%E6%B8%B8%E6%88%8F%E7%AF%87%EF%BC%89/","excerpt":"","text":"大家好，这里是猫耳堀川雷鼓~ 嗯……经过一个学期的咕咕咕我终于找到时间来继续写这篇文章了，在这里向大家道歉。 抱歉了，各位~ No.1（外传总No.61）游戏名：PAC･GYOKU･ROU 游戏类型：动作游戏 Produced by： 嘛……（接近）充分发挥uuz某设定的游戏。下面这张图一看就会明白是什么了。 嗯……吃豆人。不过和fc那个还稍微有点不同。uuz啥都能吃，不会有不能吃的情况。不过相应的，增加了另外的失败机制，就是满腹度，到零之后一定行动之内没有补充就会饿死。baka们会放出干扰让uuz一定时间不能移动，而且她们也会吃掉表面上这些食物。当然为了平衡吃掉这些baka增加的满腹度也很大。 No.2（外传总No.62）游戏名：Shiki Sama’s Judgement 游戏类型：动作游戏 Produced by：Firecat1311 挺有趣的一个游戏，虽然很小但是操作还是不错的。 妖梦要找四季改判，然而四季说什么也不同意，所以来打一架吧……游戏就一关，打四季，用剑砍或者半灵戳都有伤害。 两种颜色的弹幕，剑能砍掉黑色弹幕（说实话拿法真的像刀），半灵能戳掉白色弹幕。四季血量不多，就是看起来挺长一条血但是打几下就没了。只不过四季到处跑，半灵射程很短，经常会打不到。 No.3（外传总No.63）游戏名：東方桃月抄 ～ Pitch Peach Paradise 游戏类型：飞行射击游戏 Produced by： 大 嘘 。这标题界面完全一股子粗制滥造味道。 就像左下角说的一样，这个游戏是人气投票时候丰姬的应援小游戏，游戏目标是接桃子，你操作下面那个筐子，桃子就是就是图上看着不像子弹的那种。需要接到一定数量开启下一符卡，这里丰姬符卡是模仿了某几作6boss终符设计的。当然，这个游戏支持续关，可以无限续关。 No.4（外传总No.64）游戏名：東方☆らんだむだんじょん 游戏类型：冒险游戏 Produced by：IdxLab 玩起来挺像我在视频那边介绍过的一个游戏的，就是那个仿“地底探险”的游戏。这游戏质量挺好的，要不是完成度与难度原因我就做成视频了。 地图完全随机生成，所以没法通过背板来通关，这个游戏自由度非常高，基本所有地都能用炸弹炸开，地里面的黄金也是能补充钱的。power用来发射阴阳玉，只不过距离很远，而且是接近抛物线发射。从特别高空跳下来也会摔到，此时可以消耗power在空中漂浮缓降。跳跃高度不太够两格，通过梯子可以爬高，也可以消耗左上角的绳子凭空挂出绳索，借着绳子爬高。地上的东西看起来能搬的都可以搬，搬起来还能扔出去砸怪。每关还有荷取商店，在里面随机展示几种道具，可以用钱买。甚至可以打荷取，然后抢了商店就跑。（当然荷取会追过来，荷取的ai写的比较智能，追你到天涯海角） 比较硬伤的问题是难度偏难了一点，你扔出去的东西弹回来还能打到你自己，而且有些箱子里会放暗箭打你一条命。过关条件是进入出口门，然而需要自己找，没有地图提示。幸好出口不算很远。 No.5（外传总No.65）游戏名：妖精大変装 游戏类型：飞行射击游戏 Produced by： 恩……纵版stg。听起来好像和原作一样？但是不一样。 标题就说明了，主角是大妖精。游戏画面来看，游戏范围扩大了。然而其他的就几乎不一样了。power不是增加火力的，score也不是真正的分数，这游戏没有分数，p点和蓝点各自加power和分数。有个shot槽，是来限制射击数的（smg），连着打一会，shot槽没了，就不能射击了…… power和score别以为没什么用，它们是在这有用的。这游戏有个射击更换系统——“雾雨邸”，可以在这里升级弹幕和学习新的弹幕（如上图），在“装备更换”可以装备上。而且最重要的一点，power和score需要打完一关，通关之后才能带出来。关卡长度不长，但是挺恶心的，而且一关不会随着装备的改变而改变难度，关卡数量不少，而且打关是没有残和雷的，也没有练习模式，只能慢慢摸索着打。 No.6（外传总No.66）游戏名：橙地霊村 游戏类型：动作游戏 Produced by：atelierdorineko 这个标题可能乍看上去的话，有些人会联想到一个比较恶心的fc游戏叫《魔界村》。很不幸的告诉你，联想对了。 以下来自@洛克人MegaMan： 难度适中吧，比魔界村原作不知道简单到哪里去了，没什么特别坑爹的地方。操作还好，比较流畅没有延迟，不过缺少引导，玩家可能不知道一些特殊动作比如符卡、空翻和显示判定点之类的。画风新奇，可与隔壁takkoman一较高下。音乐一共就两首，一首道中一首boss战，比较单调（没做完可以理解）。 No.7（外传总No.67）游戏名：うつほの地底脱出大作戦 游戏类型：飞行射击游戏 Produced by：耳小屋 这是个阿空为主角的一个射击游戏。虽然简单但是还挺有趣的。 阿空又开始搞异变了，不过还是有点鸟头。从地心还是（按地灵殿顺序）倒着往上打，路上碰到阿燐恋恋小五神妈等等，一并轰了过去。打倒毛玉妖精围墙墓碑什么的会收集核燃料，收集满左侧蓝色条就可以增加一个整的核燃料，进行过剩融合（放bomb）。阿空有三种攻击方式，有的boss还会根据你的射击配置切换攻击方式（挺有趣的吧）；大概是没有疮痍之说，每次miss只会损失分数，根据分数进行排名。 No.8（外传总No.68）游戏名：Sweet Delusions 游戏类型：解谜游戏 Produced by：Chirei 恋恋想吃蛋糕啦，你能帮她吃到蛋糕吗？ 每关从类似左下角那样的黄方框出发，路上要踩够足够数量的黑白方块，打开围在蛋糕周围的黑墙。不过呢，黑白方块踩过一次之后就不能再走了，就是显示的叉号；叹号表示正在踩的方块。所以就需要一些规划来找一个合理的路线，类似于“一笔画”似的，不过这个一般会比一笔画容错率高，但是偶尔也会很让人挠头。 No.9（外传总No.69）游戏名：秋屋とカボチャ 游戏类型：解谜游戏 Produced by： 嘛，这是一个画风很可爱的记忆小游戏，穰子给出一个特定的南瓜样式，你（静叶）需要尽快记住，然后从给出的几个南瓜里挑出所有与所给一样的南瓜，获得高分，总共15关。点错了的话只有分数的倍率惩罚，但是时间到了就……boom！ No.10（外传总No.70）游戏名：魔理沙とアリスと不思議の森 游戏类型：解谜游戏 Produced by： 故事背景是魔理沙在魔法森林突然迷路了，巧遇爱丽丝，然后在爱丽丝帮助下回家。 你说你魔理沙咋就不能飞了呢？游戏中魔理沙没有飞行，跳的只有一格高度，要在爱丽丝的上海蓬莱两个人偶帮助下到达目的地。 左键点击放上海人形，是固定位置的；右键点击放蓬莱人形，会朝着当前魔理沙的方向跑。所有关卡就靠这两个人形垫脚，爬到一些被设置到很偏的地方的目标那里。还有些关卡有钥匙，开相应的门什么的。默认zc左右移动，在游戏内可以设置，不过似乎有些显示问题。（可能是因为体验版吧） 这篇文章可以说是咕的时间够长了（，自己都觉得不好意思。下一期也不知道会啥时候出，尽量快一点吧_(:3」∠❀)_ 头图pid=73997216 volantis.js(\"https://unpkg.com/pandown\").then(pandown)","categories":[{"name":"游戏","slug":"游戏","permalink":"https://neko-horikawaraiko.github.io/categories/%E6%B8%B8%E6%88%8F/"}],"tags":[{"name":"带你玩东方","slug":"带你玩东方","permalink":"https://neko-horikawaraiko.github.io/tags/%E5%B8%A6%E4%BD%A0%E7%8E%A9%E4%B8%9C%E6%96%B9/"}]},{"title":"【鼓哥】带你玩东方-外传（六）（小游戏篇）","slug":"【鼓哥】带你玩东方-外传（六）（小游戏篇）","date":"2019-02-09T15:18:43.000Z","updated":"2024-11-04T16:22:32.818Z","comments":true,"path":"2019/02/09/【鼓哥】带你玩东方-外传（六）（小游戏篇）/","link":"","permalink":"https://neko-horikawaraiko.github.io/2019/02/09/%E3%80%90%E9%BC%93%E5%93%A5%E3%80%91%E5%B8%A6%E4%BD%A0%E7%8E%A9%E4%B8%9C%E6%96%B9-%E5%A4%96%E4%BC%A0%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%88%E5%B0%8F%E6%B8%B8%E6%88%8F%E7%AF%87%EF%BC%89/","excerpt":"","text":"大家好，这里是猫耳堀川雷鼓~ 趁着热乎劲还没过去，我给大家拜个晚年，祝大家新年快乐，学习进步，事业有成，穿上女装~ No.1（外传总No.51）游戏名：Touhou Puzzle League 游戏类型：解谜游戏 Produced by：いぬ研究所 这个游戏算是一个……披着东方皮的……消消乐？ 总之是个三消游戏，控制那个像“工”字形的交换格进行左右换位，然后三消。看得出来，这是个对战游戏，所以有对战的特点，通过进行四消及以上或者连击可以对对方造成障碍，然后落下暂时不可消除的障碍块，贴着障碍块进行消除可以打破障碍。当然，由于方块从下往上出，目标就是耗死对方，让对方方块堆到顶部算获胜。击败对方即可将对方收为后宫，可以使用该角色，然而不知为什么，作者早已停止该游戏更新，所以大概可以收十多个人。 No.2（外传总No.52）游戏名：こんぱくの剣神霊廟編 游戏类型：解谜游戏 Produced by：松の木 这游戏是……emmm……续作，那个当初让我欲生欲死的游戏（。 然而这个游戏亲民度高了点，首先就是能改键位了（喜极），这样就让我舒服了很多。另外本作的半灵不再是控制作用，而是可以“隐身”，当然是原地隐身。不过呢，游戏一如既往的难，仍然是有很恶心人的地方。 No.3（外传总No.53）游戏名：伝説の胡瓜を求めて 游戏类型：动作游戏 Produced by： 这游戏和前面那个Super Aki Simai是一个引擎出品，所以键位是一样的。 相比起来，这个游戏比那个要烦人的多，流程相对较短。不想介绍了（，太恶心了（。 No.4（外传总No.54）游戏名：TypeNine 游戏类型：角色扮演游戏 Produced by：ちびっこ娘々 很可惜，这个游戏我没找到完成版x1 说实话，这个游戏挺像東方の迷宮，不过又是完全不同的模式。开头先给你介绍游戏方法，然后就去探索地牢迷宫吧。 游戏通过简化形式的格子呈现地图，且没有小地图。需要通过找到阶梯上下楼层。这里技能是摆在表面上的，因为如图这种妖怪据点需要直接用技能破坏。迷宫也和通常游戏一样，随机遇敌，不过敌人能够在已经开的格子中看见，自然是可以躲开的。 No.5（外传总No.55）游戏名：とーとと:Re（仮） 游戏类型：策略游戏 Produced by： 很可惜，这个游戏我没找到完成版x2，不过也不会有完整版了，作者已经停止更新了…… 因为不会日语以及乱码、不会类似游戏缘故，我仅探索了一小部分游戏。首先，这个游戏作者是个ぱちゅコン风像素画达人，截止到查看日期，他已经画了许多这样的像素图，已经有真珠岛5boss的图像了。其次，这个游戏素质真的挺高的，选好出击角色，在抵御随机来犯敌人同时前进。不同角色有不同攻击范围与能力，还可以耗费星星增加人物，装备上掉落装备，升级能力等，从上面的途中可窥一斑，算是麻雀虽小五脏俱全。有兴趣的可以尝试一下~ No.6（外传总No.56）游戏名：平安のえいりあん 游戏类型：动作游戏 Produced by： emmm这个游戏…… 可以用一句话概括，就是用坑把毛玉埋掉。按键只有方向键和z，在地上连着挖坑三次，才能挖出能容纳毛玉的坑，挖出来之后就只能等着毛玉自己来掉到坑里。掉进去之后要及时埋上，否则毛玉会跑出来。挖坑四次直接把挖的坑再填上。反正我觉得这游戏挺傻的（。 No.7（外传总No.57）游戏名：幻想もののけ絵巻 游戏类型：动作游戏 Produced by： 很可惜，这个游戏我没找到完成版x3，不过也不会有完整版了，作者已经停止更新了……x2 游戏质量确实挺高，如果不是停止更新，绝对值得大力推荐。这画面，是不是眼前一亮？可以前往该社团官网看一看，所作的像素图质量都很高。相比起来，操作上稍微差了一些，有些滞后，所以攻击要有个提前量。再者，我现在展示的版本没有音乐。做完整的话一定也会是一个有意思的游戏，可惜了。 No.8（外传总No.58）游戏名：ようようちれいでん 游戏类型：飞行射击游戏 Produced by：松の木 看到这个作者……emmmm又是他啊？ 然而这个游戏不是act，而是stg。他居然也做stg？ 然而，还是有些失望的。质量是不如他的act质量高的。很明显可以看到血条制，被打掉一定的血槽。主角妖梦子弹就是图上的白色尖角那样的，不能提升威力。没有难度选择，敌人攻击强度不高，不过有些东西需要发射半灵消除，没有Bomb，判定是全身。还有一个挺恶心的一个地方就是，后面有版面是会突然人物朝向变向的，不给任何提示。 No.9（外传总No.59）游戏名：ブンブンロジック 游戏类型：解谜游戏 Produced by：松の木 这个游戏对于有些人来说不会陌生，不过翻译有一点区别。 英文称为Nonogram，日本相关游戏叫做「ピクロス」。中文名字翻译为“填方块“或者“数织”。就是按照两侧的数字按顺序涂上连续相应个数的格子（两数字对应的涂出的格子之间会空白格），最后形成一幅图画。上图就是一个接近完成的图形。感兴趣的可以自己找一些相关游戏来玩，涂出一个复杂图形时不仅观赏性很好，成就感也很足。 No.10（外传总No.60）游戏名：レイセン ブロック崩し 游戏类型：动作游戏 Produced by：猫谷美甘（tailtame） ブロック崩し，标准的打砖块游戏名，以后还会介绍好几个这样的游戏。 打砖块怎么玩我就不多讲了，这个游戏用鼠标移动来控制板子移动，砖块是emmmm…… 你们可以比对一下这两张图之间的区别，就可以猜到了。当然，这游戏并不要求全部打完，完成度达到一定值就算过关，毕竟砖块都看不见（。 （本文章米有后记.jpg） volantis.js(\"https://unpkg.com/pandown\").then(pandown)","categories":[{"name":"游戏","slug":"游戏","permalink":"https://neko-horikawaraiko.github.io/categories/%E6%B8%B8%E6%88%8F/"}],"tags":[{"name":"带你玩东方","slug":"带你玩东方","permalink":"https://neko-horikawaraiko.github.io/tags/%E5%B8%A6%E4%BD%A0%E7%8E%A9%E4%B8%9C%E6%96%B9/"}]},{"title":"【鼓哥】带你玩东方-外传（五）（小游戏篇）","slug":"【鼓哥】带你玩东方-外传（五）（小游戏篇）","date":"2019-02-03T16:13:18.000Z","updated":"2024-11-04T16:20:56.964Z","comments":true,"path":"2019/02/04/【鼓哥】带你玩东方-外传（五）（小游戏篇）/","link":"","permalink":"https://neko-horikawaraiko.github.io/2019/02/04/%E3%80%90%E9%BC%93%E5%93%A5%E3%80%91%E5%B8%A6%E4%BD%A0%E7%8E%A9%E4%B8%9C%E6%96%B9-%E5%A4%96%E4%BC%A0%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%88%E5%B0%8F%E6%B8%B8%E6%88%8F%E7%AF%87%EF%BC%89/","excerpt":"","text":"大家好~这里是猫耳堀川雷鼓~ 临近假期，我也终于有了继续写下去的时间，估计这篇文章发出去的时候绝大多数学生都应该放假了，嗯~ 一不小心，距离上一篇文章咕了三个月了（上篇文章好像是说咕两个月来着……），不管怎么说，文章还是要继续下去的，那就开始吧~ No.1（外传总No.41）游戏名：東方降魔伝プラス 游戏类型：动作游戏 Produced by：ニッキー 首先，这游戏分辨率挺低的：窗口只有320*240大小，可以全屏，F4切换，大概就是直接这个分辨率拉到了全屏大小（保持比例）。其次，这游戏难度还是有点的，虽然是血条制，但是敌人打你三下你就gg，不过能通过吃“苹果”恢复血量。 见左上角红色血条，这是只被打了一下 主角灵梦，按照作者的说法可以加入2p魔理沙。灵梦的武器我暂时只见到三种：阴阳玉，抛物线轨迹，可打破木桶；符札，三叉弹，射程长；魔法阵，直线射程，射程短而范围较大。游戏有刷怪机制，拖版会把怪重新刷出来；有击退机制，有坑的时候掉下来就gg了；有奖残机制，收集金币或者钱袋（内有多个金币）每100个奖一残。因为画面很小，画面中元素就很少，路只能通过堆命背板记下来。 stage1过关，鸟居是过关标志 由于难度和一些机关奇怪的判定，我只打到了第三关（丢人）。去作者主页翻了一下，这个作者喜欢做这类的act，就是马里奥式的，这个游戏只是借鉴了一点影子。 No.2（外传总No.42）游戏名：To Hole of Hell 游戏类型：动作游戏 Produced by： 标题界面（个人原因乱码没能消除，现在的选项是开始，中间有个排行榜选项，最下面这个是退出） 是灵梦就下100层，大概是一个这个游戏比较好的翻译了。 大致不用介绍都能明白是怎么个玩法了。基本按键：x确认c跳跃Space暂停左右键移动。不过难受的是灵梦跑的有点慢，很容易被拖到版顶出屏杀，尤其是游戏每7层——层数并不是按照下降踩的平台数或者平台层数确定，而是按照一定距离——会提升一点速度，出屏杀就更是一大杀手。如果踩到了平台中间，基本就不用挣扎了（。最后一句话提一下，左上角三格血量，碰一次怪减一格，减没游戏也结束，不过这种死法比较少见（ 由于作者要求，本游戏无法再转发，不过可以前往以下网址游玩：https://game.nicovideo.jp/atsumaru/games/gm6577 No.3（外传总No.43）游戏名：メイド イン ヘル！ 游戏类型：动作游戏 Produced by：404 这是个挺不错的act，主角咲夜，横版清关模式。 游戏界面（左上角因为没转码“x”显示为了“事”） 这游戏玩起来的感觉和洛克人相仿，格血条制（左下角蓝色条），不过没有获得boss武器设定，只有咲夜自带技能：时停（左下角红色条），技能条红色时可发动，一次消耗干净。杀敌掉落大小“能量点”（无官方称呼），拾取能量点能恢复时停技能条，也能在攒满100量（左上角统计，大小能量点增加数量不同）时恢复一格血。 作者做的这个游戏其实也玩了一些梗，比如下面的save存档点，以及负命数的设定（ i wanna的save点 猫里奥的负命数（左上角） 然而这些梗并不能让我玩的舒服，因为这个游戏整体难度中等，但是版面特别恶心。比如坑上追踪敌人、自机狙。如果放在其他游戏可能很容易过关，但是这游戏还有个设定，虽然能二段跳，可是跳起来不能发射远程攻击（飞刀），只能近战小刀，在地上的时候远程飞刀也不能连续发射（大概不太到1s间隔）。整体控制的话，人物也不是很灵活。这造成了在坑上地段前进的相当难度。平面地段也会有一些恶心的敌人组合，想了解的可以自行前往游玩。 蓝色飞行毛玉自机追踪，蓝色子弹自机狙 每关关底有boss战，和洛克人的boss战差不多，不过之前那些能量点、操作方面设定完全不变，所以在boss战里自机是可能回血的。这里就不剧透boss是谁了。 可以看出，作者确实想做一个好游戏，不过可能对难度把握有点不准。 No.4（外传总No.44）游戏名：東方迷路 游戏类型：解谜游戏 Produced by：松の木 恩……一句话介绍，走迷宫游戏，“G”字样是终点，到达终点自动开启下一张迷宫图，每次开启迷宫都不重复，注意不被阴阳玉砸到。 No.5（外传总No.45）游戏名：SUPER AKI SIMAI（スーパー秋姉妹） 游戏类型：动作游戏 Produced by：KORINDO 超级马里奥？ 是的，就是超级马里奥…………………………的标题界面仿制品。内容和马里奥相仿但是差距也很明显。 游戏没有马里奥的命数制，只有倒计时。在倒计时之前静叶要经过重重跳跃难关到达终点救出妹妹穰子。前面这句话蕴含的意思就是这游戏中只有左右移动和跳跃，所以无法攻击。可以踩的人物只有灵梦（好惨啊），其他人物（除了穰子）一碰即死。版面设置极其恶心，突然蹦出一只怪就可能让你GG，然后请从头再来，因为没有自动存档点。幸好作者和蔼可亲的给了手动存档键。可以无限存档。流程很短，只有一关。 No.6（外传总No.46）游戏名：妖魔夜行 游戏类型：动作游戏 Produced by：牛乳屋 这个游戏大概是4399小游戏级别的那种（ 控制露米娅在路上“妖魔夜行”，遇到前面的妖精可以加速跳过去或者冲撞“推倒”，努力跑远吧。左下角黄色条为“蓄力条”（自己编的），加速和冲撞消耗该条，随时间自动恢复。路上要防备空中来的干扰，干扰还有可能从背后冒出来哦（ 另外，按R键有惊喜（？）。 No.7（外传总No.47）游戏名：ウンザンマニア 游戏类型：模拟游戏 Produced by：ひむかし 大概在十多年前，有一种在学生中很流行的电子游戏机，你可以在里面养自己的小宠物，甚至有的人会在半夜起来给小宠物喂食免得被饿死。这就是“宠物机”。 现在大概这东西已经湮灭在历史长河中，留给那一代人的只有记忆。 要介绍的这个游戏就是一种模拟宠物机，宠物是云山，比如和云山做游戏来获得一些限定物品，给云山喂食等。只不过这个游戏是日文的，需要有一定日文基础（或者强猜）搞懂游戏目标。 “cheese”连打游戏 オラオラオラオラオラオラ No.8（外传总No.48）游戏名：東方冷凍湖 游戏类型：飞行射击游戏 Produced by：CSG 看看标题就能知道这个游戏主角是谁了。 这个游戏敌机自然是⑨，然而自机是⑥（还有隐藏人物哦）。弹幕设计还算可以，手感有些差，只有一个extra关。 No.9（外传总No.49）游戏名：かっぱと神様 游戏类型：解谜游戏 Produced by：松の木 看过我的系列原来的作品会对这个画风有点印象，毕竟这种画风是相当有特点的。 这个游戏是以荷取为主角，帮助守矢神社搜集信仰（。游戏设定荷取不会跳，只有一个抓手辅助前进。这个抓手可以抓在浅灰色墙壁上，也能打晕部分怪物，还能打破裂缝砖块。荷取要在这些复杂地形中前进，收集信仰，就是右下角像是圆牌似的东西。有些信仰藏在砖中，需要自己找出。但是过关不需要完全收集。 No.10（外传总No.50）游戏名：橙の冒険 游戏类型：解谜游戏 Produced by：松の木 嘛，和上一个游戏是同样作者出产。看画风与手感，大概算是作者早期的游戏。 你要控制橙喵，在从隙间中被紫老太婆赶出来之后再返回隙间。过关就要找到上图的钥匙开启隙间，但是隙间开启位置并不在原地。关卡中有数个宝箱等待拾取，基本的是一个P点，没什么作用，其他关卡中可能有“禁言”“开灯”等附加道具，对通关有所帮助。跳跃可以无限高，但是碰到天花板会撞晕，然后掉下来硬直。操作手感略差，大部分情况要打提前量。 emmmm对于鸽了这么久我深感抱歉，不过未来也很难说啊（。游戏有很多，可是能拿得出来的并不多，而且新出游戏速度也是挺快的。作为个人，不能说对各种游戏精通，但是想玩出点进度来也需要下一番功夫，有的游戏确实也很恶心啊，各种奇葩键位设置以及游戏品质是测试的一大难题。加油吧，希望假期中能再出几篇文章。 pid=8702869 volantis.js(\"https://unpkg.com/pandown\").then(pandown)","categories":[{"name":"游戏","slug":"游戏","permalink":"https://neko-horikawaraiko.github.io/categories/%E6%B8%B8%E6%88%8F/"}],"tags":[{"name":"带你玩东方","slug":"带你玩东方","permalink":"https://neko-horikawaraiko.github.io/tags/%E5%B8%A6%E4%BD%A0%E7%8E%A9%E4%B8%9C%E6%96%B9/"}]},{"title":"【鼓哥】带你玩东方-外传（四）（小游戏篇）","slug":"【鼓哥】带你玩东方-外传（四）（小游戏篇）","date":"2018-10-27T15:40:07.000Z","updated":"2024-11-04T16:20:48.891Z","comments":true,"path":"2018/10/27/【鼓哥】带你玩东方-外传（四）（小游戏篇）/","link":"","permalink":"https://neko-horikawaraiko.github.io/2018/10/27/%E3%80%90%E9%BC%93%E5%93%A5%E3%80%91%E5%B8%A6%E4%BD%A0%E7%8E%A9%E4%B8%9C%E6%96%B9-%E5%A4%96%E4%BC%A0%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%88%E5%B0%8F%E6%B8%B8%E6%88%8F%E7%AF%87%EF%BC%89/","excerpt":"","text":"大家好~这里是猫耳堀川雷鼓~ 大家的学校生活怎么样呢？大概开学一个月内还是不太适应回来的，然后一个月之后就是十一假期，中间还插了个中秋节，然后又是学校适应期23333 说了这么多，该好好学还是要好好学的。当前最要紧的事情不就只有这个嘛？如果是工作党那就好好准备工作啦。 以上是临开学的时候写的（，已经鸽了两个月了（ 本期呢依然是小游戏篇，总体来说和前两期游戏性没有太大差别。 No.1（外传总No.30）游戏名：ルナチャイルドの最終防衛ライン2 游戏类型：动作游戏 Produced by：えなめる 其实看题目的话很容易想到另一个著名的stg游戏——ルナチャイルドの最終防衛ライン3（露娜切云德的最终防线3，好像也不是那么出名……），没错，这俩游戏是同一个作者，而且很明显这一作是一个不成熟作品。 界面就显示出，游戏两个难度，normal和lunatic。游戏就是控制露娜朝着四个方向打毛玉，然后“收集”另外两个妖精。收集到的妖精可以放b（什么奇葩设定），全屏消毛玉。游戏目的就是比谁的分数高。normal和lunatic的区别就是初始player数量以及毛玉侵袭速度，也就是说normal玩到最后也相当于玩lunatic了。 No.2（外传总No.31）游戏名：ぞろぞろウォーズ 游戏类型：动作游戏 Produced by：（オートリ電子/特殊装甲隊） 标题图中唯一的主角 看我燐车漂移！啊不对，走错片场了…… 这游戏主角是阿燐没错的。不过游戏机制很奇特，你的阿燐可以射击，但是射程很短，而且还需要有补充弹药时间。最得力的助手就是你的地灵妖精们，触碰每一只白蜡烛就能激活一只妖精，不同地区的蜡烛有不同的妖精，他们也有不同血量与攻击方式，靠他们打路上的怪是最方便的。 一群小妖精 当然，是个游戏就很喜欢做个boss。然而，我打不过……不知道boss之后是怎么样的…… 你想要的boss No.3（外传总No.32）游戏名：あたいのにちじょう～いなくなった大ちゃん～ 游戏类型：飞行射击游戏 Produced by：Rightnya（ライト） 这是什么标题…… 哈……又是一个⑨做主角的游戏。 故事还是⑨去救大妖精（大妖精你怎么天天让⑨操心啊），然而⑨面对的敌人只有大大小小的青蛙……和普遍的东方stg不太一样，这个游戏可以向后射击，不过不能向上下，追踪弹可以打两侧敌人。火力系统比较迷，大概是根据经验值多少决定火力等级，最高等级“看起来”还是挺有火力的。游戏有残机和雷的设定，想通关尽量坚持往下打吧，难度不算太高。 看起来很有火力的弹幕 No.4（外传总No.33）游戏名：東方店舗録～Combinations With You 游戏类型：飞行射击游戏 Produced by：魯鈍ジョン 熟悉的画风 看过我前几期的朋友可能会对这个画风感到熟悉。这不就是“东方养蜂场”的风格吗？不过这个没有了难度选择，只有一个“family”难度，混关大概相当于n的样子。另外我终于找到了作者名，第一期那个地方可以不再是（忘记了，抱歉）了哈哈哈哈…… boss名不破見 舞子，有“超越次元开店程度的能力”，说白了就是店员（。弹幕不算难，只不过反弹很容易糟。血条很多，按照“非-符模式”大致可以当做除以2看。没什么特别的地方，想玩的话可以体验一把。 时符【橙~~~~店】 No.5（外传总No.34）游戏名：にとりタイプ 游戏类型：教育游戏 Produced by： 肯定很多人玩过当年金山打字的那些小游戏，这个呢也是一个打字游戏，不过和金山那个有很大区别。 上面有三种模式，但是有两种实际上没太多区别。游戏目标就是打正确的字过关，不过字不是汉字，而是日文罗马音，对于不会日语的人来说比较别扭（当然打字快的除外）。其中quiz模式是一道一道的题目，你需要读懂日文问题并且打出对应的罗马音答案。另外由于游戏本身原因，提供的可打词组非常少，只限定于东方中与荷取相关的一些词组。 No.6（外传总No.35）游戏名：Rush the 雛 游戏类型：动作游戏 Produced by： 挺好玩的一个小游戏，主角当然就是转转啦。 转转神为了收集厄运，跑遍了幻想乡，吃尽了苦头。游戏机制与我在系列视频第一期中讲的Mystia Dash相似，区别就在于这个游戏没有在后面追你的，也没有在后面插你的，只有你自己掉下去的。这个游戏的跑的平台很碎，就像是在花坛里铺的石板路，一步太小两步扯蛋，根本没法好好玩游戏。 每一关中都会将收集的厄运数量重置，每50厄可以增加一残机，左上绿条就是飞行蓄力槽，路上有几种道具减槽啊增速啊等。rush mode每关全长500m，共4关，分别是妖精树海、地灵殿、幻想乡上空、大祀庙洞窟。charange mode就是无限距离，跑得越远越好。 每关通关与全部通关都是有通关贺图的哦，强烈建议自己通关查看~ No.7（外传总No.36）游戏名：東方仮名抄 ～ Sanae x Mystic Circle. 游戏类型：飞行射击游戏 Produced by：幽々燦々（ゆゆさんさん） 标注为“休闲”射击游戏的一点也不休闲的游戏。 总的来说，这游戏神经病啊？ 如图所见，这游戏是可以斜着射击的，因此也可以往后射击。不过要命的是，转向系统不是其他键位辅助（因为平面游戏一般都用上下左右来在平面自由移动），而是直接借用上下左右。也就是说，地灵殿灵梦的文配置的子机什么样，这个就那样。作者也考虑到射击方向问题，另外设置了键位可以固定射击方向，就像是dld梦c的低速一样。然而，你四周出魔法阵（敌人只有魔法阵），固定了方向还不如乱晃射击来的实在。 作为一个现代化东方射击游戏，这游戏是没有低速的。不过速度设计还好，不算太滑。射击模式两种，散弹和激光；另外是有雷的设计的，散弹模式的雷只有撞击判定，也就是碰到魔法阵时才爆炸，否则就飞到屏幕外去了，激光雷是全屏追踪，相比起来激光雷更易打中东西，散弹雷在团灭时好用。 No.8（外传总No.37）游戏名：みんな大好き魂魄 游戏类型：动作游戏 Produced by： 这个游戏一看就是跟妖梦有关的啊。不过呢…… 想玩这游戏的话请提前做好摔电脑的心理准备，毕竟把游戏做到滑溜到恶心人真的不多见。 这是一个妖梦给uuz找零食的游戏，你要操纵惯性超大、脚底特滑的妖梦穿梭于各个平台，收集uuz大人需要的零食，然后带回到uuz身边。每关需要的零食数量各不相同，分布位置也不相同。游戏没有小地图，所以这些食物在哪你需要自己探索着找。妖梦总共有三次机会，时间到了而没有把食物找齐带回uuz那，就损失一次机会，全部损失完游戏结束。不过作者提供了continue来用新的三次机会继续上次结束的关卡。 游戏最大的特点就是滑。玩过马里奥的朋友都知道，马里奥有走动惯性的机制，停下的时候还会往前迈一两步。这个游戏不仅有这个惯性，而且非常大，基本妖梦从平台上掉下来都是这个原因。而且妖梦速度……满速的话非常快，再加上惯性，很容易能跳过去一个平台，然后正好落在空隙掉下来。屡次玩耍屡次都因为这些因素不能过关，当然想砸电脑咯。 No.9（外传总No.38）游戏名：東方地平線 ～FlightSwitchOn！ 游戏类型：策略角色扮演游戏 Produced by：（オートリ電子/特殊装甲隊） 这是我不擅长的一类游戏，就简要介绍一下吧 東方地平線是一款仿火焰纹章一类的战棋游戏（策略角色扮演游戏），通过在规定格子地图上走棋，运用策略来击败全部敌人。 主角是灵梦，靠着自己的“人格魅力”来收“后宫”。整体上还是挺有难度的一款游戏，关键在于比较坑的残机与伤害机制。想保住所有残机基本是不可能的，boss打你一下基本你就没了一残。这里的残机制不同于血条制，所以你1hit打出了两残的伤害，但是对方只会掉一残。因此怎样用有限的残机打倒有比你多不少的残机的敌人，就是一大难点。 No.10（外传总No.39）游戏名：东方暴打油库里 游戏类型：动作游戏 Produced by：MyACG Studio 就如同右下角写的一样，或许你对永幻难度太高而生气，或许你对东方大战争太卡而抱怨。本作品就是游戏作者制作出来作为发泄游戏使用的（ 实际上就是一个打地鼠游戏！！！！！ plus.1（外传总No.40）游戏名：东方仙华赋 游戏类型：飞行射击游戏 Produced by：（未知） emmm没什么可介绍的stg游戏，东方x仙剑的二次同人，结果只有一关体验，极大概率估计是早已烂尾的游戏（ 游戏截图（擦蛋hhh） ui使用星莲船风格，道中也借用了一面道中曲，不过道中boss是小伞。关底音乐是曾志豪所作纯音乐《仗剑》，不过说实话与stg游戏不算搭配啊。（boss根据榴佬指出是五毒兽“勇气”） 我 真 的 还 想 再 鸽 两 个 月 ！ 专栏封面图头图pid=35262560 volantis.js(\"https://unpkg.com/pandown\").then(pandown)","categories":[{"name":"游戏","slug":"游戏","permalink":"https://neko-horikawaraiko.github.io/categories/%E6%B8%B8%E6%88%8F/"}],"tags":[{"name":"带你玩东方","slug":"带你玩东方","permalink":"https://neko-horikawaraiko.github.io/tags/%E5%B8%A6%E4%BD%A0%E7%8E%A9%E4%B8%9C%E6%96%B9/"}]},{"title":"【鼓哥】带你玩东方-外传（三）（小游戏篇）","slug":"【鼓哥】带你玩东方-外传（三）（小游戏篇）","date":"2018-08-28T13:35:43.000Z","updated":"2024-11-04T16:20:40.068Z","comments":true,"path":"2018/08/28/【鼓哥】带你玩东方-外传（三）（小游戏篇）/","link":"","permalink":"https://neko-horikawaraiko.github.io/2018/08/28/%E3%80%90%E9%BC%93%E5%93%A5%E3%80%91%E5%B8%A6%E4%BD%A0%E7%8E%A9%E4%B8%9C%E6%96%B9-%E5%A4%96%E4%BC%A0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%88%E5%B0%8F%E6%B8%B8%E6%88%8F%E7%AF%87%EF%BC%89/","excerpt":"","text":"大家好啊，这里是猫耳堀川雷鼓~ 嘛，这次是真的快啊，第三期就这么出来了。在第三期这素材准备的途中，我打出来了第二个lunatic混关（东方风神录），其实几天前我动态中说坑推不动了，重心转移来着，结果还是多打了打然后发了（真香）。 然后嘛，本期依然是找到了一些小游戏来（hùn）介（tóu）绍（gǎo），希望大家喜欢~ No.1（外传总No.21）游戏名：伊吹萃香の百万鬼鉄拳 游戏类型：动作游戏 Produced by： 虽然说标题名字叫萃香的什么什么，但是实际的主角有三个人：魔理沙、萃香、阿空。游戏目标就是把要石打入地里，比谁打的深。找准力度、准星、平衡点，然后一拳把要（地）石（球)打裂。 不过怎么看这个地方也是在博丽神社吧，原来不是说有一块要石插在那里吗？结果魔理沙三人一人一拳，把神社震塌了，怕是逃不了被梦想封印了hhhh。 No.2（外传总No.22）游戏名：Flandre’s Quest 游戏类型：视觉小说 Produced by：Rednal 这是一个英文视觉小说，说的是芙兰一次出去玩的时候需要的一个小问题，然后寻找答案的过程。 遇到了灵梦和爱丽丝 故事比较短，而且没有分支选项，大概当做高中级别东方众的课外阅读还可以，文章比较简单（你这说到哪去了，下一句是不是该说九磅十五便士了啊？），大概也就“九磅十五便士”的等级，大概二十分钟能过一遍。只不过，连bgm也没有…… 下面内容涉及剧透，想自己体验原文的请跳过 有一天芙兰想出门了，于是她打破了门和墙，拿着阳伞溜出去了。首先她到了红白那里，想和红白玩。然而灵梦并不想讨论这个话题，并端上来了茶。话锋一转，说到魔理沙的生日接近了，问芙兰有没有打算给魔理沙一个礼物。不过芙兰以为礼物就是好吃的食物，比如用X做的X茶。灵梦似乎看出了芙兰的心思，提醒道要自己想用什么作为礼物，记得不要杀生。离开了神社，芙兰飞到了魔法之森，见到了爱丽丝·玛？？？爱丽丝以为芙兰想来玩弹幕，想要拒绝，不过芙兰说是来问给魔理沙什么礼物。于是爱丽丝出主意说给魔理沙一个稀有的蘑菇，讨论了一下不成，爱丽丝又提议给一个月都科技那种的小玩意。芙兰离开了，但是不明白科技具体指的什么。飞在天上被文文发现了，然而文文的取材让芙兰很烦躁。芙兰问文文魔理沙的礼物，文文提议送帕琪图书馆里的书，芙兰认为这没什么用，魔理沙想要的书估计早就被偷走了。来到了妖怪之山，想找河童科技，却见到了萃香。问到礼物的事，果然萃香的回答是送点酒。被拒绝之后，萃香提议找紫咨询建议。回到神社，紫果然给出了一个可行的建议。到了生日会那天，芙兰提出给魔理沙礼物。不是吃的，而是像魔理沙一样的星星弹幕，在夜幕中闪闪发光。 No.3（外传总No.23）游戏名：touhou fabulous languaje party 游戏类型：飞行射击游戏 Produced by：chainedTan 这是一个用Unity做横版stg，暂时还在制作中（？）。 整体的游戏素质比较不错，像素风格，整个都比较简单，没有难度选择，只不过有些弹幕难度和整体风格不太像。关底是华扇这一点比较新颖。然而没有bgm。 关底华扇 No.4（外传总No.24）游戏名：新春！夜雀羽根突きエクストリーム！２０１６ 游戏类型：动作游戏 Produced by：nagasapa 这个嘛……标题很长，但是没什么用。要我给起标题就叫“夜雀的反应速度教室”。 游戏目标比较简单，控制夜雀上下移动，将飞来的弹珠打回去。听起来好像与我在视频中介绍过的那个棒球游戏挺像，不过还是有很大区别的。 有四种模式，都是比谁打出的数量多。就像上图，弹珠分三路从右面飞来，夜雀就在那一小竖条范围移动，等到弹珠靠近时击打回去就是右下角的成功。不过弹珠飞行极其诡异，首先速度不一，有的非常快；在某两个模式中还会在飞行途中变速、变道，完全贯彻了“来呀来呀你就是打不到我”的宗旨。 No.5（外传总No.25）游戏名：Ruby Mobius 游戏类型：飞行射击游戏 Produced by： 这，是一个，画风清奇的，BGM清奇的，难度极高的，还未完成的，横版的，stg游戏。 ……（现在找到的网络上的资源大概都是这个未完成版，没有更新的版本） 说它难度极高，是因为弹幕大概都在L的难度（没有难度选择），前后都会有弹幕，而你是无法向后射击的。即使背板，短时间也很难找到一个完全安全的走位路线。不过这个游戏道中妖精爆掉会消弹，很像宵海格。收集消弹白点增加tension值，相当于残机；擦弹增加擦弹数，达到相应数量奖bomb，bomb无敌时间很短。总之是一个很奇怪的游戏系统。 未完成版只有一面，boss比道中简单得多，毕竟是⑨…… No.6（外传总No.26）游戏名：アマノジャク Reverse 游戏类型：飞行射击游戏 Produced by：Raichu 天邪鬼都通了吗？能ni了吗？ 玩够了的话不妨来玩一下这个游戏吧，天邪鬼式同人游戏（之一）——天邪鬼Reverse！ 这次你扮演萌狼，而对手是正邪，运用你的智慧，打败拥有犯规道具的天邪鬼！ ……我编不下去了（ 总之就是那么一个游戏啦，自机是今泉影狼，有五种技能可选，敌机是正邪，合理运用技能把正邪打败。虽然看起来右面技能是无穷次的，实际上有CD时间，而且这是作者特意做了一个设置，在option可选择是否无限使用。另外本游戏包附带了你紫哥的ni的rep，提供借鉴…… No.7（外传总No.27）游戏名：藍さまが よくわからないけど ひたすら走るゲーム ＹＡＫＵＭＯ ＲＵＮ！ 游戏类型：动作游戏 Produced by： 有一天，紫妹（ma）闲得无聊，觉得蓝（Ran，らん）要跑（run，らん）一跑的话挺有趣的，于是设置了一个20关的“蓝大人不清楚是什么但是一直跑”的游戏。 如题，整个游戏就是蓝大人往前跑，穿越各种地形到达目标地点。路上会有各种小妖精或冲过来或发射弹幕，阻挡蓝大人前进。左上角显示分数，也相当于倒计时，分数为0之前到达目标算过关，被体术或者子弹打到会扣一定的分数。路上有p点，就是加时间用的。 蓝大人自动加速，可以控制的是跳跃和一定时间内的减速后退，被体术、打到、撞到障碍都会后退，当然也都消耗了时间。前面关卡随便可以过，后面的话需要稍微背背板，特别恶心。 ↑蓝大人后面跟着的……应该能才出来是什么吧233 No.8（外传总No.28）游戏名：Rumia Roller 游戏类型：动作游戏 Produced by：Gman8r 很短但是强推的游戏！ 这种游戏风格确实不错，简洁明了，音乐空灵澄澈，搭配的很合适。游戏主体为控制露米娅球在平台上滚动、跳跃、翻转，到达终点。游戏重力方向比较特殊，以人物头向脚方向为重力，所以当你向上贴着平台的时候重力会刚好反过来。 整个游戏总共⑩关，前几关不难，只有最后一关有些难度，而且很容易迷路（应该叫不知道终点在哪）。 No.9（外传总No.29）游戏名：东方梦魂链 游戏类型：动作角色扮演游戏 Produced by：ッ不动のKING emmm，这游戏和前面某个似的，挺尴尬。 咲夜在外出吃饭回红魔馆的路上路过森林，突然感到杀机，于是做了下“饭后运动”。 说白了，就是控制主角射击打怪（rpg+stg+act但是全是半吊子的感觉）。打掉路上的怪物可以获得蓝点分数，打掉飞碟能得一个红点加hp。大致往下游戏就是这么进行的。尴尬原因和前面那个相似，只不过这个是不知道因为我的原因还是什么，游戏到了第三场景就无法往下进行。所以也就没办法做深入介绍。 恭喜达成成就“暑假结束”。 大概，这就是暑假的最后一期了。之后的专栏和视频真的保证不了了，三次元的事情还是比较重要的。动态的话，因为我也知道一部分人对太多动态反感，所以我很少发动态。但是相信我，动态少并不代表我没有了活动，这个系列也一定不会断的。各位加油，保重。有缘再见。 头图pid=23869259 volantis.js(\"https://unpkg.com/pandown\").then(pandown)","categories":[{"name":"游戏","slug":"游戏","permalink":"https://neko-horikawaraiko.github.io/categories/%E6%B8%B8%E6%88%8F/"}],"tags":[{"name":"带你玩东方","slug":"带你玩东方","permalink":"https://neko-horikawaraiko.github.io/tags/%E5%B8%A6%E4%BD%A0%E7%8E%A9%E4%B8%9C%E6%96%B9/"}]},{"title":"【鼓哥】带你玩东方-外传（二）（小游戏篇）","slug":"【鼓哥】带你玩东方-外传（二）（小游戏篇）","date":"2018-08-22T16:05:44.000Z","updated":"2024-11-04T16:20:30.653Z","comments":true,"path":"2018/08/23/【鼓哥】带你玩东方-外传（二）（小游戏篇）/","link":"","permalink":"https://neko-horikawaraiko.github.io/2018/08/23/%E3%80%90%E9%BC%93%E5%93%A5%E3%80%91%E5%B8%A6%E4%BD%A0%E7%8E%A9%E4%B8%9C%E6%96%B9-%E5%A4%96%E4%BC%A0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%88%E5%B0%8F%E6%B8%B8%E6%88%8F%E7%AF%87%EF%BC%89/","excerpt":"","text":"大家好啊~这里是猫耳堀川雷鼓。 感谢@幻想乡共和国的推荐，我的同人游戏系列被更多人了解，这样也让更多人了解了东方系列（同人）游戏的有趣之处。 本次呢，是外传系列的第二期，继续介绍一些小游戏，相比上一期来说这次的游戏似乎要稍微有趣一些了。 另外我仍然要提醒想玩游戏的各位，如果游戏打开乱码，请自行 ①下载安装APPLocale ②下载安装LocaleEmulator ③电脑系统设置转区，以上一般三选一即可打开不乱码。另外如果txt文本打开乱码可以尝试右键菜单打开方式使用OfficeWord打开，选用日文编码可能会解决。 No.1（外传总No.11）游戏名：しょぼんのアクション 游戏类型：动作游戏 Produced by：ちく 标题界面（汉化翻译为了图上的名字，也只是把标题汉化了） 看到这个界面，你联想到了什么？ 没错，正是在下 所以……我就不用做过多说明了吧…… 大致就是把猫里奥贴图改为妹红（毕竟不死蓬莱人），其他一些地方也改了点贴图，仅此而已。关卡坑点和原版猫里奥一模一样，如果玩过猫里奥的话应该非常熟悉。 毛玉和喷出来的腹黑兔 蹦出来的辉夜和中间存档点的老师 另外，标题界面按0键（键盘o和p上方那个）有惊喜。（来自作者说） No.2（外传总No.12）游戏名：ずっとあたいのターン！ 游戏类型：教育游戏 Produced by：よもぎ 你觉得这个游戏会是什么样子的？ 开始玩之后你会发现刺激的一比，如下图。 这居然是学！习！游！戏！还是日！英！双！语！ 实际上这是一个日本作者做的背英语单词的RPG游戏，如果我们来玩就成了日英双外语同时学习了。游戏总共设置了2500个英语单词，从小学水平到四六级都有涉及。一般来说难度不在英文方面，而是在日文方面，因为大部分人是英语教育，所以日文啥意思只能靠有汉字的选项猜测。游戏以chapter与stage展现，每个stage需要达成不同条件——比如答对几个、连续答对几个、打败多少NPC等——来清关。 然而它还是一个RPG游戏，所以作者设置了一些能力点，可以升级琪露诺的血量攻击力等属性，另外还有一些小成就系统设置。游戏本身没设置bgm，但是可以自己添加文件至特定位置即可，见readme.txt。这游戏真骨骼清奇，没话说。 No.3（外传总No.13）游戏名：東方一騎當千 游戏类型：射击游戏 Produced by：東方Flash小店 标题界面这灵梦……我滴妈呀…… 不过进了游戏就行了，见不到这幅画了。游戏说明讲到，灵梦要保卫自己家打败一波波来犯的妖怪，不过我也没看出哪里保卫来了。不过反正就是到处乱射然后打死妖怪就可以了。 游戏内擦弹很重要，你可以凭借擦弹数在升级界面提升能力，恢复血量。然而……这是类act的stg，擦弹有那么好擦吗？1000擦弹数恢复血量是来搞笑的吧？每一波10个敌人血厚的一比，往后几波妖怪发弹越来越奇葩，然后你擦不动弹，升不了级，打不了怪，陷入死循环而GG。 No.4（外传总No.14）游戏名：快傑スワット 游戏类型：动作游戏 Produced by： 先说一句，喝酒害人啊（后排艾特2un）。 这是几个人的合作游戏，青蛙子为主角，没什么故事背景，就是一个往前闯关的游戏。 然而，要是那么容易的话我就不会说害人了。这游戏操作特别滑，一个不好就掉到刺上game over；另外虽然青蛙子能发子弹（扔铁轮），但是不是往正前方，而是在前方上下大概六十度角的范围内随机方向扔；关卡有的地方需要从高处跳下来，然而你事先是不知道下方地形的，只能以身探路（，所以是个纯背板游戏。 据作者说，游戏有boss战和二周目，不过前面这一点路已经消耗完了我的耐心（ 我似乎开头提到了喝酒，这游戏是他们喝酒时冒出来的想法，然后三天做完了游戏…… No.5（外传总No.15）游戏名：東方人生終 － The end of the life 游戏类型：飞行射击游戏 Produced by：マオ 就如同游戏标题。玩过了游戏真的感觉走到了the end of the life。 故事背景是，幻想乡变成了黑白色，世界被文字符号取代，灵梦要打败侵略者X拯救幻想乡。 故事很奇葩，背景也很奇葩，简直是在精神污染，BGM属于魔性系列，操作手感方面比正作差一截，很沉的感觉。玩过游戏后感觉精神错乱，神志不清，口吐白沫，失去意识…… 哦对了，达成特殊条件可以开启隐藏人物，请努力达成吧~（呸！） 哦还有，游戏如同绀珠传的模式，分为「ゆとりモード」（轻松模式，相当于完美无缺模式）和「レガシーモード」（传统模式），建议从ゆとり尝试…… No.6（外传总No.16）游戏名：（无标题，被称为 红美铃同人横版弹幕） 游戏类型：飞行射击游戏 Produced by：（未知） 猜测是国人做的一个小游戏，素材全部借用正作，大致相当于风神录转了九十度。然而道中（只有一面）是fsl六道中曲，关底跟着boss是五boss曲信仰は儚き人間の為に。首先难度有三个选择easy~hard，不过easy和normal难度没有太大区别。主角红美铃没得选，僚机有四种风味，分别是酸甜苦辣，自然有不同的特性。 No.7（外传总No.17）游戏名：東方奇怪録 游戏类型：动作游戏 Produced by：鬼姫 听名字就很奇怪，这是个什么游戏。故事背景就是灵梦听见外面很吵然后出去看，也没有什么特别的地方。 玩过一会之后还是不明白，游戏到底想让人去达到什么目标。总之就是玩的一头雾水。内容上呢，灵梦有三格血，投掷符札打怪，血量没了就回家了。路上有一些箱子罐子可以打破，里面有补血团子或者钱等物品（作者也说钱并没有什么用）。估计也就是尽量走得远一些吧。有一些日文对话，但是我看不懂…… 作者在说明中说原则上不允许二次分发，那我就先在这里贴上游戏下载链接： 東方奇怪録https://www.freem.ne.jp/win/game/11023 No.8（外传总No.18）游戏名：Tencoinbox hero 游戏类型：动作游戏 Produced by：（作者未留名） 这标题界面……简直精神污染啊！太刺激了吧！ 然而内容却特别怂，不敢放那么精污的东西了，但是游戏却是……虐天子的游戏。你需要控制19，发射子弹打M子，打的越多获得的钱越多。偶尔天上会出现酒瓶，吃了可以加攻击力。嘛，说白了是个发泄情绪的游戏咯？ 退出方式，碰到M子会即死，或者像作者说的达成某条件可以过关。或者直接右上角叉号吧…… 提示，本游戏需要安装RPG VX才可运行，在百度上即可搜到本软件，是一个RPG素材库，安装包形式。 No.9（外传总No.19）游戏名：東方風々偽 游戏类型：飞行射击游戏 Produced by： 这是一个看起来很高大上但是鸡肋的要命的stg游戏。 自机可以在莉格露、美铃、帕秋莉、慧音、妹红、橙、永琳中选择两个组队打关，每个人有不同的射击方式以及符卡，立绘大概是自己画的，很有特点，bgm也很带感。 然而，鸡肋的地方来了。首先操作方式与正作stg略有不同，比如用ctrl是放b，c是低速，shift换人……另外没有决死（大概），弹幕难度偏高，而且我这个版本根本没有做完，只有两关（每一关各自是单独的stage），官网未知，后续做没做也是没法查找…… No.10（外传总No.20）游戏名：Touhou Contra 游戏类型：动作游戏 Produced by：galateasrbb Contra应该都认得吧，就是魂斗罗。这个游戏就是根据魂斗罗改来，不过关卡和敌人什么的都重新设定了，人物换成了东方人物。 这……大概是魂斗罗2代？不管怎么说想法挺好的，但是……这游戏有点难吧？道中难受的一匹，自机（魔理沙）走得比较慢，一不小心就面前来几个刀弹你就跑不了了。游戏我没有发现连发键，所以打起来比较吃力，就像图片上的魔法书，有点硬度，而且还带bug（？），你把它打掉了他还能发弹。另外有时候你吃了枪（游戏里是打P点掉出）会触发一个打不出子弹的bug…… 不知不觉对这个游戏吐槽了这么多，还没说优点……不过这游戏没什么太明显的优点，让我从何说起啊…… 好啦，本期游戏就介绍到这里吧，就像是通宵写文章一样，我这虽然不算“通宵”，也写到了十二点，大概算是半个有思路的享受吧？ 下期专栏的话，也已经在准备中了，不过不知道什么时候能写好呢？或许有你们的支持之后我会更快吧。谢谢大家。 头图pid=47340083 volantis.js(\"https://unpkg.com/pandown\").then(pandown)","categories":[{"name":"游戏","slug":"游戏","permalink":"https://neko-horikawaraiko.github.io/categories/%E6%B8%B8%E6%88%8F/"}],"tags":[{"name":"带你玩东方","slug":"带你玩东方","permalink":"https://neko-horikawaraiko.github.io/tags/%E5%B8%A6%E4%BD%A0%E7%8E%A9%E4%B8%9C%E6%96%B9/"}]},{"title":"【鼓哥】带你玩东方-外传（一）（小游戏篇）","slug":"【鼓哥】带你玩东方-外传（一）（小游戏篇）","date":"2018-08-11T03:59:46.000Z","updated":"2024-11-04T16:19:34.587Z","comments":true,"path":"2018/08/11/【鼓哥】带你玩东方-外传（一）（小游戏篇）/","link":"","permalink":"https://neko-horikawaraiko.github.io/2018/08/11/%E3%80%90%E9%BC%93%E5%93%A5%E3%80%91%E5%B8%A6%E4%BD%A0%E7%8E%A9%E4%B8%9C%E6%96%B9-%E5%A4%96%E4%BC%A0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%88%E5%B0%8F%E6%B8%B8%E6%88%8F%E7%AF%87%EF%BC%89/","excerpt":"","text":"大家好啊~这里是猫耳堀川雷鼓。 在最近的视频中我提到了，有些游戏不太适合做成视频来观看（咕咕咕），所以呢我就开始写这系列的“外传”专栏，介绍一些不太重要的游戏。 本来这个系列的目的，就是让大家了解东方二次同人游戏种类繁多，冷门偏门的更是不少（就是有些不太好玩就是了），作为“开阔眼界”的一种方式。每个游戏我都尽量花时间了解机制，评判可玩性。然而个人力量有限，以及大部分游戏也是没有汉化过的，进度以及评价质量偶尔偏低在所难免，先向大家道歉〈（＿ ＿）〉 本期和刚制作出的第一期视频一样，属于小游戏篇，介绍一些很少人见过的小游戏，包含的是相对有一些可玩性的游戏。一些极度不推荐的游戏我已经分到了另一个文件夹中，大概是不会再见了吧……想见识一下的话可以私聊找我（ 以后的专栏文章大概和这篇的篇幅相近，按照篇幅长短大概介绍10个左右（？）的游戏。待我慢慢更完~……（发出了勤奋的声音） 以后是会好起来的，一定会的……（自我安慰） No.1（外传总No.1）游戏名：こいしの算数教室 游戏类型：教育游戏 Produced by： 如题目，这就是个算数教室，可别和⑨的算数教室联系在一起啊。游戏是flash格式，我从原网站上下载了下来，结果把来源忘了……这游戏应该对于初中生都不难，绝大部分算术题都是加减法，乘除极少。不过想在时间限制内完成还是有点小难度的，别说你算这种题目还需要计算器啊~ 总共50道题目，难度逐渐增加，总共三次错误机会，每道题目给10秒回答时间，亲民度还是可以的。不过更推荐的是恋恋哇（恋恋世界第一！） 做对、做错、通关画面 No.2（外传总No.2）游戏名：魔理沙的魔炮阵 游戏类型：动作游戏 Produced by： 这个是迷走的flash动画&amp;游戏合集中的一个游戏，主角三个魔理沙、幽香、天子，用鼠标画出对应的魔法阵，然后拖拽旋转松开释放魔炮。然后比谁打（用那个字毕竟不好是吧）得远。 迷走这个社团的相关介绍可见这篇文章，是一篇很好的介绍文。 迷走ポタージュ简介：开场秀的揭幕者https://www.bilibili.com/read/cv622745 游戏没有什么技巧。画魔法阵的时候根据提示图像画出来，相似度越高越好；画出来之后旋转魔法阵，速度越快越好。两者结合起来发出魔炮，挑战高分。如果是M子的话，魔炮方向……懂得了吧~ 画魔法阵、发射魔炮 No.3（外传总No.3）游戏名：FlappyRumia 游戏类型：动作游戏 Produced by：song_5007等人 FlappyRumia 听说过FlappyBird吧，这个就是那个的东方版翻版，是一个两三人合作的小品作品。游戏没有开始界面，直接进入游戏。通过点击Rumia上飞下落穿过树桩，和FlappyBird一样。不过这个游戏的判定更大，整个贴图都是判定，要稍微难一些。根据作者说有两大雾，过100个和500个树桩时会有彩蛋，然而我并没有达到过那里…… No.4（外传总No.4）游戏名：Nitori Dungeon 游戏类型：解谜游戏 Produced by：よもぎ 荷取啊，来拿黄瓜吧~这个游戏呢，就是控制荷取通过各种地形，拿到黄瓜。游戏有多少关暂时未知，看最高分的显示的话至少有四位数的关卡。每关都是一面，流程不长，难度逐渐增加。如果本关吃到黄瓜之前未死亡，则吃黄瓜时奖励三点血，每死亡一次扣一点血。游戏每25关自动存档一次，之后可以在主菜单进入。游戏有类似于马里奥的惯性的设定，控制起来需要稍微小心一点。 其中某一关，可以飞行 No.5（外传总No.5）游戏名：東方守銭道 游戏类型：飞行射击游戏 Produced by：はにぐら 妖精身上有钱嘛？有！这个小游戏就是控制灵梦，发射御札打爆妖精，然后获得金币的一个游戏（灵梦你居然连妖精都不放过）。一般飘过小妖精，三月精作为中boss，魔理沙是bonus。开始打掉三月精能获得札弹的提升道具，后面就会掉红心（血）补给，满血三颗心。打发时间的游戏，打正作stg打烦了可以来消遣一下。 No.6（外传总No.6）游戏名：Lost children at the bamboo forest 游戏类型：角色扮演射击游戏 Produced by：White Pikmin 这个游戏挺像以撒的，比较推荐游玩。一开始你扮演在森林中迷路的⑨，与兔子、幽灵斗智斗勇，突破重围（雾），寻找一同迷路在森林里的其他人，就不说是谁了。游戏地图是随机的，不过并不大，运气好的话很快能通关。森林中还能碰见几个有趣的人，给你指点。另外有些特殊路段需要找到同伴才能打开，把没走过的路走走吧。 为避免剧透只放一张游戏截图~ No.7（外传总No.7）游戏名：MARISA MATRIX 游戏类型：飞行射击游戏 Produced by： 游戏是街机风，挺爽的，但是街机特点很明显，第一关简单点，后面难度瞬间提升。火力就是高低速二选一+二选一。弹幕压迫感很强，没有一按就放出来的b，而是一种蓄力雷，首先条件要power攒满，然后蓄力过程中可以消除自身周围的弹幕，蓄满释放全屏伤害。由于作者没做完坑了，只有三关，不过boss还是有点意想不到。 No.8（外传总No.8）游戏名：東方養蜂場 游戏类型：飞行射击游戏 Produced by：魯鈍ジョン 从截图看，像是把星莲船的界面换了个背景做出来的游戏。关卡大概是ex+程度，加出来的是boss的血条而已。开始有难度选择，高难度还是有点挑战性的，我就选个n做演示好了。 著名的“洗衣机”，然而这里弱化了 听名字就是一股怒首领蜂味，想着是不是会和这个游戏有联系，结果送来“洗衣机”这个符卡，确定了有点致敬的意味。boss血条比较多，但是血量并不高，很快就能击破。游戏资源默认给的比较多，n通关还是比较轻松。bgm有点喜感，或许也是为了忘记biubiubiu的痛苦吧（。 No.9（外传总No.9）游戏名：キャプテン・ムラサのケツアンカーオンザゲーム 游戏类型：动作游戏 Produced by： 前方奇葩警告 嘛……这是个不太推荐的游戏，船长拿着锚打倒敌人，敌人是鸭子和马桶……（这都什么跟什么啊）避免这两种敌人入侵到后方，然后拿高分。没有个稍微有趣的故事的话，真的很难让人有兴趣玩下去。 No.10（外传总No.10）游戏名：東方コンプガチャシュミレータ 游戏类型：模拟游戏 Produced by： 别想多了，这是个单机版游戏，所以不会有什么大用的。 大概就是给博丽神社赛钱，然后抽卡的那么一个游戏。人物挺多，不过大概是到正作第十三作的样子，可以用来琢磨画风看立绘（，除此之外我没想到什么其他好用途。 pid=34067344 嘛，这一期就先介绍那么十个小游戏了，写这玩意也是挺累人的，不如直接直播录屏剪辑一下丢上来作为视频简单啊（懒死了好吧）。大概呢，暑假期间还能来一个第二期专栏，再介绍十个左右的游戏~ 另外是我还想说的某些话： 在down站关闭之前，我将很大一部分能下载的游戏转存了起来。所有找到的游戏都来自于网络，我就相当于一个中介。根据实际能否分享情况，有些资源我会放出，有些游戏不会放资源。请尽量理解一下吧。 volantis.js(\"https://unpkg.com/pandown\").then(pandown)","categories":[{"name":"游戏","slug":"游戏","permalink":"https://neko-horikawaraiko.github.io/categories/%E6%B8%B8%E6%88%8F/"}],"tags":[{"name":"带你玩东方","slug":"带你玩东方","permalink":"https://neko-horikawaraiko.github.io/tags/%E5%B8%A6%E4%BD%A0%E7%8E%A9%E4%B8%9C%E6%96%B9/"}]}],"categories":[{"name":"学习","slug":"学习","permalink":"https://neko-horikawaraiko.github.io/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"游戏","slug":"游戏","permalink":"https://neko-horikawaraiko.github.io/categories/%E6%B8%B8%E6%88%8F/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://neko-horikawaraiko.github.io/tags/Java/"},{"name":"Objective-C","slug":"Objective-C","permalink":"https://neko-horikawaraiko.github.io/tags/Objective-C/"},{"name":"带你玩东方","slug":"带你玩东方","permalink":"https://neko-horikawaraiko.github.io/tags/%E5%B8%A6%E4%BD%A0%E7%8E%A9%E4%B8%9C%E6%96%B9/"},{"name":"C++","slug":"C","permalink":"https://neko-horikawaraiko.github.io/tags/C/"}]}